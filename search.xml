<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>scrapy爬虫框架</title>
      <link href="/posts/8386228b/"/>
      <url>/posts/8386228b/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Scrapy框架概念"><a href="#Scrapy框架概念" class="headerlink" title="Scrapy框架概念"></a>Scrapy框架概念</h2><p><code>Scrapy</code>是一个Python编写的开源网络爬虫框架。它是一个被设计用于爬取网络数据、提取结构性数据的框架。</p><p>Scrapy文档地址：<a href="http://scrapy-chs.readthedocs.io/zh_CN/1.0/intro/overview.html">http://scrapy-chs.readthedocs.io/zh_CN/1.0/intro/overview.html</a></p><h2 id="Scrapy框架作用"><a href="#Scrapy框架作用" class="headerlink" title="Scrapy框架作用"></a>Scrapy框架作用</h2><p>少量的代码，就能够快速的抓取。一般用于爬取大量数据。</p><h2 id="Scrapy框架工作流程"><a href="#Scrapy框架工作流程" class="headerlink" title="Scrapy框架工作流程"></a>Scrapy框架工作流程</h2><ol><li><p>回顾request的爬虫流程</p><p><img src="/img/loading.gif" data-original="https://raw.githubusercontent.com/ZekerTop/images/main/20210906/%E5%8E%9F%E5%A7%8B%E7%9A%84%E7%88%AC%E8%99%AB%E6%B5%81%E7%A8%8B.1a7d9jv58bmo.jpg" alt="原始的爬虫流程"></p><p>我们可以在此基础上改写流程：</p><p><img src="/img/loading.gif" data-original="https://raw.githubusercontent.com/ZekerTop/images/main/20210906/%E6%94%B9%E5%86%99%E7%9A%84%E7%88%AC%E8%99%AB%E6%B5%81%E7%A8%8B.ef49avaji3k.png" alt="改写的爬虫流程"></p><p>而上面改写的流程图也更加便于大家去理解scrapy的流程</p></li><li><p>scapy的流程</p><p><img src="/img/loading.gif" data-original="https://raw.githubusercontent.com/ZekerTop/images/main/20210906/scapy%E7%9A%84%E6%B5%81%E7%A8%8B.2rcpyfhjjoo0.png" alt="scapy的流程"></p><h3 id="其流程详细如下："><a href="#其流程详细如下：" class="headerlink" title="其流程详细如下："></a>其流程详细如下：</h3><ol><li>爬虫中起始的url构造成request对象——&gt;爬虫中间件——&gt;引擎&gt;调度器</li><li>调度器把request——&gt;引擎——&gt;下载中间件——&gt;下载器 </li><li>下载器发送请求，获取response响应——&gt;下载中间件——&gt;引擎——&gt;爬虫中间件——&gt;爬虫 </li><li>爬虫提取url地址，组装成request对象——&gt;爬虫中间件——&gt;引擎——&gt;调度器，重复步骤2 </li><li>爬虫提取数据——&gt;引擎——&gt;管道处理和保存数据</li></ol></li></ol><div class="note warning no-icon flat"><p>​    注意：</p><ul><li>图中绿色线条的表示数据的传递</li><li>注意图中中间件的位置，决定了其作用</li><li>注意其中引擎的位置，所有的模块之前相互独立，只和引擎进行交互</li></ul></div><h2 id="各模块的具体作用"><a href="#各模块的具体作用" class="headerlink" title="各模块的具体作用"></a>各模块的具体作用</h2><p><img src="/img/loading.gif" data-original="https://raw.githubusercontent.com/ZekerTop/images/main/20210906/%E5%90%84%E6%A8%A1%E5%9D%97%E4%BD%9C%E7%94%A8.5z8n2kdpqtw0.jpg" alt="各模块作用"></p><p>​    各模块功能：</p><ul><li>引擎 —— 数据和信号的传递</li><li>调度器 —— 任务url队列</li><li>下载器 —— 发送请求、获取响应</li><li>爬虫 —— 起始的url、解析数据</li><li>管道 —— 保存数据</li><li>中间件 —— 定制化操作</li></ul><h2 id="三个内置对象"><a href="#三个内置对象" class="headerlink" title="三个内置对象"></a>三个内置对象</h2><ul><li>request请求对象：由url、method、post_data、headers等构成 </li><li>response响应对象：由url、body status、headers等构成 </li><li>item数据对象：本质是个字典</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>有时pip版本过于老旧不能使用，需要升级pip版本，输入<code>pip install --upgrade pip</code>回车，升级成功</p><p>安装scrapy命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip/pip3 install Scrapy</span><br></pre></td></tr></table></figure><h2 id="scrapy项目开发流程"><a href="#scrapy项目开发流程" class="headerlink" title="scrapy项目开发流程"></a>scrapy项目开发流程</h2><ol><li>创建项目</li><li>生成一个爬虫</li><li>提取数据</li><li>保存数据</li></ol><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>创建scrpy项目的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject &lt;项目名字&gt;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject myspider</span><br></pre></td></tr></table></figure><h2 id="创建爬虫"><a href="#创建爬虫" class="headerlink" title="创建爬虫"></a>创建爬虫</h2><div class="note info flat"><p>通过命令创建出爬虫文件，爬虫文件为主要的代码作业文件，通常一个网站的爬取动作都会在爬虫文件中进行编写。</p></div><p>命令：在<strong>项目路径下</strong>执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy genspider &lt;爬虫名字&gt; &lt;允许爬取的域名&gt;</span><br></pre></td></tr></table></figure><ul><li>爬虫名字：作为爬虫运行时的参数</li><li>允许爬取的域名：为对于爬虫设置的爬取范围，设置之后用于过滤要爬取的url，如果爬取的url与允许的域不通则被过滤掉。如不确定时，可以设置xx.com，后期再进行修改。</li></ul><p>这里我们以<code>豆瓣电影Top250</code>作为示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd myspider</span><br><span class="line">scrapy genspider douban movie.douban.com</span><br></pre></td></tr></table></figure><p>生成的目录和文件结果如下：</p><p><img src="/img/loading.gif" data-original="https://raw.githubusercontent.com/ZekerTop/images/main/20210906/%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E6%80%BB%E8%A7%88.5z4b3r667x00.jpg" alt="目录文件总览"></p><h2 id="完善爬虫"><a href="#完善爬虫" class="headerlink" title="完善爬虫"></a>完善爬虫</h2><p>在上一步生成出来的爬虫文件中编写指定网站的数据采集操作，实现数据提取</p><p><strong>一、在item.py中定义要提取的字段</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyspiderItem</span>(<span class="params">scrapy.Item</span>):</span></span><br><span class="line">    <span class="comment"># define the fields for your item here like:</span></span><br><span class="line">    num = scrapy.Field()<span class="comment"># 电影序号   </span></span><br><span class="line">    name = scrapy.Field()<span class="comment"># 电影名字</span></span><br><span class="line">    score = scrapy.Field()<span class="comment"># 电影评分   </span></span><br><span class="line">    con = scrapy.Field()<span class="comment"># 电影简介</span></span><br></pre></td></tr></table></figure><p><strong>二、在/myspider/myspider/spiders/douban.py 中修改内容如下</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> ..items <span class="keyword">import</span> MyspiderItem</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubanSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;douban&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;movie.douban.com&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;http://movie.douban.com/top250&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        <span class="comment"># 电影名字</span></span><br><span class="line">        name = response.xpath(<span class="string">&#x27;.//div[@id=&quot;content&quot;]/div/div/ol/li[*]/div/div/div/a/span[1]/text()&#x27;</span>).getall()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 电影评分</span></span><br><span class="line">        score = response.xpath(<span class="string">&#x27;.//*[@id=&quot;content&quot;]/div/div[1]s/ol/li[*]/div/div/div/div/span[3]/@content&#x27;</span>).getall()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 美化格式</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">25</span>):</span><br><span class="line">            <span class="comment">#在爬虫中导入并且实例化对象, 使用方法跟使用字典类似</span></span><br><span class="line">            item = MyspiderItem()</span><br><span class="line">            item[<span class="string">&#x27;name&#x27;</span>] = name[i]<span class="comment"># 这里的键名要跟item.py中字段名一致</span></span><br><span class="line">            item[<span class="string">&#x27;score&#x27;</span>] = score[i]</span><br><span class="line">            <span class="built_in">print</span>(item)</span><br><span class="line">            <span class="keyword">yield</span> item      <span class="comment"># yield 会把数据传给管道</span></span><br></pre></td></tr></table></figure><div class="note warning no-icon flat"><p>注意：</p><ul><li>scrapy.Spider爬虫类中必须有名为parse的解析</li><li>如果网站结构层次比较复杂，也可以自定义其他解析函数</li><li>在解析函数中提取的url地址如果要发送请求，则必须属于allowed_domains范围内，但是start_urls中的url地 址不受这个限制，我们会在后续的课程中学习如何在解析函数中构造发送请求</li><li>启动爬虫的时候注意启动的位置，是在项目路径下启动</li><li>parse()函数中使用yield返回数据，注意：解析函数中的yield能够传递的对象只能是：BaseItem, Request, dict, None</li></ul></div><p><strong>三、定位元素以及提取数据、属性值的方法</strong></p><div class="note info flat"><p>解析并获取scrapy爬虫中的数据: 利用xpath规则字符串进行定位和提取</p></div><ol><li><p>response.xpath方法的返回结果是一个类似list的类型，其中包含的是selector对象，操作和列表一样，但是有 一些额外的方法</p></li><li><p>额外方法extract()：返回一个包含有字符串的列表（相当于getall（））</p></li><li><p>额外方法extract_first()：返回列表中的第一个字符串，列表为空没有返回None（相当于get()）</p></li></ol><p><strong>四、response响应对象的常用属性</strong></p><ul><li>response.url：当前响应的url地址</li><li>response.request.url：当前响应对应的请求的url地址</li><li>response.headers：响应头</li><li>response.requests.headers：当前响应的请求头 </li><li>response.body：响应体，也就是html代码，byte类型</li><li>response.status：响应状态码</li></ul><p><strong>五、（改进版）可构造Request对象，并发送请求</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> ..items <span class="keyword">import</span> MyspiderItem</span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span>     <span class="comment"># 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubanSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;douban&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;movie.douban.com&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;http://movie.douban.com/top250&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        <span class="comment"># 电影名字</span></span><br><span class="line">        name = response.xpath(<span class="string">&#x27;.//div[@id=&quot;content&quot;]/div/div/ol/li[*]/div/div/div/a/span[1]/text()&#x27;</span>).getall()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 电影评分</span></span><br><span class="line">        score = response.xpath(<span class="string">&#x27;.//*[@id=&quot;content&quot;]/div/div[1]/ol/li[*]/div/div/div/div/span[2]/text()&#x27;</span>).getall()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 电影链接</span></span><br><span class="line">        link = response.xpath(<span class="string">&#x27;.//*[@id=&quot;content&quot;]/div/div[1]/ol/li[*]/div/div[2]/div[1]/a/@href&#x27;</span>).getall()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 美化格式</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">25</span>):</span><br><span class="line">            item = MyspiderItem()</span><br><span class="line">            <span class="keyword">global</span> num</span><br><span class="line">            <span class="keyword">if</span> num == i:        <span class="comment"># 防止乱序</span></span><br><span class="line">                item[<span class="string">&#x27;num&#x27;</span>] = num+<span class="number">1</span></span><br><span class="line">                item[<span class="string">&#x27;name&#x27;</span>] = name[i]</span><br><span class="line">                item[<span class="string">&#x27;score&#x27;</span>] = score[i]</span><br><span class="line">                <span class="comment"># print(item)</span></span><br><span class="line">                <span class="comment"># yield item      # yield 会把数据传给管道</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># print(link[i])</span></span><br><span class="line">                <span class="comment"># 对获取的电影链接去发送请求</span></span><br><span class="line">                <span class="keyword">yield</span> scrapy.Request(link[i], callback=self.parse_data, meta=&#123;<span class="string">&#x27;item2&#x27;</span>: item&#125;)</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 翻页操作一</span></span><br><span class="line">        next_url = response.xpath(<span class="string">&#x27;.//*[@id=&quot;content&quot;]/div/div[1]/div[2]/span[3]/a/@href&#x27;</span>).get()</span><br><span class="line">        <span class="comment"># 拼接</span></span><br><span class="line">        next_url = <span class="string">&#x27;https://movie.douban.com/top250&#x27;</span> + next_url</span><br><span class="line"></span><br><span class="line">        <span class="comment"># # 翻页操作二</span></span><br><span class="line">        <span class="comment"># # n_url = response.xpath(&quot;//a[text()=&#x27;后页&gt;&#x27;]/@href&quot;)</span></span><br><span class="line">        <span class="comment"># # 直接使用response携带残缺的url</span></span><br><span class="line">        <span class="comment"># # yield response.follow(n_url, callback=self.parse)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 手动构造请求对象，指定解析起始url的parse方法</span></span><br><span class="line">        <span class="comment"># yield scrapy.Request(next_url, callback=self.parse)   # 数据过多，防止被反爬，先注释掉  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析详情的函数(自定义)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_data</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        item = response.meta.get(<span class="string">&#x27;item2&#x27;</span>)   <span class="comment"># 或 item = response.meta[&#x27;item2&#x27;]</span></span><br><span class="line">        <span class="comment"># print(item)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 提取详情简介</span></span><br><span class="line">        <span class="comment"># 有的节点不一样，有些是div/span   有些div/span/span</span></span><br><span class="line">        <span class="comment"># // *[ @ id = &quot;link-report&quot;] / span[1] / text()</span></span><br><span class="line">        <span class="comment"># // *[ @ id = &quot;link-report&quot;] / span[1] / span / text()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># content = response.xpath(&#x27;//*[@id=&quot;link-report&quot;]/span[1]/span/text()&#x27;).get()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># string(path) 方法会提取父标签下的文本内容</span></span><br><span class="line">        <span class="comment"># path  就是父标签的路径</span></span><br><span class="line">        content = response.xpath(<span class="string">&#x27;string(.//*[@id=&quot;link-report&quot;]/span)&#x27;</span>).get()</span><br><span class="line">        <span class="comment"># print(&#x27;详情:&#x27;, content)</span></span><br><span class="line">        item[<span class="string">&#x27;con&#x27;</span>] = content.strip()  <span class="comment"># strip()去除左右两边的空格</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure><p>scrapy.Request()中的常见参数解释</p><table><thead><tr><th>参数</th><th>解释</th><th>是否必填</th></tr></thead><tbody><tr><td>url</td><td>请求的url</td><td>是</td></tr><tr><td>callback</td><td>回调函数，用于接收请求后的返回信息，若没指定，则默认为parse()函数</td><td>是</td></tr><tr><td>meta</td><td>方法之间以字典形式传递参数，这个参数一般也可在<code>middlewares</code>中处理</td><td>否</td></tr><tr><td>method</td><td>http请求的方式，默认为GET请求，一般不需要指定。若需要POST请求，建议使用用<code>scrapy.FormRequest()</code></td><td>否</td></tr><tr><td>headers</td><td>dict类型，请求头信息，一般在settings中设置即可，也可在middlewares中设置</td><td>否</td></tr><tr><td>cookies</td><td>dict或list类型，请求的cookie</td><td>否</td></tr><tr><td>dont_filter</td><td>是否开启过滤，默认关闭，开启之后爬取过的url,下一次不会再爬取</td><td>否</td></tr><tr><td>errback</td><td>抛出错误的回调函数并打印出来，错误包括404，超时，DNS错误等</td><td>否</td></tr></tbody></table><div class="note success no-icon flat"><p>发送post请求</p><p><code>scrapy.FormRequest(url，callback, formdata)</code></p><p>FormRequest 类为Request的子类，用于POST请求，其他参数与Request一样，其中新增的<code>formdata</code>是dict类型，相当于meta。</p></div><h2 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h2><div class="note info flat"><p>利用管道pipeline来处理（保存）数据</p></div><p><strong>一、在pipelines.py文件中定义对数据的操作</strong></p><ol><li>定义一个管道类</li><li>重写管道类的process_item方法</li><li>process_item方法处理完item之后必须返回给引擎</li><li>定义数据的保存逻辑</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyspiderPipeline</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span>(<span class="params">self, spider</span>):</span></span><br><span class="line">        self.file = <span class="built_in">open</span>(<span class="string">&#x27;douban.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span>(<span class="params">self, item, spider</span>):</span></span><br><span class="line">        <span class="comment"># with open(&#x27;douban250.txt&#x27;, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) as f:</span></span><br><span class="line">        <span class="comment">#     f.write(str(item) + &#x27;\n&#x27;)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 把传递数据的载体item对象转为一个字典</span></span><br><span class="line">        dic = <span class="built_in">dict</span>(item)</span><br><span class="line">        js_data = json.dumps(dic, ensure_ascii=<span class="literal">False</span>) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        self.file.write(js_data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span>(<span class="params">self, spider</span>):</span></span><br><span class="line">        self.file.close()</span><br></pre></td></tr></table></figure><ul><li>def open_spider(self, spider) —— 爬虫<code>开启</code>时执行一次，可用来<code>打开</code>文件</li><li>def process_item(self, item, spider) ——实现数据的写入操作</li><li>def close_spider(self, spider) —— 爬虫<code>关闭</code>时执行一次，可用来<code>关闭</code>文件</li></ul><p><strong>二、在settings.py 配置启用管道</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启用管道配置</span></span><br><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">   <span class="string">&#x27;myspider.pipelines.MyspiderPipeline&#x27;</span>: <span class="number">300</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绕过robots规则，直接爬取页面</span></span><br><span class="line"><span class="comment"># Obey robots.txt rules</span></span><br><span class="line">ROBOTSTXT_OBEY = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加User-agent</span></span><br><span class="line"><span class="comment">#USER_AGENT = &#x27;myspider (+http://www.yourdomain.com)&#x27;</span></span><br><span class="line">USER_AGENT = <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加cookie</span></span><br><span class="line">COOKIES_ENABLED = <span class="literal">False</span></span><br><span class="line">DEFAULT_REQUEST_HEADERS = &#123;</span><br><span class="line">  <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;en&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>setting.py一般都会将<code>管道配置</code>注释掉，取消注释即可。</p><p>配置项中键为使用的管道类，管道类使用<code>.</code>进行分割，第一个为<code>项目目录</code>，第二个为<code>文件</code>，第三个为<code>定义的管道类</code>。 配置项中值为管道的使用顺序，设置的数值<code>越小越优先执行</code>，该值一般设置为1000以内。</p><h2 id="运行爬虫"><a href="#运行爬虫" class="headerlink" title="运行爬虫"></a>运行爬虫</h2><p>命令：在<strong>项目目录下</strong>执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl &lt;爬虫名字&gt;(--nolog)</span><br></pre></td></tr></table></figure><div class="note orange icon flat"><i class="note-icon fas fa-battery-half"></i><p>—nolog：不显示调试信息，不加即默认显示</p></div><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl douban --nolog</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><img src="/img/loading.gif" data-original="https://raw.githubusercontent.com/ZekerTop/images/main/20210906/运行结果.5s2ykwcn5bk0.jpg" alt="运行结果" style="zoom:67%;" /><h2 id="crawlspider爬虫"><a href="#crawlspider爬虫" class="headerlink" title="crawlspider爬虫"></a>crawlspider爬虫</h2><p>回顾之前的代码，有很多一部分时间都寻找下一页的url地址或者内容的url地址上面，而这个过程能更简单吗？</p><p>需求思路：</p><ol><li>从response中提取所有的满足规则的url地址</li><li> 自动的构造自己requests请求，发送给引擎</li></ol><p>而<code>crawlspider</code>就可以满足上述需求，能够匹配满足条件的url地址，组装成Reuqest对象后自动发送给引擎， 同时能够指定callback函数，</p><p>即：crawlspider爬虫可以按照规则自动获取连接</p><div class="note info no-icon flat"><p>Scrapy框架中分两类爬虫，Spider类和CrawlSpider类。CrawlSpider继承自spider，只不过是在之前的基础上增加了新的功能。可以定义爬取的url的规则，以后scrapy碰到满足条件的url都进行爬取，而不用手动yield Request。</p></div><h2 id="创建crawlspider爬虫并观察爬虫内的默认内容"><a href="#创建crawlspider爬虫并观察爬虫内的默认内容" class="headerlink" title="创建crawlspider爬虫并观察爬虫内的默认内容"></a>创建crawlspider爬虫并观察爬虫内的默认内容</h2><p><strong>一、创建crawlspider爬虫：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy genspider -t crawl douban movie.douban.com</span><br></pre></td></tr></table></figure><p><strong>二、spider中默认生成的内容如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> scrapy.linkextractors <span class="keyword">import</span> LinkExtractor</span><br><span class="line"><span class="keyword">from</span> scrapy.spiders <span class="keyword">import</span> CrawlSpider, Rule</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubnSpider</span>(<span class="params">CrawlSpider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;douban&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;movie.douban.com&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;http://movie.douban.com/&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    rules = (</span><br><span class="line">        Rule(LinkExtractor(allow=<span class="string">r&#x27;Items/&#x27;</span>), callback=<span class="string">&#x27;parse_item&#x27;</span>, follow=<span class="literal">True</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_item</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        item = &#123;&#125;</span><br><span class="line">        <span class="comment">#item[&#x27;domain_id&#x27;] = response.xpath(&#x27;//input[@id=&quot;sid&quot;]/@value&#x27;).get()</span></span><br><span class="line">        <span class="comment">#item[&#x27;name&#x27;] = response.xpath(&#x27;//div[@id=&quot;name&quot;]&#x27;).get()</span></span><br><span class="line">        <span class="comment">#item[&#x27;description&#x27;] = response.xpath(&#x27;//div[@id=&quot;description&quot;]&#x27;).get()</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><p><strong>三、观察其与跟普通的scrapy.spider的区别</strong></p><div class="note danger flat"><p>在crawlspider爬虫中，没有parse函数</p></div><p>重点在<code>rules</code>中： </p><ol><li>rules是一个元组或者是列表，包含的是Rule对象</li><li>Rule表示规则，其中包含LinkExtractor，callback和follow等参数 </li><li>LinkExtractor:连接提取器，可以通过<code>正则</code>或者是<code>xpath</code>来进行url地址的匹配 </li><li>callback :表示经过连接提取器提取出来的url地址响应的回调函数，可以没有，没有表示响应不会进行回调函数 的处理 </li><li>follow：连接提取器提取的url地址对应的响应是否还会继续被rules中的规则进行提取，True表示会，Flase表示不会</li></ol><p><strong>四、crawlspider使用的注意点</strong></p><ol><li>除了用命令 <code>scrapy genspider -t crawl &lt;爬虫名&gt;  &lt;allowed_domail&gt;</code>创建一个crawlspider的模板，页可以手动创建</li><li>crawlspider中<code>不能</code>再有以<code>parse</code>为名的数据提取方法，该方法被crawlspider用来实现基础url提取等功能</li><li>Rule对象中LinkExtractor为固定参数，其他callback、follow为可选参数</li><li> 不指定callback且follow为True的情况下，满足rules中规则的url还会被继续提取和请求</li><li>如果一个被提取的url满足多个Rule，那么会从rules中选择一个满足匹配条件的Rule执行</li></ol><p><strong>五、crawlspider其他知识点的了解</strong></p><ol><li>链接提取器<code>LinkExtractor</code>的更多常见参数<ul><li>allow：满足括号中的’re’表达式的url会被提取，如果为空，则全部匹配 </li><li>deny：满足括号中的’re’表达式的url不会被提取，优先级高于allow </li><li>allow_domains：会被提取的链接的domains(url范围)，如： [‘hr.tencent.com’, ‘baidu.com’] </li><li>deny_domains：不会被提取的链接的domains(url范围) </li><li>restrict_xpaths：使用xpath规则进行匹配，和allow共同过滤url，即xpath满足的范围内的url地址会被 提取，如： restrict_xpaths=’//div[@class=”pagenav”]’</li></ul></li><li><code>Rule</code>常见参数<ul><li>LinkExtractor：链接提取器，可以通过正则或者是xpath来进行url地址的匹配 </li><li>callback：表示经过连接提取器提取出来的url地址响应的回调函数，可以没有，没有表示响应不会进行回调 函数的处理 </li><li>follow：连接提取器提取的url地址对应的响应是否还会继续被rules中的规则进行提取，默认True表示会， Flase表示不会 </li><li>process_links：当链接提取器LinkExtractor获取到链接列表的时候调用该参数指定的方法，这个自定义方 法可以用来过滤url，且这个方法执行后才会执行callback指定的方法</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记（3）</title>
      <link href="/posts/6cb57fa2/"/>
      <url>/posts/6cb57fa2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Redis应用问题"><a href="#Redis应用问题" class="headerlink" title="Redis应用问题"></a>Redis应用问题</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>用户的数据一般都是存储于数据库中，数据库的数据是落在磁盘上的，磁盘的读写速度可以说是计算机里硬件中最慢的了。</p><p>当用户的请求，都访问数据库的话，请求数量一上来，数据库很容易就崩溃，所以为了避免用户直接访问数据库，会用<code>Redis</code>作为<code>缓存层</code>。</p><p><code>Redis</code>是内存数据库，将数据库的数据缓存在<code>Redis</code>中，相当于数据缓存在内存中，内存的读写速度比硬盘快好几个数量级，这也大大提高了系统性能。</p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210814/缓存层与存储层.id06cl9w4q8.png" alt="缓存层与存储层" style="zoom: 67%;" /><p>引入了缓存层，随之而来的是有关缓存异常的一些问题：<code>缓存穿透</code>、<code>缓存击穿</code>、<code>缓存雪崩</code>、<code>缓存颠簸</code>、<code>缓存预热</code>、<code>缓存降级</code>……而前三个也正是有些企业面试经常考察的问题。</p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>缓存层</code>和<code>数据库</code>中<code>都没有</code>的数据，而用户不断发起请求，导致请求在访问缓存时，发现缓存缺失，再去访问数据库，如果从数据库中查不到该数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存保护后端持久的意义。</p><p>而我们数据库的 id 都是1开始自增上去的，如发起为id值为 -1 的数据或 id 为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大，严重会击垮数据库。</p><h3 id="造成原因"><a href="#造成原因" class="headerlink" title="造成原因"></a>造成原因</h3><ol><li>自身业务代码或者数据出现问题（例如：set 和 get 的key不一致，数据被误删除）</li><li>一些恶意攻击、爬虫等造成大量空命中（爬取线上商城商品数据，超大循环递增商品的ID）</li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><strong>一、非法请求的限制</strong></p><p>当有大量恶意请求访问不存在的数据时，也会发生缓存穿透，因此在API入口处我们要<code>判断请求参数是否合理，请求参数是否含有非法字符、请求字段是否存在</code>，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存层和数据库。</p><p><strong>二、缓存空对象</strong></p><p>缓存空对象：是指在持久层没有命中的情况下，对key进行set （key,null）</p><p>缓存空对象会有<code>两个问题</code>：</p><p>第一，value为null不代表不占用内存空间，空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间，<code>比较有效的方法</code>是针对这类数据设置一个较短的过期时间，让其自动剔除。</p><p>第二，缓存层和存储层的数据会有一段时间窗口的<code>不一致</code>，可能会对业务有一定影响。</p><p>例如过期时间设置为5分钟，如果此时存储层添加了这个数据，那这段时间内就会出现缓存层和存储层数据的不一致，此时可以利用<code>消息系统</code>或者其他方式清除掉缓存层中的空对象</p><p><strong>三、布隆过滤器(Bloom Filter)拦截</strong></p><p>布隆过滤器实际上是一个很长的<code>二进制向量</code>和一系列<code>随机映射函数</code>，其实也可以说是由<code>初始值都为0的位图数组</code>和<code>N个哈希函数</code>两部分组成的。布隆过滤器可以用于检索一个元素是否在一个集合中。</p><p>优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><p>在写入数据库数据时，将存在的key使用布隆过滤器<code>标记一下</code>，然后在用户请求到来时，业务线程确认缓存失效后，可以<code>通过查询布隆过滤器快速判断数据是否存在</code>，如果不存在，就不用通过查询数据库来判断数据是否存在。</p><p>即使发生了缓存穿透，大量请求只会查询<code>Redis</code>和<code>布隆过滤器</code>，而不会查询数据库，这就拦截了很多注定没有结果的查询，降低了数据库的负载，保证了数据库正常运行。</p><p>布隆过滤器会通过<code>3个操作</code>完成标记：</p><ol><li>使用N个哈希函数分别对数据做哈希计算，得到N个哈希值；</li><li>将第一步得到的N个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置；</li><li>将每个哈希值在位图数组的对应位置的值设置为1；</li></ol><p>举个栗子：假设有一个位图数组长度为 8，哈希函数 3 个的布隆过滤器。<br></p><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210814/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BE%8B%E5%AD%90.4jkr5jfjjme0.png" alt="布隆过滤器例子"></p><p><br>在数据库写入数据 x 后，把数据 x 标记在布隆过滤器时，数据 x 会被 3 个哈希函数分别计算出 3 个哈希值，然后在对这 3 个哈希值对 8 取模，假设取模的结果为 1、4、6，然后把位图数组的第 1、4、6 位置的值设置为 1。<strong>当应用要查询数据 x 是否数据库时，通过布隆过滤器只要查到位图数组的第 1、4、6 位置的值是否全为 1，只要有一个为 0，就认为数据 x 不在数据库中</strong>。</p><p>布隆过滤器由于是基于<code>哈希函数</code>实现查找的，高效查找的同时<code>存在哈希冲突的可能性</code>，比如数据 x 和数据 y 可能都落在第 1、4、6 位置，而事实上，可能数据库中并不存在数据 y，存在误判的情况。</p><p>所以，<strong>查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据</strong>。虽有一定的误识别率，但没有识别错误的情形。</p><div class="note info flat"><p>布隆过滤器适用场景：爬虫系统url去重、垃圾邮件过滤、黑名单….</p></div><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>存在<code>某个</code>热点数据key，例如商城秒杀活动、热搜等等。</p><p>用户<code>大并发集中</code>对这一个<code>key</code>进行访问，<code>缓存层</code>在不停地扛着大并发，而当这个 key 在<code>失效过期</code>的瞬间，<code>持续</code>的<code>大并发</code>就会穿破缓存层，直接访问数据库，此时就像在一个完好无损的桶上凿开了一个洞。</p><p>当发生缓存击穿的时候，数据库的查询压力会倍增，导致大量的请求阻塞。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p><strong>一、预先设置热点数据</strong></p><p>在Redis高峰访问之前，把一些热点数据提前存入redis中，增加热点数据key的过期时间</p><p><strong>二、实时调整</strong></p><p>现场监控哪些数据被频繁访问，实时调整key的过期时间</p><p><strong>三、永不过期</strong></p><p>不给热点数据设置过期时间，若数据需要更新的话，可以在后台开启一个异步线程，发现过期的 key 直接重写缓存即可</p><p><strong>四、分布式互斥锁</strong></p><p>当业务线程在处理用户请求时，<strong>如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存</strong>（<u>从数据库读取数据，再将数据更新到 Redis 里</u>），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</p><p>实现互斥锁的时候，最好<code>设置超时时间</code>，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现<code>无响应</code>现象。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setex &lt;key&gt; &lt;second&gt; &lt;value&gt;//上锁并设置过期时间</span><br><span class="line">set &lt;key&gt; &lt;value&gt; nx ex 10//nx: 上锁, ex: 过期时间, 10: 过期时间为10秒</span><br></pre></td></tr></table></figure><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210814/互斥锁.75h7xq3fu9c0.png" alt="互斥锁" style="zoom:67%;" /><p>优点：较好地降低后端存储负载，并在一致性上做得比较好。</p><p>缺点：当缓存失效的时候，同一时间只有一个线程读数据库然后回写缓存，其他线程都处于阻塞状态。如果是高并发场景，大量线程阻塞会降低吞吐量。</p><div class="note info no-icon flat"><p>关于穿透与击穿的一些小知识<br>学完上面的<code>缓存穿透</code>与<code>缓存击穿</code>，有些人可能时间久了容易忘记（记忆力好的可以忽略），况且两个词字面上看也有点相近（小声bb），于是就去查了一些资料。<br> <code>穿透</code>，本义可指：贯穿，经过，通过；<br><code>击穿</code>，第一联想是击穿电压，电击穿等等，其实大多也是指在<code>高压力下</code>的破坏和穿孔现象。<br>单看两词，意思相近，但主要区别在于所受的<code>环境压力</code>。</p></div><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>与缓存击穿相似，但区别在于<code>缓存雪崩</code>针对<code>大量key缓存</code>，而<code>缓存击穿则</code>则是针对<code>某个key</code>。</p><p>由于<code>缓存层</code>承载着大量请求，有效地<code>保护</code>了存储层，但是如果<code>缓存层</code>由于某些原因不可用（宕机）或者<code>大量缓存</code>由于<code>过期时间相同</code>在同一时间段失效（大批key失效/热点数据失效），<code>大量请求</code>直接到达存储层，存储层压力过大导致系统雪崩。</p><p>同一时间大面积失效，那一瞬间Redis跟没有一样，那这个数量级别的请求直接打到数据库几乎是<code>灾难性</code>的。</p><h3 id="造成原因-1"><a href="#造成原因-1" class="headerlink" title="造成原因"></a>造成原因</h3><ol><li>大量数据同时过期</li><li>Redis故障宕机</li></ol><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="针对大量数据同时过期"><a href="#针对大量数据同时过期" class="headerlink" title="针对大量数据同时过期"></a>针对大量数据同时过期</h4><p><strong>一、均匀设置过期时间</strong></p><p>预防大面积的 key 同时失效，可以给不同的 key 过期时间加上随机值，让缓存失效的时间点尽量均匀，这样可以保证数据不会在同一时间大面积失效。</p><p><strong>二、分布式互斥锁</strong></p><p>保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。与<code>缓存击穿</code>的措施相似。</p><p><strong>三、双key策略</strong></p><p>对缓存数据可以使用两个 key，一个是<code>主 key，会设置过期时间</code>，一个是<code>备 key，不会设置过期</code>，它们只是 key 不一样，但是 value 值是一样的，相当于给缓存数据做了个副本。</p><p>当业务线程访问不到<code>主 key </code>的缓存数据时，就直接返回<code>备 key </code>的缓存数据，然后在更新缓存的时候，同时<code>更新 主 key 和 备 key 的数据</code>。</p><p><strong>四、后台更新缓存</strong></p><p>业务线程不再负责更新缓存，缓存也不设置有效期，而是<code>让缓存“永久有效”</code>，并将更新缓存的工作<code>交由后台线程定时更新</code>。</p><p>事实上，缓存数据不设置有效期，并不是意味着数据一直能在内存里，因为<code>当系统内存紧张的时候，有些缓存数据会被“淘汰”</code>，而在缓存被“淘汰”到下一次后台定时更新缓存的这段时间内，业务线程读取缓存失败就返回空值，业务的视角就以为是数据丢失了。</p><p>如何解决上面的问题呢？</p><ol><li><p><code>后台线程</code>不仅负责定时更新缓存，而且也负责<code>频繁地检测缓存是否有效</code>，检测到缓存失效了，可能原因是系统紧张而被淘汰的，于是就要马上<code>从数据库读取数据，并更新到缓存</code>。</p><p>这种方式的检测时间间隔不能太长，太长也导致用户获取的数据是一个空值而不是真正的数据，所以检测的间隔最好是<code>毫秒级</code>的，但是总归是有个间隔时间，用户体验一般。</p></li><li><p>在业务线程发现缓存数据失效后（缓存数据被淘汰），<code>通过消息队列发送一条消息通知后台线程更新缓存</code>，后台线程收到消息后，在更新缓存前可以判断缓存是否存在，存在就不执行更新缓存操作；不存在就读取数据库数据，并将数据加载到缓存。</p><p>这种方式相比第一种方式缓存的更新会更及时，用户体验也比较好。</p></li></ol><h4 id="针对Redis故障宕机"><a href="#针对Redis故障宕机" class="headerlink" title="针对Redis故障宕机"></a>针对Redis故障宕机</h4><p><strong>一、服务熔断或请求限流机制</strong></p><p>当Redis故障宕机而导致缓存雪崩问题时，我们可以启动<code>服务熔断</code>机制，<code>暂停业务应用对缓存服务的访问，直接返回错误</code>，不用再继续访问数据库，从而降低对数据库的访问压力，保证数据库系统的正常运行，然后等到 <code>Redis 恢复正常</code>后，再允许业务应用访问缓存服务。</p><p><code>服务熔断机制</code>是保护数据库的正常允许，但是暂停了业务应用访问缓存服务系统，全部业务都<code>无法正常工作</code>。</p><p>为了减少对业务的影响，我们可以启用<code>请求限流</code>机制，只将<code>少部分请求</code>发送到数据库进行处理，再多的请求就在入口直接拒绝服务，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。</p><p><strong>二、构建Redis缓存高可靠集群</strong></p><p>服务熔断或请求限流机制是<code>缓存雪崩发生后</code>的应对方案，我们最好通过<code>主从节点的方式构建 Redis 缓存高可靠集群</code>。</p><p>如果 Redis 缓存的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务，避免了由于 Redis 故障宕机而导致的缓存雪崩问题。</p><h2 id="缓存颠簸"><a href="#缓存颠簸" class="headerlink" title="缓存颠簸"></a>缓存颠簸</h2><p><code>缓存颠簸</code>，也被称为“缓存抖动”，可以看作一种比“雪崩”更轻微的故障，但是也会在一段时间内对系统造成冲击和性能影响，一般是由<code>缓存节点故障</code>导致的。</p><p>业内推荐的做法是通过一致性Hash算法来解决问题。</p><h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><p>即系统上线后，先将<code>相关的数据构建到缓存中</code>，这样就可以避免用户请求的时候直接查库。</p><p>这部分预热的数据主要取决于<code>访问量</code>和<code>数据量大小</code>。如果数据的访问量不大的话，那么就没必要做预热，都没什么多少请求了，直接按正常的缓存读取流程执行就好。</p><p>访问量大的话，也要看数据的大小来做预热措施。</p><ol><li>数据量不大的时候，系统启动的时候<code>进行加载缓存</code>动作，这种数据一般可以是电商首页的运营位之类的信息；</li><li>数据量大的时候，设置一个<code>定时任务脚本</code>，进行<code>缓存的刷新</code>；</li><li>数据量太大的时候，优先保证热点数据进行<code>提前加载到缓存</code>，并且确保访问期间不能更改缓存，比如用定时器在秒杀活动前30分钟就把商品信息之类的刷新到缓存，同时规定后台运营人员不能在秒杀期间更改商品属性。</li></ol><h2 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h2><p>即<code>缓存失效</code>或<code>缓存服务器挂掉</code>的情况下，<code>不去访问数据库</code>，直接返回默认数据或访问服务的内存数据。</p><p>在项目实战中通常会将部分热点数据缓存到服务的内存中，类似 <code>HashMap</code>、<code>Guava</code> 这样的工具，一旦缓存出现异常，可以直接使用服务的内存数据，从而避免数据库遭受巨大压力。</p><p>当然，这样的操作对于业务是<code>有损害</code>的，<code>分布式系统</code>中很容易出现<code>数据不一致问题</code>。</p><p>所以，一般这种情况下，我们都优先保证从<code>运维角度</code>确保缓存服务器的<code>高可用性</code>。比如 Redis 的部署采用集群方式，同时做好备份。总之，尽量避免出现降级的影响。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记（2）</title>
      <link href="/posts/1bb24f34/"/>
      <url>/posts/1bb24f34/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note orange icon flat"><i class="note-icon fas fa-bullhorn"></i><p>前方多图提醒，请耐心等待加载或刷新页面，已参考多种资料，作图不易，且看且珍惜。（快累趴了）</p></div><h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>主从复制</code>，主机数据更新后根据配置和策略，自动同步道备机的<code>master/slaver机制</code>，<code>Master以写为主</code>，<code>Slave以读为主</code>。</p><p>其作用有以下几点：</p><ul><li>读写分离：主服务器负责写，各从服务器负责读，即主机写，从机读</li><li>容灾快速恢复：主从多台服务器进行持久化操作，任意一台服务器宕机也不会影响数据恢复，有效避免了单点故障问题，使数据持久化更加安全</li><li>其他：主从复制是实现哨兵模式和Redis集群的前提</li></ul><h2 id="实现主从复制"><a href="#实现主从复制" class="headerlink" title="实现主从复制"></a>实现主从复制</h2><p>每一台<code>Redis</code>服务器启动时，默认都为主服务器（master）,可通过命令<code>info replcation</code>查看</p><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/1.5foiw2sgbgo0.jpg" alt="1"></p><ol><li><p>配置文件修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /myredis                # 创建文件夹存储配置文件</span><br><span class="line">cd /myredis# 进入文件夹</span><br><span class="line">cp /etc/redis.conf /myredis/redis.conf# 复制原配置文件，以便操作</span><br></pre></td></tr></table></figure><p>创建<code>reids6379.conf</code>、<code>reids6380.conf</code>、<code>reids6381.conf</code>文件，在文件中填入以下信息</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include /myredis/redis.<span class="keyword">conf</span></span><br><span class="line">pidfile /var/run/redis_端口号.pid</span><br><span class="line">port （端口号）</span><br><span class="line">dbfilename dump（端口号）.rdb</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/2.6wgs4wui72w0.jpg" alt="2"></p></li><li><p>启动redis服务器</p><p>新建窗口通过<code>redis-cli -p 端口号</code>进入各自的客户端</p><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/3.36sncsb6o840.jpg" alt="3"></p></li><li><p>使用命令实现主从关系（配从不配主）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure><p>详情如下图所示</p><p>从节点：</p><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E4%BB%8E%E8%8A%82%E7%82%B9.31rkn6xum640.jpg" alt="从节点"></p><p>主节点：</p><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E4%B8%BB%E8%8A%82%E7%82%B9.124i7i3mtvg0.jpg" alt="主节点"></p></li><li><p>主从关系实现后，验证是否实现数据复制</p><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6.3458jbrjayg0.jpg" alt="数据复制"></p></li></ol><h2 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><p>在Redis2.8之前同步方式都以<code>全量方式</code>同步，但之后为了提高效率，数据复制方式分为两种：<code>全量复制</code>和<code>部分复制</code>。</p><ul><li>全量复制：将主服务器中的数据，全部同步到从服务器中，一般是在从服务器启动初始化数据的时候进行全量同步</li><li>部分复制：将未同步的增量数据，同步到从服务器，无需再全部复制一遍，一般用于因网络中断等无法同步数据的情况下，待恢复正常之后，将中断期间的数据进行部分同步</li></ul><h3 id="全量复制图解"><a href="#全量复制图解" class="headerlink" title="全量复制图解"></a>全量复制图解</h3><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/全量复制.40tonu0t4to0.png" alt="全量复制" style="zoom: 50%;" /><p>解释说明：</p><p>1、从节点断开连接后，发送同步请求<code>psync</code>尝试建立连接</p><p>2、主节点向从节点发送信息，获取<code>runid</code>和<code>offset</code></p><p>3、主节点fork子进程将全部数据生成<code>RDB文件</code></p><p>4、主节点期间接收到的<code>write</code>命令存入到复制缓冲区</p><p>5、当主节点<code>RDB文件</code>完成后发送给从节点</p><p>6、从节点接受<code>RDB文件</code>后，清空旧数据，加载RDB数据到内存中（即直接将其作为数据文件）</p><p>7、主节点发送缓冲区内的数据到从节点</p><p>8、从节点接受复制缓冲区命令并执行，最后同步到最新数据中</p><h3 id="部分复制图解"><a href="#部分复制图解" class="headerlink" title="部分复制图解"></a>部分复制图解</h3><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/部分复制.6cn0kqkut9o0.png" alt="部分复制" style="zoom:50%;" /><p>解释说明：</p><p>1、当主从服务器之间由于网络中断后，从节点会尝试连接主节点</p><p>2、重连期间主节点接收到的<code>write</code>命令会存入到复制缓冲区</p><p>3、当网络恢复后，从节点成功连接主节点，由于之前从节点保存了主节点的<code>runid</code> 和<code>offset</code>，所以只需要发送命令 <code>psync &#123;runid&#125; &#123;offset&#125;</code>即可</p><p>4、主节点接收到从节点的请求，会先验证请求的<code>runid</code>是否和自身的的 <code>runid</code>匹配，不匹配则进行<code>全量复制</code>，其后查看请求的<code>offset</code>在自身复制缓冲区查找，如果偏移量之后的数据存在缓冲区中，则对从节点发送<code> +CONTINUE</code> 响应，表示可以进行部分复制。</p><p>5、当从节点传递过来的runid和offset验证通过时，则进行部分复制，并记录新的<code>offset</code></p><div class="note info flat"><p>PS：当主机宕机时，主从关系仍存在，各从机中的主机信息不会发生改变，主机重启后，其从机信息与宕机前的一致</p></div><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><h3 id="一、-薪火相传"><a href="#一、-薪火相传" class="headerlink" title="一、    薪火相传"></a><strong>一、    薪火相传</strong></h3><p>有三个节点ABC，A为主机，B为A的从机，C为B的从机。</p><ol><li>主机A无法对C进行主从复制</li><li>当主机A存活时，B、C都不可写数据，只能读数据</li><li>主机A宕机后，B、C仍不可写数据，直到B使用<code>slaveof no one</code>命令后，即下面所讲的<code>反客为主</code>模式，B可以写数据，C可以读取B写的数据</li></ol><p><strong>官方概述</strong>：上一个<code>slave</code>（从机）可以是下一个<code>slave</code>（从机）的<code>master</code>（主机），<code>slave</code>同样可以接收其他slaves的连接和同步请求，那么该<code>slave</code>作为了链条中下一个的<code>master</code>，可以有效减轻<code>master</code>的写压力。</p><p><strong>风险</strong>：一旦某个从机宕机，后面的从机都无法备份。</p><p><strong>中途变更转向</strong>：会清除之前的数据，重新建立拷贝最新的。</p><h3 id="二、-反客为主"><a href="#二、-反客为主" class="headerlink" title="二、    反客为主"></a><strong>二、    反客为主</strong></h3><p>当一个<code>master</code>宕机后，后面的<code>slave</code>通过命令可以立刻升为<code>master</code>，其后面的<code>slave</code>不用做任何修改，但不用修改的前提在于<code>从机</code>实现了薪火相传模式，否则仍需进行主从关系确认。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof no one# 将从机变为主机</span><br></pre></td></tr></table></figure><p>当宕机后的<code>master</code>重启后，此时已无任何主从关系，无任何复制关系。</p><h3 id="三、-哨兵模式"><a href="#三、-哨兵模式" class="headerlink" title="三、    哨兵模式"></a><strong>三、    哨兵模式</strong></h3><p>哨兵模式，俗称<font color="red">反客为主的自动版</font>，能够后台监控主机是否故障，若故障了则根据<code>投票数</code>自动<code>将从库转换为主库</code>，保证了系统的可用性。</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>监控（Monitoring）：哨兵会不断地检查主节点和从节点是否运行正常</li><li>自动故障转移（Automatic faliover）：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点</li><li>配置提供者（Configuration provider）：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址</li><li>通知（Notification）：哨兵可以将故障转移的结果发送给客户端</li></ul><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li><p>调整为<code>一主二仆模式</code>，<code>6379</code>带着<code>6380</code>、<code>6381</code></p></li><li><p>在自定义的<code>/myredis</code>目录下新建<code>sentinel.conf</code>，切记文件名不能有错</p></li><li><p>配置哨兵</p><p>在<code>sentinel.conf</code>文件中填入配置信息，保存退出</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster <span class="number">127.0</span>.<span class="number">0.1</span> <span class="number">6379</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>注：<code>mymaster</code>为监控对象起的服务器名称（即哨兵名称），<code>1</code>为至少有多少个哨兵同意迁移的数量</p></li><li><p>启动哨兵</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /myredis/sentinel.conf</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E5%93%A8%E5%85%B5%E5%90%AF%E5%8A%A8.6svp11zonng0.jpg" alt="启动哨兵"></p></li><li><p>当主节点6379宕机后，等待30秒，哨兵进行投票推选新主节点</p><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E5%93%A8%E5%85%B5%E7%A5%A8%E9%80%89.5xpehoup20s0.jpg" alt="哨兵票选"></p></li><li><p>当主节点6379重新连接后，哨兵服务端响应两句</p><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E5%8E%9F%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF.18mr2583aghs.jpg" alt="原主机上线"></p><p>第一句是：去除6379的下线处理</p><p>第二句是：重连6379到新的主节点上，此时6379为新主节点的从节点</p></li><li><p>检验主从复制是否正常工作</p><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E6%A3%80%E9%AA%8C%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.62himtzsuys0.jpg" alt="检验主从复制"></p><p>上图所见，主从复制正常运行，至此，哨兵模式的配置完成</p></li></ol><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：<code>高可用</code>，<code>读写分离</code>，哨兵模式是基于主从模式的，主从模式的优点，哨兵模式都具备，主从可以自动切换，系统更健壮，可用性更高。</p><p>缺点：Redis比较难支持在线扩容，在集群容量达到上线时在线扩容会变得非常复杂。</p><h1 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>所谓的集群，就是通过添加服务器的数量，提供相同的服务，从而让服务器达到一个稳定、高效的状态，集群主要解决<code>容量不够</code>和<code>并发写操作压力</code>等问题。</p><p>Redis3.0版本之前只支持单例（代理主机），在3.0版本即以后的版本才支持集群，采用<code>无中心化集群</code>配置。</p><p>Redis集群，是基于Redis主从复制实现的，同时也存在三种模式：<code>主从模式</code>、<code>哨兵模式</code>和<code>Cluster集群模式</code>。</p><p>由于前两种模式在前面<code>主从复制</code>环节中有讲解，所以我们这里重点关注<code>Cluster模式</code>。</p><h2 id="Cluster集群模式"><a href="#Cluster集群模式" class="headerlink" title="Cluster集群模式"></a>Cluster集群模式</h2><ul><li>之前的<code>哨兵模式</code>基本已经可以实现高可用、读写分离，但是在这种模式每台redis服务器都存储相同的数据，很<code>浪费内存资源</code>，所以在Redis3.0上加入了<code>Cluster集群模式</code>，实现了Redis的<code>分布式存储</code>，也就是说每台Redis节点存储着不同的内容</li><li>根据官方推荐，集群部署至少要<code>3台以上</code>的master节点，最好使用<code>3主3从</code>六个节点的模式</li><li>Cluster集群由多个redis服务器组成的<code>分布式网络服务集群</code>，集群之中有多个master主节点，每一个主节点都可读可写，节点之间会相互通信，两两相连，redis集群无中心节点</li></ul><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E6%97%A0%E4%B8%AD%E5%BF%83%E5%8C%96%E9%9B%86%E7%BE%A4.2s6cwtc8k6g0.png" alt="无中心化集群"></p><ul><li>在<code>redis-Cluster集群</code>中，可以给每个主节点添加从节点，主节点和从节点直接遵循主从模型的特性，当用户需要处理更多读请求的时候，添加从节点可以扩展系统的读性能</li><li><code>redis-cluster</code>的<code>故障转移</code>：redis集群的主机节点内置了类似redis sentinel的<code>节点故障检测</code>和<code>自动故障转移</code>功能，当集群中的某个主节点下线时，集群中的其他在线主节点会注意到这一点，并且对已经下线的主节点进行故障转移</li><li>集群进行故障转移的方法和<code>redis sentinel</code>进行故障转移的方法基本一样，不同的是，在集群里面，故障转移是由集群中其他在线的主节点负责进行的，所以集群不必另外使用<code>redis sentinel</code></li></ul><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>删除持久化数据（rdb/aof文件）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /myredis# 进入自定义目录</span><br><span class="line">rm -rf rdb*# 删除rdb文件，如若有aof文件，也一并删除</span><br></pre></td></tr></table></figure></li><li><p>实例准备</p><p>Master端口：6379、6380、6381</p><p>Slave端口：6389、6390、6391</p><div class="note warning flat"><p>分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上。</p></div><p>配置文件<code>redis6379.conf</code></p><p>删除之前的哨兵数据，添加下面的集群配置，保存退出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cluster-enabled yes# 打开集群模式</span><br><span class="line">cluster-config-file nodes-6379.conf# 设定节点配置文件</span><br><span class="line">cluster-node-timeout 15000# 集群节点的超时时限默认值</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E5%88%A0%E9%99%A4.aamudg5l9f4.jpg" alt="集群配置删除"></p><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E6%B7%BB%E5%8A%A0.4c4xk3rl6qi0.jpg" alt="集群配置添加"></p><p>删除原来的<code>redis6380.conf</code>和<code>redis6381.conf</code>文件，另外<code>拷贝5份</code>修改的<code>redis6379.conf</code>为对应端口号文件</p><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6.185f6wfoq2yo.jpg" alt="拷贝文件"></p><p>进入vim编辑器，在命令模式下使用<code>:%s/6379/替换后端口</code>快速修改5份拷贝后的配置文件信息</p></li><li><p>启动6个redis服务</p><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1.22uohujnmgcg.jpg" alt="启动服务"></p></li><li><p>组合集群</p><p>组合之前，确保所有redis服务启动后，<code>nodes-端口号.conf</code>文件都生成正常</p><p>如果你是redis5.0及之后的，无需安装ruby依赖，redis安装目录里内置了集群命令行工具redis-trib ，它是一个 Ruby 程序， 这个程序通过向实例发送特殊命令来完成创建新集群， 检查群， 或者对集群进行重新分片工作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create 192.168.30.0:6379 192.168.30.0:6380 192.168.30.0:6381 192.168.30.0:6389 192.168.30.0:6390 192.168.30.0:6391 --cluster-replicas 1# 组合命令</span><br></pre></td></tr></table></figure> <div class="note info no-icon flat"><p>ps：<code>--cluster-replicas 1</code> 这个指的是从机的数量，表示我们希望为集群中的每个主节点创建一个从节点。另外，主从是随机绑定的，创建完成后可以在master节点中看到所有节点状态（netstat -natp | grep 6379） </p></div><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E7%BB%84%E5%90%88%E9%9B%86%E7%BE%A4.5p63gwu2zhk0.jpg" alt="组合集群"></p></li><li><p>测试集群</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c -p 端口号    # -c参数实现自动重定向，连接客户端</span><br><span class="line">cluster info    # 查看集群状态</span><br><span class="line">cluster nodes    # 查看节点信息</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E6%B5%8B%E8%AF%95%E9%9B%86%E7%BE%A4.h1u9gsuk0nc.jpg" alt="测试集群"></p><p>如图所示，集群搭建成功。</p> <div class="note info no-icon flat"><p>Redis 集群有<code>16384</code>个<code>哈希槽</code>，每个<code>key</code>通过<code>CRC16</code>校验后对16384取模来决定放置哪个槽。集群的每个节点负责一部分hash槽，举个例子，比如当前集群有3个节点ABC，那么：</p><ul><li>节点 A 包含 <code>0</code> 到 <code>5460</code>号哈希槽</li><li>节点 B 包含<code>5461</code> 到 <code>10922</code> 号哈希槽</li><li>节点 C 包含<code>10923</code> 到 <code>16383</code>号哈希槽</li></ul></div><p>尝试往集群中写入数据</p><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE.5rjk9tsc1xs0.jpg" alt="写入数据"></p><p>不在一个<code>slot</code>下的键值，是不能使用<code>mget、mset等多键操作</code>，但可通过<code>&#123;&#125;</code>内相同内容的键值对放到同一个<code>slot</code>中去</p><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E5%A4%9A%E9%94%AE%E6%93%8D%E4%BD%9C.3ukznasnqym0.jpg" alt="多键操作"></p><p>查询集群中的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cluster keyslot &lt;key&gt;                # 计算key的插槽值</span><br><span class="line">cluster countkeysinslot &lt;slot&gt;        # 返回slot槽的键数(只能查看自己插槽范围内的值)</span><br><span class="line">cluster getkeysinslot &lt;slot&gt; &lt;count&gt;# 返回count个slot槽中的键</span><br></pre></td></tr></table></figure></li><li><p>集群的Jedis开发</p><p>无中心化主从集群。即使连接的不是主机，集群会自动切换主机存储。遵循<code>主写从读</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- jedis依赖包引入  --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisClusterTest</span></span>&#123;</span><br><span class="line">    <span class="function">publi <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">         Set&lt;HostAndPort&gt; set = <span class="keyword">new</span> HashSet&lt;HostAndPort&gt;();</span><br><span class="line">         set.add(<span class="keyword">new</span> HashSet&lt;HostAndPort&gt;(<span class="string">&quot;192.168.30.0&quot;</span>,<span class="number">6379</span>));</span><br><span class="line">         JedisCluster jc = <span class="keyword">new</span> JedisCluster(set);</span><br><span class="line">         jc.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;zeker&quot;</span>);</span><br><span class="line">         String value = jc.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">         System.out.println(value);</span><br><span class="line">         jc.close();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="集群优缺点"><a href="#集群优缺点" class="headerlink" title="集群优缺点"></a>集群优缺点</h3><p>优点：实现扩容、分摊压力、无中心配置相对简单</p><p>缺点：多键操作、多键的Redis事务、lua脚本均不被支持</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring boot整合Redis</title>
      <link href="/posts/b921ad40/"/>
      <url>/posts/b921ad40/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Jedis、Spring-data-redis的配置以及区别"><a href="#Jedis、Spring-data-redis的配置以及区别" class="headerlink" title="Jedis、Spring-data-redis的配置以及区别"></a>Jedis、Spring-data-redis的配置以及区别</h1><h2 id="Jedis如何配置"><a href="#Jedis如何配置" class="headerlink" title="Jedis如何配置"></a>Jedis如何配置</h2><ol><li><p>jedis引入依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--        Jedis引入依赖--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>连接Redis客户端</p><ol><li><p>Jedis直连</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.30.0&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">jedis.set(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">String value = jedis.get(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>JedisPool 连接池的使用</p><p>配置文件<code>jedis.properties</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 资源池最大连接数</span><br><span class="line">maxTotal=<span class="number">50</span>             </span><br><span class="line"># 资源池允许最大空闲连接数</span><br><span class="line">maxIdle=<span class="number">10</span>              </span><br><span class="line"># redis服务器地址</span><br><span class="line">host=<span class="number">192.168</span><span class="number">.30</span><span class="number">.0</span> </span><br><span class="line"># redis开放端口</span><br><span class="line">port=<span class="number">6379</span>             </span><br></pre></td></tr></table></figure><p>类<code>JedisUtils.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个连接池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//读取配置文件</span></span><br><span class="line">        InputStream is = JedisUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jedis.properties&quot;</span>);</span><br><span class="line">        Properties pro=<span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pro.load(is);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//连接池配置</span></span><br><span class="line">        JedisPoolConfig config=<span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        config.setMaxTotal(Integer.parseInt(pro.getProperty(<span class="string">&quot;maxTotal&quot;</span>)));</span><br><span class="line">        config.setMaxIdle(Integer.parseInt(pro.getProperty(<span class="string">&quot;maxIdle&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化连接池，把对应参数传递进去</span></span><br><span class="line">        jedisPool=<span class="keyword">new</span> JedisPool(config,pro.getProperty(<span class="string">&quot;host&quot;</span>), Integer.parseInt(pro.getProperty(<span class="string">&quot;port&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置好后返回，返回一个Jedis对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类<code>JedisTest.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取连接池对象</span></span><br><span class="line">            jedis = JedisUtils.getJedis();</span><br><span class="line">            <span class="comment">//执行操作</span></span><br><span class="line">            jedis.set(<span class="string">&quot;java&quot;</span>, <span class="string">&quot;good&quot;</span>);</span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;java&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//这里使用的close不代表关闭连接，指的是归还资源</span></span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>Jedis<code>直连</code>与Jedis<code>连接池</code>使用的对比</p><table><thead><tr><th>方案</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>Jedis直连</td><td>简单方便<br>适用于连接数较少且使用时间较长，可构成长连接场景</td><td>存在每次新建/关闭TCP开销<br>资源无法控制，存在连接泄露的可能<br>Jedis对象线程不安全</td></tr><tr><td>Jedis连接池</td><td>Jedis预先生成，降低开销<br>连接池的形成保护和控制资源的使用</td><td>相对于直连，使用相对麻烦，尤其在资源管理上需要很多参数来保证，一旦规划不合理就会出现问题</td></tr></tbody></table></li></ol><h2 id="Spring-data-redis如何配置"><a href="#Spring-data-redis如何配置" class="headerlink" title="Spring-data-redis如何配置"></a>Spring-data-redis如何配置</h2><ol><li><p> spring-data-redis引入依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--        redis--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.6</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p> 添加配置文件<code>application.properties</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#Redis服务器地址</span><br><span class="line">spring.redis.host=<span class="number">192.168</span><span class="number">.30</span><span class="number">.0</span></span><br><span class="line">#Redis服务器连接端口（默认端口为<span class="number">6379</span>）</span><br><span class="line">spring.redis.port=<span class="number">6379</span></span><br><span class="line">#Redis数据库索引（默认位<span class="number">0</span>）</span><br><span class="line">spring.redis.database=<span class="number">0</span></span><br><span class="line">#连接超时时间（毫秒）</span><br><span class="line">spring.redis.timeout=<span class="number">1800000</span></span><br><span class="line">#连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">spring.redis.lettuce.pool.max-active=<span class="number">20</span></span><br><span class="line">#最大阻塞等待时间（复数表示没有限制）</span><br><span class="line">spring.redis.lettuce.pool.max-wait=-<span class="number">1</span></span><br><span class="line">#连接池中的最大空闲连接</span><br><span class="line">spring.redis.lettuce.pool.max-idle=<span class="number">5</span></span><br><span class="line">#连接池中的最小空闲连接</span><br><span class="line">spring.redis.lettuce.pool.min-idle=<span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p> 添加Redis配置类<code>RedisConfig.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate();</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance ,</span><br><span class="line">                ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        template.setKeySerializer(redisSerializer);</span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance ,</span><br><span class="line">                ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line">        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofSeconds(<span class="number">600</span>))</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line">        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p> 创建Controller试验一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/redisTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTestControllor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;zeker&quot;</span>);</span><br><span class="line">        String name = (String) redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p> 根据自己开设的端口访问<code>http://localhost:8080/redisTest</code></p></li></ol><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210806/666ae2ea6a519635d9932f43f286144.mt0bja0dxmo.png" alt="1"></p><h2 id="常见问题及解决方法"><a href="#常见问题及解决方法" class="headerlink" title="常见问题及解决方法"></a>常见问题及解决方法</h2><div class="note info no-icon flat"><p>Could not get a resource from the pool; nested exception is io.lettuce.core.RedisConnectionException: Unable to connect to 192.168.30.0:6379</p></div><p>1、查看是否启动Redis服务器</p><p>2、查看目标IP地址是否可以ping通</p><p>3、Redis的配置application.yml（或application.properties）中spring.redis.timeout连接超时时间（毫秒）中设置不能为0</p><p>4、修改redis的配置文件redis.conf</p><ol><li>protected-mode yes 改为 protected-mode no<br> （该配置项表示是否开启保护模式，默认是开启，开启后Redis只会本地进行访问，拒绝外部访问）</li><li>注释掉 bin127.0.0.1 即 #bin 127.0.0.1<br> （PS: 不注释掉，表示指定 Redis 只接收来自于该 IP 地址的请求，注释掉后，则表示将处理所有请求）</li></ol><div class="note warning flat"><p>修改配置文件redis.conf后记得保存重启redis</p></div><p>5、如果在Redis中没有配置requirepass，那么在application.properties（或application.yaml）中就不要写spring.redis.password</p><p>6、开放对应端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=6379/tcp# 开放6379端口号</span><br><span class="line">firewall-cmd --query-port=6379/tcp# 查看端口号是否打开</span><br></pre></td></tr></table></figure><div class="note info no-icon flat"><p>PS：云服务器需在安全组中设置对应端口号，不建议开放所有端口。在<code>虚拟机上测试</code>也可以选择关闭防火墙<code>systemctl stop firewalld</code>。</p></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Jedis</code>是Redis官方推荐的面向Java的操作Redis的客户端，而<code>RedisTemplate</code>是<code>Spring-data-redis</code>中对<code>Jedis</code>Api的高度封装。</p><p><code>Spring-data-redis</code>相对于Jedis来说可以方便地更换Redis的Java客户端，比Jedis多了自动管理连接池的特性，方便与其他Spring框架进行搭配使用</p><p>总体来说，<code>Jedis</code>，更像<code>spring 与 MySQL</code>结合，通过操作连接池，获取实例操作数据库，而<code>Spring-data-redis</code>与spring的整合，更像<code>spring 与 mybatis</code>整合，通过工厂，创建实例，再操作实例。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 配置 </tag>
            
            <tag> Spring boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记（1）</title>
      <link href="/posts/d9238aea/"/>
      <url>/posts/d9238aea/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Redis键（key）"><a href="#Redis键（key）" class="headerlink" title="Redis键（key）"></a>Redis键（key）</h2><table><thead><tr><th align="left">命令</th><th>描述</th></tr></thead><tbody><tr><td align="left">keys *</td><td>查看当前库所有key</td></tr><tr><td align="left">exists &lt;key&gt;</td><td>判断某个key是否存在</td></tr><tr><td align="left">type &lt;key&gt;</td><td>查看key是什么类型</td></tr><tr><td align="left">del &lt;key&gt;</td><td>删除指定的key数据</td></tr><tr><td align="left">expore &lt;key&gt; &lt;time&gt;</td><td>为给定的key设置过期时间time（单位秒）</td></tr><tr><td align="left">ttl &lt;key&gt;</td><td>查看还有多少秒过期，-1表示永不过期，-2表示已过期</td></tr><tr><td align="left">select &lt;index&gt;</td><td>切换当前数据库（共16个数据库，0为默认库）</td></tr><tr><td align="left">dbsize</td><td>查看当前数据库key的数量</td></tr><tr><td align="left">flushdb/flushall</td><td>清空当前库/全部库</td></tr></tbody></table><h2 id="Redis字符串（String）"><a href="#Redis字符串（String）" class="headerlink" title="Redis字符串（String）"></a>Redis字符串（String）</h2><p><code>String</code>类型是二进制安全的，意味着Redis的<code>String</code>可包含任何数据，比如jpg图片或者序列化的对象。</p><p>一个Redis中字符串value最多可以是512M。</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>set &lt;key&gt; &lt;value&gt;</td><td>添加键值对</td></tr><tr><td>get &lt;key&gt;</td><td>查询对应键值</td></tr><tr><td>append &lt;key&gt; &lt;value&gt;</td><td>将给定的value追加到原值的末尾</td></tr><tr><td>strlen &lt;key&gt;</td><td>获得key的长度</td></tr><tr><td>setnx &lt;key&gt; &lt;value&gt;</td><td>只有在key不存在时，才能设置key的值</td></tr><tr><td>incr/decr &lt;key&gt;</td><td>将key中储存的数字值增/减（+/-） 1</td></tr><tr><td>incrby/decrby &lt;key&gt; &lt;步长&gt;</td><td>将key中储存的数字值增/减，自定义步长</td></tr><tr><td>mset &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;….</td><td>同时设置一个或多个key-value对</td></tr><tr><td>mget &lt;key1&gt;&lt;key2&gt;….</td><td>同时获取一个或多个value</td></tr><tr><td>msetnx &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;….</td><td>同时设置一个或多个key-value对，当且仅当所有给定key都不存在</td></tr><tr><td>getrange &lt;key&gt; &lt;起始位置&gt;&lt;结束位置&gt;</td><td>获得值的范围（全部：get key 0 -1）</td></tr><tr><td>setrange &lt;key&gt;&lt;起始位置&gt;&lt;value&gt;</td><td>用value覆写key所储存的字符串值，从起始位置开始（索引从0开始）</td></tr><tr><td>setnx &lt;key&gt; &lt;过期时间&gt;&lt;value&gt;</td><td>设置键值的同时，设置过期时间（单位秒）</td></tr><tr><td>getset&lt;key&gt;&lt;value&gt;</td><td>设置新值同时获得旧值</td></tr></tbody></table><h2 id="Redis列表（List）"><a href="#Redis列表（List）" class="headerlink" title="Redis列表（List）"></a>Redis列表（List）</h2><p><strong>单键多值，双向链表</strong></p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>lpush/rpush &lt;key&gt; &lt;value1&gt; &lt;value2&gt;….</td><td>从左边/右边插入一个或多个值</td></tr><tr><td>lpop/rpop  &lt;key&gt;</td><td>从左边/右边吐出一个值。</td></tr><tr><td>rpoplpush  &lt;key1&gt; &lt;key2&gt;</td><td>从key1列表右边吐出一个值，查到key2列表右边</td></tr><tr><td>lrange &lt;key&gt; &lt;start&gt; &lt;stop&gt;</td><td>按照索引下标获得元素（从左到右）&lt;br&gt;（全部：lrange key 0 -1）</td></tr><tr><td>lindex &lt;key&gt; &lt;index&gt;</td><td>按照索引下标获得元素（从左到右）</td></tr><tr><td>llen &lt;key&gt;</td><td>获得列表的长度</td></tr><tr><td>linsert &lt;key&gt; before/after &lt;value&gt; &lt;newvalue&gt;</td><td>在value的前/后面插入newvalue值</td></tr><tr><td>lrem &lt;key&gt; &lt;n&gt; &lt;value&gt;</td><td>从左边删除n个value（从左到右）</td></tr><tr><td>lset &lt;key&gt; &lt;index&gt; &lt;value&gt;</td><td>将列表key下标为index的值替换成value</td></tr></tbody></table><h2 id="Redis集合（Set）"><a href="#Redis集合（Set）" class="headerlink" title="Redis集合（Set）"></a>Redis集合（Set）</h2><p>Redis的集合<code>Set</code>是String类型的无序集合，与list类似是一个列表的功能，但<code>Set</code>可以自动数据排重。底层是一个value为<code>null</code>的hash表，所以添加、删除、查找的复杂度都为<code>O(1)</code>。</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>sadd &lt;key&gt; &lt;member1&gt; &lt;member2&gt;….</td><td>将一个或多个member元素加入到集合key中，已存在的member将被忽略</td></tr><tr><td>smembers &lt;key&gt;</td><td>取出该集合的所有值</td></tr><tr><td>sismember &lt;key&gt; &lt;member&gt;</td><td>判断集合key是否含有该member值，有则1，无则0</td></tr><tr><td>scard &lt;key&gt;</td><td>返回该集合的元素个数</td></tr><tr><td>srem &lt;key&gt; &lt;member1&gt; &lt;member2&gt;….</td><td>删除集合中的某个元素</td></tr><tr><td>spop &lt;key&gt;</td><td>随机从该集合中吐出一个值</td></tr><tr><td>srandmember &lt;key&gt; &lt;n&gt;</td><td>随机从该集合中取出n个值。值不会从集合中删除</td></tr><tr><td>smove &lt;source&gt; &lt;destination&gt;  &lt;member&gt;</td><td>把集合中的一个member值从一个集合移动到另一个集合中</td></tr><tr><td>sinter/sunion &lt;key1&gt; &lt;key2&gt;</td><td>返回两个集合的交集/并集元素</td></tr><tr><td>sdiff &lt;key1&gt; &lt;key2&gt;</td><td>返回两个集合的差集元素（key1中的，不包含key2中的）</td></tr></tbody></table><h2 id="Redis哈希（Hash）"><a href="#Redis哈希（Hash）" class="headerlink" title="Redis哈希（Hash）"></a>Redis哈希（Hash）</h2><p>Redis的<code>Hash</code>是一个String类型的field和value的映射表，hash适合用于存储对象，类似Java中的<code>Map&lt;String, Object&gt;</code>。</p><p>当key存储的value过多时，往往为了提高查询效率，例如用户ID为key，field有姓名、年龄、职业等信息，这是我们可以选择通过key(用户ID)+field(属性标签)就可以操作对应属性的数据。</p><p>类似于map套娃：<code>&lt;String， &lt;Map&lt;key, value&gt;&gt;&gt;</code></p><div class="note green no-icon flat"><p>好处：既不需要重复存储数据，避免了数据冗余，也不会带来序列化和并发修改控制的问题。</p></div><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>hset &lt;key&gt; &lt;field&gt; &lt;value&gt;</td><td>给key集合中的field键赋值value，例：hset user:001 name zeker</td></tr><tr><td>hget &lt;key&gt; &lt;field&gt;</td><td>从key集合中的fild中取出value</td></tr><tr><td>hmset &lt;key&gt; &lt;field1&gt; &lt;value1&gt; &lt;field2&gt; &lt;value2&gt;….</td><td>批量设置hash的值</td></tr><tr><td>hexists &lt;key&gt; &lt;field&gt;</td><td>查看哈希表key中，给定field是否存在</td></tr><tr><td>hkeys &lt;key&gt;</td><td>列出该hash集合的所有field</td></tr><tr><td>hvals &lt;key&gt;</td><td>列出该hash集合的所有value</td></tr><tr><td>hincrby &lt;key&gt; &lt;field&gt; &lt;increment&gt;</td><td>为哈希表key中的field的值加上增量increment（例：1 -1）</td></tr><tr><td>hsetnx &lt;key&gt; &lt;field&gt; &lt;value&gt;</td><td>将哈希表key中的field的值设置为value，当且仅当field不存在</td></tr></tbody></table><h2 id="Redis有序集合（Zset）"><a href="#Redis有序集合（Zset）" class="headerlink" title="Redis有序集合（Zset）"></a>Redis有序集合（Zset）</h2><p>Redis有序集合<code>Zset</code>与普通集合Set相似，都是一个没有重复元素的字符串集合。</p><p>不同之处在于有序集合<code>Zset</code>的每个成员都关联了一个评分（score），这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。</p><p>集合中的成员是唯一的，但评分可以是重复的。这里例子可以为：排行榜</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>zadd &lt;key&gt; &lt;score1&gt; &lt;member1&gt; &lt;score2&gt; &lt;member2&gt;….</td><td>将一个或多个memeber元素及其score值加入到有序集key中</td></tr><tr><td>zrange &lt;key&gt; &lt;start&gt; &lt;stop&gt; [withscores]</td><td>返回有序集key中，下标在start与stop之间的元素(withscores可让分数与值返回到结果集</td></tr><tr><td>zrangebyscore key min max [withscoers]  [limit offset count]</td><td>返回有序集key中，所有score值介于min和max之间（包括等于min或max）的成员，有序集成员按score值递增（从小到大）次序排列</td></tr><tr><td>zrevrangebyscore key max min [withscoers]  [limit offset count]</td><td>dev：反转。意思同上，次序从大到小排列</td></tr><tr><td>zincrby &lt;key&gt; &lt;increment&gt; &lt;member&gt;</td><td>为元素member的score加上增量increment</td></tr><tr><td>zrem &lt;key&gt; &lt;member&gt;</td><td>删除该集合下指定值的元素</td></tr><tr><td>zcount &lt;key&gt; &lt;min&gt; &lt;max&gt;</td><td>统计该集合中分数区间内的元素个数</td></tr><tr><td>zrank &lt;key&gt; &lt;member&gt;</td><td>返回该元素member在集合中的排名，从0开始</td></tr></tbody></table><p>Zset底层中使用了两种数据结构：hash表与跳跃表</p><ol><li>hash表，作用就是关联元素value和权重score，保障元素value的唯一值，可以通过元素value找到相应的score值。</li><li>跳跃表，目的在于给元素value排序，根据score的范围获取元素列表，从而比普通列表查询效率更快。</li></ol><h2 id="Redis新数据类型"><a href="#Redis新数据类型" class="headerlink" title="Redis新数据类型"></a>Redis新数据类型</h2><h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><p>Redis提供<code>Bitmaps</code>这个”数据类型“可以实现对位的操作：</p><p>（1）<code>Bitmaps</code>本身不是一种数据结构，实际上就是字符串，但是它可以对字符串的位进行操作。、</p><p>（2）<code>Bitmaps</code>单独提供了一套命令，所以在Redis中使用<code>Bitmaps</code>和使用字符串的方法不太相同。可以<code>Bitmaps</code>想象成一个以位为单位数组，数组中的每个单元只能存0或者1，数组的下标在<code>Bitmaps</code>中叫做偏移量。单个<code>Bitmaps</code>的最大长度是<code>512MB</code>，即<code>2^32</code>个比特位。</p><div class="note green no-icon flat"><p>合理地使用操作位能够有效地提高内存使用率和开发效率，并且可以极大地节省内存空间。<br>例如：用户访问，统计不同电话号码的个数以及布隆过滤法（URL的排重、垃圾邮箱地址的过滤）……</p></div><table><thead><tr><th>命令</th><th>描述</th><th></th></tr></thead><tbody><tr><td>setbit &lt;key&gt; &lt;offset&gt; &lt;value&gt;</td><td>设置Bitmaps中某个偏移量offset的值value</td><td></td></tr><tr><td>getbit &lt;key&gt; &lt;offset&gt;</td><td>获取Bitmaps中某个偏移量offset的值value</td><td></td></tr><tr><td>bitcount &lt;key&gt; [start end]</td><td>统计字符串从start字节到end字节比特值为1的数量</td><td></td></tr><tr><td>bitop and(or/not/xor) &lt;destkey&gt; [key….]</td><td>多个Bitmaps的and（交集）、or（并集）、not（非）、xor（异或）操作并将结果保存在destkey中</td><td></td></tr></tbody></table><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><div class="note default no-icon flat"><p>在工作当中，经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。<br>但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？而这种求集合中不重复元素个数的问题称为基数问题。</p></div><p>解决基数问题方案：</p><p>（1）数据存储在MySQL表中，使用distinct count计算不重复个数</p><p>（2）使用Redis提供的hash、set、bitmaps等数据结构来处理</p><p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。</p><p>为了能够降低一定的精度来平衡存储空间，Redis推出了HyperLogLog，一种用来做基数统计的算法。</p><p>其优点在于：</p><p>在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p><p>每个<code>HyperLogLog</code>键只需要花费 <code>12 KB</code>内存，就可以计算接近 <code>2^64</code> 个不同元素的<code>基数</code>。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p><div class="note info flat"><p>基数 = 数据集元素个数 - 重复数字个数</p></div><p>但是，因为<code>HyperLogLog</code>只会根据输入元素来计算基数，而不会储存输入元素本身，所以 <code>HyperLogLog</code>不能像集合那样，返回输入的各个元素。</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>padd &lt;key&gt; &lt;element&gt; [element….]</td><td>添加指定元素element到HyperLogLog中</td></tr><tr><td>pfcount &lt;key&gt; [key….]</td><td>计算key中的基数</td></tr><tr><td>pfmerge &lt;destkey&gt; &lt;sourcekey&gt; [sourcekey….]</td><td>将一个或多个key合并后的结果储存在另一个destkey中</td></tr></tbody></table><h3 id="Geospatital"><a href="#Geospatital" class="headerlink" title="Geospatital"></a>Geospatital</h3><p><code>Redis GEO</code>，Geographic，地理信息的缩写。</p><p>主要用于存储地理位置信息，即经纬度（二维坐标），基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>geoadd &lt;key&gt; &lt;longitude&gt; &lt;latitude&gt; &lt;member&gt; [longitude latitude member….]</td><td>添加地理位置（经度、维度、名称）（有效经度：-180度到180度；有效纬度：-85.05112878度到85.05112878度）</td></tr><tr><td>geopos &lt;key&gt; &lt;member&gt; [member….]</td><td>获得指定地区member的坐标</td></tr><tr><td>geodist &lt;key&gt; &lt;member1&gt; &lt;member2&gt; [m|km|ft|mi]</td><td>获取两个指定地区位置之间的直线距离（单位：米|千米|英尺|英里，默认单位米）</td></tr><tr><td>georadius &lt;key&gt; &lt;longitude&gt; &lt;latitude&gt; radius    m|km|ft|mi</td><td>以给定的经纬度为中心找出某一半径radius内的元素</td></tr></tbody></table><h2 id="Redis事务命令"><a href="#Redis事务命令" class="headerlink" title="Redis事务命令"></a>Redis事务命令</h2><p>一个事务从开始到执行会经历以下三个阶段：</p><ul><li>开始事务</li><li>命令入队</li><li>执行事务</li></ul><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>multi</td><td>标记一个事务块的开始，开始对命令的组队阶段</td></tr><tr><td>exec</td><td>执行所有事务块内的命令，开始执行阶段</td></tr><tr><td>discard</td><td>取消事务，放弃执行事务块内的所有命令</td></tr><tr><td>watch &lt;key&gt; [key….]</td><td>监视一个（或多个）key，如果在事务执行之前这个（或这些）key被其他命令锁改动，那么事务将被打断</td></tr><tr><td>unwatch</td><td>取消watch命令对所有key的监视</td></tr></tbody></table><p>组队阶段中某个命令出现了命令报错，执行阶段整个的所有队列都会被取消。</p><p>而当组队阶段无报错，执行阶段某一命令出现了命令报错，则只有报错的命令不会被执行，其他命令不受影响。</p><p>当出现事务冲突时，Redis往往呈现出<code>乐观锁</code>的形式进行处理，即在使用完数据<code>修改版本号</code>等机制，提高吞吐量，而Redis就是利用这种<code>check-and-set</code>机制实现事务。</p><h3 id="事务三特性"><a href="#事务三特性" class="headerlink" title="事务三特性"></a>事务三特性</h3><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>单独的隔离操作</td><td>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断</td></tr><tr><td>没有隔离级别的概念</td><td>队列中的命令没有提交之前都不会实际地被执行，因为事务提交前任何指令都不会被实际执行</td></tr><tr><td>不保证原子性</td><td>Redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos安装Redis</title>
      <link href="/posts/9d3a5b2a/"/>
      <url>/posts/9d3a5b2a/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Centos导入Redis安装包"><a href="#Centos导入Redis安装包" class="headerlink" title="Centos导入Redis安装包"></a>Centos导入Redis安装包</h2><div class="hide-toggle" style="border: 1px solid #e8fafe"><div class="hide-button toggle-title" style="background-color: #e8fafe;color: color"><i class="fas fa-caret-right fa-fw"></i><span>第一种方案</span></div>    <div class="hide-content"><h3 id="前往Redis官网下载安装包"><a href="#前往Redis官网下载安装包" class="headerlink" title="前往Redis官网下载安装包"></a>前往<a href="http://redi.io/">Redis官网</a>下载安装包</h3><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210722/1.4b8tzfon68k0.jpg" alt="1"></p><h3 id="通过Xftp将已下载好的安装包拖拽到centos的新建目录下"><a href="#通过Xftp将已下载好的安装包拖拽到centos的新建目录下" class="headerlink" title="通过Xftp将已下载好的安装包拖拽到centos的新建目录下"></a>通过Xftp将已下载好的安装包拖拽到centos的新建目录下</h3><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210722/2.kd9zl46gwc0.jpg" alt="2"></p><h3 id="查看安装包是否在选定目录下"><a href="#查看安装包是否在选定目录下" class="headerlink" title="查看安装包是否在选定目录下"></a>查看安装包是否在选定目录下</h3><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210722/3.6app3qipdg40.jpg" alt="3"></p></div></div><div class="hide-toggle" style="border: 1px solid #fff8e9"><div class="hide-button toggle-title" style="background-color: #fff8e9;color: color"><i class="fas fa-caret-right fa-fw"></i><span>第二种方案</span></div>    <div class="hide-content"><p>在Centos直接安装，下载之前，建议新建一个文件夹来存放安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-6.2.4.tar.gz   #下载最新版即可</span><br></pre></td></tr></table></figure></div></div><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>安装C语言的编译环境gcc</li></ol><p>依次输入以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install centos-release-scl scl-utils-build</span><br><span class="line">yum install -y devtollset-8-toolchain</span><br><span class="line">scl enable devtoolset-8 bash</span><br></pre></td></tr></table></figure><ol start="2"><li> 查看gcc是否安装成功</li></ol><p>检测gcc版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc --version</span><br></pre></td></tr></table></figure><p>安装成功如下:</p><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210722/4.1zo605jol5wg.jpg" alt="4"></p><h2 id="解压并安装"><a href="#解压并安装" class="headerlink" title="解压并安装"></a>解压并安装</h2><ol><li> 解压安装包<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf redis-6.2.4.tar.gz</span><br></pre></td></tr></table></figure></li><li> 解压完成后进入目录<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd redis-6.2.4</span><br></pre></td></tr></table></figure></li><li>在目录下执行make命令，编译成C文件</li></ol><div class="note info no-icon flat"><p>注意：如果没有安装C语言编译环境，make命令会报错</p><p>报错信息：jemalloc/jemalloc.h: 没有那个文件或目录</p><p>解决方案：检测gcc是否安装成功，并运行make distclean</p></div><ol start="4"><li>在目录下进行安装<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure></li></ol><h2 id="安装目录：-user-local-bin"><a href="#安装目录：-user-local-bin" class="headerlink" title="安装目录：/user/local/bin"></a>安装目录：/user/local/bin</h2><table><thead><tr><th align="left">文件名</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">redis-benchmark</td><td align="left">性能测试工具</td></tr><tr><td align="left">redis-check-aof</td><td align="left">修复有问题的AOF文件</td></tr><tr><td align="left">redis-check-rdb</td><td align="left">修复有问题的dump.rdb文件</td></tr><tr><td align="left">redis-sentinel</td><td align="left">Redis哨兵启动，用于主从复制、集群使用</td></tr><tr><td align="left"><font color='red'>redis-server</td><td align="left">Redis服务器启动</td></tr><tr><td align="left"><font color='red'>redis-cli</td><td align="left">Redis客户端，操作入口</td></tr></tbody></table><h2 id="前台启动（不推荐）"><a href="#前台启动（不推荐）" class="headerlink" title="前台启动（不推荐）"></a>前台启动（不推荐）</h2><p>运行redis-server命令启动，但命令行窗口不能关闭，否则服务器停止</p><h2 id="后台启动（推荐）"><a href="#后台启动（推荐）" class="headerlink" title="后台启动（推荐）"></a>后台启动（推荐）</h2><ol><li><p> 修改后台启动设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/redis-6.2.4             #进入redis目录下</span><br><span class="line">ls                              #查看文件</span><br><span class="line">cp redis.conf /etc/redis.conf   #为方便操作，复制redis.conf文件到其他目录下</span><br><span class="line">vim /opt/redis.conf             #进入编辑器修改文件</span><br></pre></td></tr></table></figure><p>在编辑器中通过<font color='red'>\daemonize</font>查找，将文件内的<font color='red'>daemonize no</font>改为<font color='red'>yes</font>，保存退出，使服务器能在后台启动</p></li><li><p> 后台启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /etc/redis.conf</span><br></pre></td></tr></table></figure></li><li><p> 查看进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure></li><li><p> 客户端通过输入<font color='red'>redis-cli</font>命令进行访问 </p></li></ol><div class="note info no-icon flat"><p>多个端口号可输入redis-cli -p 端口号</p></div><ol start="5"><li> 关闭后台Redis</li></ol><p>一、单实例关闭</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli shutdown</span><br></pre></td></tr></table></figure><p>二、多实例关闭，指定端口关闭</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 端口号 shutdown</span><br></pre></td></tr></table></figure><p>三、关闭Redis进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 进程号</span><br></pre></td></tr></table></figure><p>四、在Redis终端中输入shutdown进行关闭</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis详细概述</title>
      <link href="/posts/389b592e/"/>
      <url>/posts/389b592e/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="技术分类"><a href="#技术分类" class="headerlink" title="技术分类"></a>技术分类</h2><table><thead><tr><th align="left">解决问题类型</th><th align="left">技术</th></tr></thead><tbody><tr><td align="left">功能性</td><td align="left">JAVA、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN</td></tr><tr><td align="left">扩展性</td><td align="left">Struts、Spring、SpringMVC、Hibernate、Mybatis</td></tr><tr><td align="left">性能</td><td align="left">NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch</td></tr></tbody></table><p>随着web技术的不断发展，用户访问量的大幅度提升，同时也产生了大量的用户数据，加之智能移动设备的普及，<br>所有的互联网平台都面临着巨大的性能挑战。</p><div class="note danger no-icon flat"><p>web服务器面临着CPU及内存压力，数据库服务器面临着IO压力。</p></div><h2 id="问题及主要解决方案"><a href="#问题及主要解决方案" class="headerlink" title="问题及主要解决方案"></a>问题及主要解决方案</h2><div class="hide-toggle" style="border: 1px solid #e8fafe"><div class="hide-button toggle-title" style="background-color: #e8fafe;color: color"><i class="fas fa-caret-right fa-fw"></i><span>CPU及内存压力：主要为session存储问题</span></div>    <div class="hide-content"><p>但session应该存在哪里呢？</p><ol><li><p>存储在cookie中</p><p> 优点：极高的扩展性和可用性</p><p> 缺点：不安全</p></li><li><p>存储在文件服务器或者数据库里</p><p> 优点：简单高性能，支持分布式与集群</p><p> 缺点: 数据库的大量IO效率问题</p></li><li><p>session复制</p><p> 优点： 实现简单、配置较少、当网络中有机器Down掉时不影响用户访问</p><p> 缺点： 广播式复制有一定廷时，会带来一定网络开销；session对象内容相同，空间浪费造成session数据冗余，节点（服务器）越多浪费越大</p></li><li><p>存储在缓存数据库（例NoSQL数据库）</p><p> 优点： 不经过IO，减少访问数据库的频率，完全在内存中，速度快，数据结构简单，无形中缓解了CPU及内存压力</p></li></ol></div></div><div class="hide-toggle" style="border: 1px solid #fff8e9"><div class="hide-button toggle-title" style="background-color: #fff8e9;color: color"><i class="fas fa-caret-right fa-fw"></i><span>IO压力</span></div>    <div class="hide-content"><p>随着数据量的增多，数据库操作逐渐麻烦，效率也急剧降低</p><ol><li><p>数据库表进行拆分</p><p> 水平切分、垂直切分、读写分离，通过破坏一定的业务逻辑来换取性能</p></li><li><p>缓存数据库（例NoSQL数据库）</p><p> 通过添加缓存数据库，从中查询数据，从而减少IO的读操作，极大地提高查询效率</p></li></ol></div></div><h2 id="NoSQL数据库概述"><a href="#NoSQL数据库概述" class="headerlink" title="NoSQL数据库概述"></a>NoSQL数据库概述</h2><p>NoSQL(Not Only SQL)，意思为“不仅仅是SQL”，泛指非关系型数据库。</p><p>NoSQL相较于MySQL，它不依赖业务逻辑方式存储，而以简单的key-value模式存储，因此大大的增加了数据库的扩展能力。</p><ul><li>  不遵循SQL标准</li><li>  不支持ACID（即原子性、一致性、隔离性、持久性）</li><li>  远超于SQL的性能</li></ul><div class="note success flat"><p>NoSQL数据库打破了传统关系型数据库以业务逻辑为依据的存储模式，而是针对不同数据结构类型改为以性能为最有限的存储方式。</p></div><div class="hide-toggle" style="border: 1px solid #e8fafe"><div class="hide-button toggle-title" style="background-color: #e8fafe;color: color"><i class="fas fa-caret-right fa-fw"></i><span>适用场景</span></div>    <div class="hide-content"><ul><li>  对数据高并发读写，例如“购物秒杀系统”</li><li>  海量数据读写</li><li>  对数据高可扩展性的</li></ul></div></div><div class="hide-toggle" style="border: 1px solid #fff8e9"><div class="hide-button toggle-title" style="background-color: #fff8e9;color: color"><i class="fas fa-caret-right fa-fw"></i><span>不适用场景</span></div>    <div class="hide-content"><ul><li>  取代通过键查询，而是通过值来查询。 Key-Value数据库中根本没有通过值查询的途径。</li><li>  需要储存数据之间的关系。在Key-Value数据库中不能通过两个或以上的键来关联数据。</li><li>  事务的支持。在Key-Value数据库中故障产生时不可以进行回滚。</li></ul></div></div><h3 id="常见NoSQL数据库"><a href="#常见NoSQL数据库" class="headerlink" title="常见NoSQL数据库"></a>常见NoSQL数据库</h3><table><thead><tr><th>数据库名称</th><th>特点</th></tr></thead><tbody><tr><td>Memcache</td><td>1. 很早出现的NoSQL数据库<br>2. 多线程+锁的机制，数据库都在内存中，一般不持久化<br>3. 支持简单的key-value模式，支持类型单一<br>4. 一般是作为缓存数据库辅助持久化的数据库</td></tr><tr><td>Redis</td><td>1. 几乎覆盖了Memcache的绝大部分功能<br>2. 单线程+多路IO复用的机制，数据都在内存中，支持持久化，主要用作备份恢复<br>3. 除了支持简单的key-value模式，还支持多种数据结构的存储，如list、set、hash、zset等<br>4. 一般是作为缓存数据库辅助持久化的数据库</td></tr><tr><td>MongoDB</td><td>1. 文档型数据库<br>2. 数据都在内存中，若内存不足，则把不常用的数据存到硬盘<br>3. 虽然是key-value模式，但是对value（尤其是json）提供强大的查询功能<br>4. 支持二进制数据及大型对象<br>5. 可根据数据特点替代RDBMS，成为独立数据库，亦或配合RDBMS,存储特定数据</td></tr></tbody></table><div class="note orange icon simple"><i class="note-icon fas fa-battery-half"></i><p>看完上面对NoSQL的介绍，对Redis有一个大概了解了吧</p></div><h2 id="Redis概述"><a href="#Redis概述" class="headerlink" title="Redis概述"></a>Redis概述</h2><p>Redis是当今社会最受欢迎的NoSQL数据库之一，是一个使用ANSI C编写的开源，遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，且提供多种语言的API。</p><div class="note primary no-icon flat"><p>Redis具备以下特性：</p><ul><li>  开源C语言代码，支持单线程+多路IO复用，不依赖外部库，速度极快</li><li>  数据持久化，支持多种数据结构、编程语言</li><li>  高并发读写，支持lua脚本，主从复制</li><li>  高可用，支持分布式，理论上可以无限扩展 </li></ul></div><div class="note primary no-icon flat"><p>Redis的应用场景包括：<br>    缓存系统（“热点”数据：高频读、低频写)、计数器、消息队列系统、排行榜、社交网络和实时系统。</p></div><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: far fa-hand-point-right;color:  green larger">看看哪些大厂在使用Redis？  </button><span class="hide-content">github，twitter，微博，Stack Overflow，阿里巴巴，百度，腾讯，美团，搜狐...... </span></span>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156/"/>
      <url>/posts/4a17b156/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Welcome-to-my-blog"><a href="#Welcome-to-my-blog" class="headerlink" title="Welcome to my blog!"></a>Welcome to my blog!</h2><p> by zeker</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
