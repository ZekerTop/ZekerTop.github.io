<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis学习笔记（3）</title>
      <link href="/posts/6cb57fa2/"/>
      <url>/posts/6cb57fa2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Redis应用问题"><a href="#Redis应用问题" class="headerlink" title="Redis应用问题"></a>Redis应用问题</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>未完待续…持续更新</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记（2）</title>
      <link href="/posts/1bb24f34/"/>
      <url>/posts/1bb24f34/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note orange icon flat"><i class="note-icon fas fa-bullhorn"></i><p>前方多图提醒，请耐心等待加载或刷新页面，已参考多种资料，作图不易，且看且珍惜。（快累趴了）</p></div><h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>主从复制</code>，主机数据更新后根据配置和策略，自动同步道备机的<code>master/slaver机制</code>，<code>Master以写为主</code>，<code>Slave以读为主</code>。</p><p>其作用有以下几点：</p><ul><li>读写分离：主服务器负责写，各从服务器负责读，即主机写，从机读</li><li>容灾快速恢复：主从多台服务器进行持久化操作，任意一台服务器宕机也不会影响数据恢复，有效避免了单点故障问题，使数据持久化更加安全</li><li>其他：主从复制是实现哨兵模式和Redis集群的前提</li></ul><h2 id="实现主从复制"><a href="#实现主从复制" class="headerlink" title="实现主从复制"></a>实现主从复制</h2><p>每一台<code>Redis</code>服务器启动时，默认都为主服务器（master）,可通过命令<code>info replcation</code>查看</p><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/1.5foiw2sgbgo0.jpg" alt="1"></p><ol><li><p>配置文件修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /myredis                # 创建文件夹存储配置文件</span><br><span class="line">cd /myredis# 进入文件夹</span><br><span class="line">cp /etc/redis.conf /myredis/redis.conf# 复制原配置文件，以便操作</span><br></pre></td></tr></table></figure><p>创建<code>reids6379.conf</code>、<code>reids6380.conf</code>、<code>reids6381.conf</code>文件，在文件中填入以下信息</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include /myredis/redis.<span class="keyword">conf</span></span><br><span class="line">pidfile /var/run/redis_端口号.pid</span><br><span class="line">port （端口号）</span><br><span class="line">dbfilename dump（端口号）.rdb</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/2.6wgs4wui72w0.jpg" alt="2"></p></li><li><p>启动redis服务器</p><p>新建窗口通过<code>redis-cli -p 端口号</code>进入各自的客户端</p><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/3.36sncsb6o840.jpg" alt="3"></p></li><li><p>使用命令实现主从关系（配从不配主）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure><p>详情如下图所示</p><p>从节点：</p><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E4%BB%8E%E8%8A%82%E7%82%B9.31rkn6xum640.jpg" alt="从节点"></p><p>主节点：</p><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E4%B8%BB%E8%8A%82%E7%82%B9.124i7i3mtvg0.jpg" alt="主节点"></p></li><li><p>主从关系实现后，验证是否实现数据复制</p><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6.3458jbrjayg0.jpg" alt="数据复制"></p></li></ol><h2 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><p>在Redis2.8之前同步方式都以<code>全量方式</code>同步，但之后为了提高效率，数据复制方式分为两种：<code>全量复制</code>和<code>部分复制</code>。</p><ul><li>全量复制：将主服务器中的数据，全部同步到从服务器中，一般是在从服务器启动初始化数据的时候进行全量同步</li><li>部分复制：将未同步的增量数据，同步到从服务器，无需再全部复制一遍，一般用于因网络中断等无法同步数据的情况下，待恢复正常之后，将中断期间的数据进行部分同步</li></ul><h3 id="全量复制图解"><a href="#全量复制图解" class="headerlink" title="全量复制图解"></a>全量复制图解</h3><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/全量复制.40tonu0t4to0.png" alt="全量复制" style="zoom: 50%;" /><p>解释说明：</p><p>1、从节点断开连接后，发送同步请求<code>psync</code>尝试建立连接</p><p>2、主节点向从节点发送信息，获取<code>runid</code>和<code>offset</code></p><p>3、主节点fork子进程将全部数据生成<code>RDB文件</code></p><p>4、主节点期间接收到的<code>write</code>命令存入到复制缓冲区</p><p>5、当主节点<code>RDB文件</code>完成后发送给从节点</p><p>6、从节点接受<code>RDB文件</code>后，清空旧数据，加载RDB数据到内存中（即直接将其作为数据文件）</p><p>7、主节点发送缓冲区内的数据到从节点</p><p>8、从节点接受复制缓冲区命令并执行，最后同步到最新数据中</p><h3 id="部分复制图解"><a href="#部分复制图解" class="headerlink" title="部分复制图解"></a>部分复制图解</h3><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/部分复制.6cn0kqkut9o0.png" alt="部分复制" style="zoom:50%;" /><p>解释说明：</p><p>1、当主从服务器之间由于网络中断后，从节点会尝试连接主节点</p><p>2、重连期间主节点接收到的<code>write</code>命令会存入到复制缓冲区</p><p>3、当网络恢复后，从节点成功连接主节点，由于之前从节点保存了主节点的<code>runid</code> 和<code>offset</code>，所以只需要发送命令 <code>psync &#123;runid&#125; &#123;offset&#125;</code>即可</p><p>4、主节点接收到从节点的请求，会先验证请求的<code>runid</code>是否和自身的的 <code>runid</code>匹配，不匹配则进行<code>全量复制</code>，其后查看请求的<code>offset</code>在自身复制缓冲区查找，如果偏移量之后的数据存在缓冲区中，则对从节点发送<code> +CONTINUE</code> 响应，表示可以进行部分复制。</p><p>5、当从节点传递过来的runid和offset验证通过时，则进行部分复制，并记录新的<code>offset</code></p><div class="note info flat"><p>PS：当主机宕机时，主从关系仍存在，各从机中的主机信息不会发生改变，主机重启后，其从机信息与宕机前的一致</p></div><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><h3 id="一、-薪火相传"><a href="#一、-薪火相传" class="headerlink" title="一、    薪火相传"></a><strong>一、    薪火相传</strong></h3><p>有三个节点ABC，A为主机，B为A的从机，C为B的从机。</p><ol><li>主机A无法对C进行主从复制</li><li>当主机A存活时，B、C都不可写数据，只能读数据</li><li>主机A宕机后，B、C仍不可写数据，直到B使用<code>slaveof no one</code>命令后，即下面所讲的<code>反客为主</code>模式，B可以写数据，C可以读取B写的数据</li></ol><p><strong>官方概述</strong>：上一个<code>slave</code>（从机）可以是下一个<code>slave</code>（从机）的<code>master</code>（主机），<code>slave</code>同样可以接收其他slaves的连接和同步请求，那么该<code>slave</code>作为了链条中下一个的<code>master</code>，可以有效减轻<code>master</code>的写压力。</p><p><strong>风险</strong>：一旦某个从机宕机，后面的从机都无法备份。</p><p><strong>中途变更转向</strong>：会清除之前的数据，重新建立拷贝最新的。</p><h3 id="二、-反客为主"><a href="#二、-反客为主" class="headerlink" title="二、    反客为主"></a><strong>二、    反客为主</strong></h3><p>当一个<code>master</code>宕机后，后面的<code>slave</code>通过命令可以立刻升为<code>master</code>，其后面的<code>slave</code>不用做任何修改，但不用修改的前提在于<code>从机</code>实现了薪火相传模式，否则仍需进行主从关系确认。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof no one# 将从机变为主机</span><br></pre></td></tr></table></figure><p>当宕机后的<code>master</code>重启后，此时已无任何主从关系，无任何复制关系。</p><h3 id="三、-哨兵模式"><a href="#三、-哨兵模式" class="headerlink" title="三、    哨兵模式"></a><strong>三、    哨兵模式</strong></h3><p>哨兵模式，俗称<font color="red">反客为主的自动版</font>，能够后台监控主机是否故障，若故障了则根据<code>投票数</code>自动<code>将从库转换为主库</code>，保证了系统的可用性。</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>监控（Monitoring）：哨兵会不断地检查主节点和从节点是否运行正常</li><li>自动故障转移（Automatic faliover）：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点</li><li>配置提供者（Configuration provider）：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址</li><li>通知（Notification）：哨兵可以将故障转移的结果发送给客户端</li></ul><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li><p>调整为<code>一主二仆模式</code>，<code>6379</code>带着<code>6380</code>、<code>6381</code></p></li><li><p>在自定义的<code>/myredis</code>目录下新建<code>sentinel.conf</code>，切记文件名不能有错</p></li><li><p>配置哨兵</p><p>在<code>sentinel.conf</code>文件中填入配置信息，保存退出</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster <span class="number">127.0</span>.<span class="number">0.1</span> <span class="number">6379</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>注：<code>mymaster</code>为监控对象起的服务器名称（即哨兵名称），<code>1</code>为至少有多少个哨兵同意迁移的数量</p></li><li><p>启动哨兵</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /myredis/sentinel.conf</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E5%93%A8%E5%85%B5%E5%90%AF%E5%8A%A8.6svp11zonng0.jpg" alt="启动哨兵"></p></li><li><p>当主节点6379宕机后，等待30秒，哨兵进行投票推选新主节点</p><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E5%93%A8%E5%85%B5%E7%A5%A8%E9%80%89.5xpehoup20s0.jpg" alt="哨兵票选"></p></li><li><p>当主节点6379重新连接后，哨兵服务端响应两句</p><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E5%8E%9F%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF.18mr2583aghs.jpg" alt="原主机上线"></p><p>第一句是：去除6379的下线处理</p><p>第二句是：重连6379到新的主节点上，此时6379为新主节点的从节点</p></li><li><p>检验主从复制是否正常工作</p><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E6%A3%80%E9%AA%8C%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.62himtzsuys0.jpg" alt="检验主从复制"></p><p>上图所见，主从复制正常运行，至此，哨兵模式的配置完成</p></li></ol><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：<code>高可用</code>，<code>读写分离</code>，哨兵模式是基于主从模式的，主从模式的优点，哨兵模式都具备，主从可以自动切换，系统更健壮，可用性更高。</p><p>缺点：Redis比较难支持在线扩容，在集群容量达到上线时在线扩容会变得非常复杂。</p><h1 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>所谓的集群，就是通过添加服务器的数量，提供相同的服务，从而让服务器达到一个稳定、高效的状态，集群主要解决<code>容量不够</code>和<code>并发写操作压力</code>等问题。</p><p>Redis3.0版本之前只支持单例（代理主机），在3.0版本即以后的版本才支持集群，采用<code>无中心化集群</code>配置。</p><p>Redis集群，是基于Redis主从复制实现的，同时也存在三种模式：<code>主从模式</code>、<code>哨兵模式</code>和<code>Cluster集群模式</code>。</p><p>由于前两种模式在前面<code>主从复制</code>环节中有讲解，所以我们这里重点关注<code>Cluster模式</code>。</p><h2 id="Cluster集群模式"><a href="#Cluster集群模式" class="headerlink" title="Cluster集群模式"></a>Cluster集群模式</h2><ul><li>之前的<code>哨兵模式</code>基本已经可以实现高可用、读写分离，但是在这种模式每台redis服务器都存储相同的数据，很<code>浪费内存资源</code>，所以在Redis3.0上加入了<code>Cluster集群模式</code>，实现了Redis的<code>分布式存储</code>，也就是说每台Redis节点存储着不同的内容</li><li>根据官方推荐，集群部署至少要<code>3台以上</code>的master节点，最好使用<code>3主3从</code>六个节点的模式</li><li>Cluster集群由多个redis服务器组成的<code>分布式网络服务集群</code>，集群之中有多个master主节点，每一个主节点都可读可写，节点之间会相互通信，两两相连，redis集群无中心节点</li></ul><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E6%97%A0%E4%B8%AD%E5%BF%83%E5%8C%96%E9%9B%86%E7%BE%A4.2s6cwtc8k6g0.png" alt="无中心化集群"></p><ul><li>在<code>redis-Cluster集群</code>中，可以给每个主节点添加从节点，主节点和从节点直接遵循主从模型的特性，当用户需要处理更多读请求的时候，添加从节点可以扩展系统的读性能</li><li><code>redis-cluster</code>的<code>故障转移</code>：redis集群的主机节点内置了类似redis sentinel的<code>节点故障检测</code>和<code>自动故障转移</code>功能，当集群中的某个主节点下线时，集群中的其他在线主节点会注意到这一点，并且对已经下线的主节点进行故障转移</li><li>集群进行故障转移的方法和<code>redis sentinel</code>进行故障转移的方法基本一样，不同的是，在集群里面，故障转移是由集群中其他在线的主节点负责进行的，所以集群不必另外使用<code>redis sentinel</code></li></ul><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>删除持久化数据（rdb/aof文件）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /myredis# 进入自定义目录</span><br><span class="line">rm -rf rdb*# 删除rdb文件，如若有aof文件，也一并删除</span><br></pre></td></tr></table></figure></li><li><p>实例准备</p><p>Master端口：6379、6380、6381</p><p>Slave端口：6389、6390、6391</p><div class="note warning flat"><p>分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上。</p></div><p>配置文件<code>redis6379.conf</code></p><p>删除之前的哨兵数据，添加下面的集群配置，保存退出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cluster-enabled yes# 打开集群模式</span><br><span class="line">cluster-config-file nodes-6379.conf# 设定节点配置文件</span><br><span class="line">cluster-node-timeout 15000# 集群节点的超时时限默认值</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E5%88%A0%E9%99%A4.aamudg5l9f4.jpg" alt="集群配置删除"></p><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E6%B7%BB%E5%8A%A0.4c4xk3rl6qi0.jpg" alt="集群配置添加"></p><p>删除原来的<code>redis6380.conf</code>和<code>redis6381.conf</code>文件，另外<code>拷贝5份</code>修改的<code>redis6379.conf</code>为对应端口号文件</p><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6.185f6wfoq2yo.jpg" alt="拷贝文件"></p><p>进入vim编辑器，在命令模式下使用<code>:%s/6379/替换后端口</code>快速修改5份拷贝后的配置文件信息</p></li><li><p>启动6个redis服务</p><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1.22uohujnmgcg.jpg" alt="启动服务"></p></li><li><p>组合集群</p><p>组合之前，确保所有redis服务启动后，<code>nodes-端口号.conf</code>文件都生成正常</p><p>如果你是redis5.0及之后的，无需安装ruby依赖，redis安装目录里内置了集群命令行工具redis-trib ，它是一个 Ruby 程序， 这个程序通过向实例发送特殊命令来完成创建新集群， 检查群， 或者对集群进行重新分片工作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create 192.168.30.0:6379 192.168.30.0:6380 192.168.30.0:6381 192.168.30.0:6389 192.168.30.0:6390 192.168.30.0:6391 --cluster-replicas 1# 组合命令</span><br></pre></td></tr></table></figure> <div class="note info no-icon flat"><p>ps：<code>--cluster-replicas 1</code> 这个指的是从机的数量，表示我们希望为集群中的每个主节点创建一个从节点。另外，主从是随机绑定的，创建完成后可以在master节点中看到所有节点状态（netstat -natp | grep 6379） </p></div><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E7%BB%84%E5%90%88%E9%9B%86%E7%BE%A4.5p63gwu2zhk0.jpg" alt="组合集群"></p></li><li><p>测试集群</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c -p 端口号    # -c参数实现自动重定向，连接客户端</span><br><span class="line">cluster info    # 查看集群状态</span><br><span class="line">cluster nodes    # 查看节点信息</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E6%B5%8B%E8%AF%95%E9%9B%86%E7%BE%A4.h1u9gsuk0nc.jpg" alt="测试集群"></p><p>如图所示，集群搭建成功。</p> <div class="note info no-icon flat"><p>Redis 集群有<code>16384</code>个<code>哈希槽</code>，每个<code>key</code>通过<code>CRC16</code>校验后对16384取模来决定放置哪个槽。集群的每个节点负责一部分hash槽，举个例子，比如当前集群有3个节点ABC，那么：</p><ul><li>节点 A 包含 <code>0</code> 到 <code>5460</code>号哈希槽</li><li>节点 B 包含<code>5461</code> 到 <code>10922</code> 号哈希槽</li><li>节点 C 包含<code>10923</code> 到 <code>16383</code>号哈希槽</li></ul></div><p>尝试往集群中写入数据</p><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE.5rjk9tsc1xs0.jpg" alt="写入数据"></p><p>不在一个<code>slot</code>下的键值，是不能使用<code>mget、mset等多键操作</code>，但可通过<code>&#123;&#125;</code>内相同内容的键值对放到同一个<code>slot</code>中去</p><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/%E5%A4%9A%E9%94%AE%E6%93%8D%E4%BD%9C.3ukznasnqym0.jpg" alt="多键操作"></p><p>查询集群中的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cluster keyslot &lt;key&gt;                # 计算key的插槽值</span><br><span class="line">cluster countkeysinslot &lt;slot&gt;        # 返回slot槽的键数(只能查看自己插槽范围内的值)</span><br><span class="line">cluster getkeysinslot &lt;slot&gt; &lt;count&gt;# 返回count个slot槽中的键</span><br></pre></td></tr></table></figure></li><li><p>集群的Jedis开发</p><p>无中心化主从集群。即使连接的不是主机，集群会自动切换主机存储。遵循<code>主写从读</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- jedis依赖包引入  --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisClusterTest</span></span>&#123;</span><br><span class="line">    <span class="function">publi <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">         Set&lt;HostAndPort&gt; set = <span class="keyword">new</span> HashSet&lt;HostAndPort&gt;();</span><br><span class="line">         set.add(<span class="keyword">new</span> HashSet&lt;HostAndPort&gt;(<span class="string">&quot;192.168.30.0&quot;</span>,<span class="number">6379</span>));</span><br><span class="line">         JedisCluster jc = <span class="keyword">new</span> JedisCluster(set);</span><br><span class="line">         jc.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;zeker&quot;</span>);</span><br><span class="line">         String value = jc.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">         System.out.println(value);</span><br><span class="line">         jc.close();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="集群优缺点"><a href="#集群优缺点" class="headerlink" title="集群优缺点"></a>集群优缺点</h3><p>优点：实现扩容、分摊压力、无中心配置相对简单</p><p>缺点：多键操作、多键的Redis事务、lua脚本均不被支持</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring boot整合Redis</title>
      <link href="/posts/b921ad40/"/>
      <url>/posts/b921ad40/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Jedis、Spring-data-redis的配置以及区别"><a href="#Jedis、Spring-data-redis的配置以及区别" class="headerlink" title="Jedis、Spring-data-redis的配置以及区别"></a>Jedis、Spring-data-redis的配置以及区别</h1><h2 id="Jedis如何配置"><a href="#Jedis如何配置" class="headerlink" title="Jedis如何配置"></a>Jedis如何配置</h2><ol><li><p>jedis引入依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--        Jedis引入依赖--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>连接Redis客户端</p><ol><li><p>Jedis直连</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.30.0&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">jedis.set(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">String value = jedis.get(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>JedisPool 连接池的使用</p><p>配置文件<code>jedis.properties</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 资源池最大连接数</span><br><span class="line">maxTotal=<span class="number">50</span>             </span><br><span class="line"># 资源池允许最大空闲连接数</span><br><span class="line">maxIdle=<span class="number">10</span>              </span><br><span class="line"># redis服务器地址</span><br><span class="line">host=<span class="number">192.168</span><span class="number">.30</span><span class="number">.0</span> </span><br><span class="line"># redis开放端口</span><br><span class="line">port=<span class="number">6379</span>             </span><br></pre></td></tr></table></figure><p>类<code>JedisUtils.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个连接池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//读取配置文件</span></span><br><span class="line">        InputStream is = JedisUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jedis.properties&quot;</span>);</span><br><span class="line">        Properties pro=<span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pro.load(is);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//连接池配置</span></span><br><span class="line">        JedisPoolConfig config=<span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        config.setMaxTotal(Integer.parseInt(pro.getProperty(<span class="string">&quot;maxTotal&quot;</span>)));</span><br><span class="line">        config.setMaxIdle(Integer.parseInt(pro.getProperty(<span class="string">&quot;maxIdle&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化连接池，把对应参数传递进去</span></span><br><span class="line">        jedisPool=<span class="keyword">new</span> JedisPool(config,pro.getProperty(<span class="string">&quot;host&quot;</span>), Integer.parseInt(pro.getProperty(<span class="string">&quot;port&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置好后返回，返回一个Jedis对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类<code>JedisTest.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取连接池对象</span></span><br><span class="line">            jedis = JedisUtils.getJedis();</span><br><span class="line">            <span class="comment">//执行操作</span></span><br><span class="line">            jedis.set(<span class="string">&quot;java&quot;</span>, <span class="string">&quot;good&quot;</span>);</span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;java&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//这里使用的close不代表关闭连接，指的是归还资源</span></span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>Jedis<code>直连</code>与Jedis<code>连接池</code>使用的对比</p><table><thead><tr><th>方案</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>Jedis直连</td><td>简单方便<br>适用于连接数较少且使用时间较长，可构成长连接场景</td><td>存在每次新建/关闭TCP开销<br>资源无法控制，存在连接泄露的可能<br>Jedis对象线程不安全</td></tr><tr><td>Jedis连接池</td><td>Jedis预先生成，降低开销<br>连接池的形成保护和控制资源的使用</td><td>相对于直连，使用相对麻烦，尤其在资源管理上需要很多参数来保证，一旦规划不合理就会出现问题</td></tr></tbody></table></li></ol><h2 id="Spring-data-redis如何配置"><a href="#Spring-data-redis如何配置" class="headerlink" title="Spring-data-redis如何配置"></a>Spring-data-redis如何配置</h2><ol><li><p> spring-data-redis引入依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--        redis--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.6</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p> 添加配置文件<code>application.properties</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#Redis服务器地址</span><br><span class="line">spring.redis.host=<span class="number">192.168</span><span class="number">.30</span><span class="number">.0</span></span><br><span class="line">#Redis服务器连接端口（默认端口为<span class="number">6379</span>）</span><br><span class="line">spring.redis.port=<span class="number">6379</span></span><br><span class="line">#Redis数据库索引（默认位<span class="number">0</span>）</span><br><span class="line">spring.redis.database=<span class="number">0</span></span><br><span class="line">#连接超时时间（毫秒）</span><br><span class="line">spring.redis.timeout=<span class="number">1800000</span></span><br><span class="line">#连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">spring.redis.lettuce.pool.max-active=<span class="number">20</span></span><br><span class="line">#最大阻塞等待时间（复数表示没有限制）</span><br><span class="line">spring.redis.lettuce.pool.max-wait=-<span class="number">1</span></span><br><span class="line">#连接池中的最大空闲连接</span><br><span class="line">spring.redis.lettuce.pool.max-idle=<span class="number">5</span></span><br><span class="line">#连接池中的最小空闲连接</span><br><span class="line">spring.redis.lettuce.pool.min-idle=<span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p> 添加Redis配置类<code>RedisConfig.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate();</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance ,</span><br><span class="line">                ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        template.setKeySerializer(redisSerializer);</span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance ,</span><br><span class="line">                ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line">        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofSeconds(<span class="number">600</span>))</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line">        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p> 创建Controller试验一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/redisTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTestControllor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;zeker&quot;</span>);</span><br><span class="line">        String name = (String) redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p> 根据自己开设的端口访问<code>http://localhost:8080/redisTest</code></p></li></ol><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210806/666ae2ea6a519635d9932f43f286144.mt0bja0dxmo.png" alt="1"></p><h2 id="常见问题及解决方法"><a href="#常见问题及解决方法" class="headerlink" title="常见问题及解决方法"></a>常见问题及解决方法</h2><div class="note info no-icon flat"><p>Could not get a resource from the pool; nested exception is io.lettuce.core.RedisConnectionException: Unable to connect to 192.168.30.0:6379</p></div><p>1、查看是否启动Redis服务器</p><p>2、查看目标IP地址是否可以ping通</p><p>3、Redis的配置application.yml（或application.properties）中spring.redis.timeout连接超时时间（毫秒）中设置不能为0</p><p>4、修改redis的配置文件redis.conf</p><ol><li>protected-mode yes 改为 protected-mode no<br> （该配置项表示是否开启保护模式，默认是开启，开启后Redis只会本地进行访问，拒绝外部访问）</li><li>注释掉 bin127.0.0.1 即 #bin 127.0.0.1<br> （PS: 不注释掉，表示指定 Redis 只接收来自于该 IP 地址的请求，注释掉后，则表示将处理所有请求）</li></ol><div class="note warning flat"><p>修改配置文件redis.conf后记得保存重启redis</p></div><p>5、如果在Redis中没有配置requirepass，那么在application.properties（或application.yaml）中就不要写spring.redis.password</p><p>6、开放对应端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=6379/tcp# 开放6379端口号</span><br><span class="line">firewall-cmd --query-port=6379/tcp# 查看端口号是否打开</span><br></pre></td></tr></table></figure><div class="note info no-icon flat"><p>PS：云服务器需在安全组中设置对应端口号，不建议开放所有端口。在<code>虚拟机上测试</code>也可以选择关闭防火墙<code>systemctl stop firewalld</code>。</p></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Jedis</code>是Redis官方推荐的面向Java的操作Redis的客户端，而<code>RedisTemplate</code>是<code>Spring-data-redis</code>中对<code>Jedis</code>Api的高度封装。</p><p><code>Spring-data-redis</code>相对于Jedis来说可以方便地更换Redis的Java客户端，比Jedis多了自动管理连接池的特性，方便与其他Spring框架进行搭配使用</p><p>总体来说，<code>Jedis</code>，更像<code>spring 与 MySQL</code>结合，通过操作连接池，获取实例操作数据库，而<code>Spring-data-redis</code>与spring的整合，更像<code>spring 与 mybatis</code>整合，通过工厂，创建实例，再操作实例。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置 </tag>
            
            <tag> Redis </tag>
            
            <tag> Spring boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记（1）</title>
      <link href="/posts/d9238aea/"/>
      <url>/posts/d9238aea/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Redis键（key）"><a href="#Redis键（key）" class="headerlink" title="Redis键（key）"></a>Redis键（key）</h2><table><thead><tr><th align="left">命令</th><th>描述</th></tr></thead><tbody><tr><td align="left">keys *</td><td>查看当前库所有key</td></tr><tr><td align="left">exists &lt;key&gt;</td><td>判断某个key是否存在</td></tr><tr><td align="left">type &lt;key&gt;</td><td>查看key是什么类型</td></tr><tr><td align="left">del &lt;key&gt;</td><td>删除指定的key数据</td></tr><tr><td align="left">expore &lt;key&gt; &lt;time&gt;</td><td>为给定的key设置过期时间time（单位秒）</td></tr><tr><td align="left">ttl &lt;key&gt;</td><td>查看还有多少秒过期，-1表示永不过期，-2表示已过期</td></tr><tr><td align="left">select &lt;index&gt;</td><td>切换当前数据库（共16个数据库，0为默认库）</td></tr><tr><td align="left">dbsize</td><td>查看当前数据库key的数量</td></tr><tr><td align="left">flushdb/flushall</td><td>清空当前库/全部库</td></tr></tbody></table><h2 id="Redis字符串（String）"><a href="#Redis字符串（String）" class="headerlink" title="Redis字符串（String）"></a>Redis字符串（String）</h2><p><code>String</code>类型是二进制安全的，意味着Redis的<code>String</code>可包含任何数据，比如jpg图片或者序列化的对象。</p><p>一个Redis中字符串value最多可以是512M。</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>set &lt;key&gt; &lt;value&gt;</td><td>添加键值对</td></tr><tr><td>get &lt;key&gt;</td><td>查询对应键值</td></tr><tr><td>append &lt;key&gt; &lt;value&gt;</td><td>将给定的value追加到原值的末尾</td></tr><tr><td>strlen &lt;key&gt;</td><td>获得key的长度</td></tr><tr><td>setnx &lt;key&gt; &lt;value&gt;</td><td>只有在key不存在时，才能设置key的值</td></tr><tr><td>incr/decr &lt;key&gt;</td><td>将key中储存的数字值增/减（+/-） 1</td></tr><tr><td>incrby/decrby &lt;key&gt; &lt;步长&gt;</td><td>将key中储存的数字值增/减，自定义步长</td></tr><tr><td>mset &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;….</td><td>同时设置一个或多个key-value对</td></tr><tr><td>mget &lt;key1&gt;&lt;key2&gt;….</td><td>同时获取一个或多个value</td></tr><tr><td>msetnx &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;….</td><td>同时设置一个或多个key-value对，当且仅当所有给定key都不存在</td></tr><tr><td>getrange &lt;key&gt; &lt;起始位置&gt;&lt;结束位置&gt;</td><td>获得值的范围（全部：get key 0 -1）</td></tr><tr><td>setrange &lt;key&gt;&lt;起始位置&gt;&lt;value&gt;</td><td>用value覆写key所储存的字符串值，从起始位置开始（索引从0开始）</td></tr><tr><td>setnx &lt;key&gt; &lt;过期时间&gt;&lt;value&gt;</td><td>设置键值的同时，设置过期时间（单位秒）</td></tr><tr><td>getset&lt;key&gt;&lt;value&gt;</td><td>设置新值同时获得旧值</td></tr></tbody></table><h2 id="Redis列表（List）"><a href="#Redis列表（List）" class="headerlink" title="Redis列表（List）"></a>Redis列表（List）</h2><p><strong>单键多值，双向链表</strong></p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>lpush/rpush &lt;key&gt; &lt;value1&gt; &lt;value2&gt;….</td><td>从左边/右边插入一个或多个值</td></tr><tr><td>lpop/rpop  &lt;key&gt;</td><td>从左边/右边吐出一个值。</td></tr><tr><td>rpoplpush  &lt;key1&gt; &lt;key2&gt;</td><td>从key1列表右边吐出一个值，查到key2列表右边</td></tr><tr><td>lrange &lt;key&gt; &lt;start&gt; &lt;stop&gt;</td><td>按照索引下标获得元素（从左到右）&lt;br&gt;（全部：lrange key 0 -1）</td></tr><tr><td>lindex &lt;key&gt; &lt;index&gt;</td><td>按照索引下标获得元素（从左到右）</td></tr><tr><td>llen &lt;key&gt;</td><td>获得列表的长度</td></tr><tr><td>linsert &lt;key&gt; before/after &lt;value&gt; &lt;newvalue&gt;</td><td>在value的前/后面插入newvalue值</td></tr><tr><td>lrem &lt;key&gt; &lt;n&gt; &lt;value&gt;</td><td>从左边删除n个value（从左到右）</td></tr><tr><td>lset &lt;key&gt; &lt;index&gt; &lt;value&gt;</td><td>将列表key下标为index的值替换成value</td></tr></tbody></table><h2 id="Redis集合（Set）"><a href="#Redis集合（Set）" class="headerlink" title="Redis集合（Set）"></a>Redis集合（Set）</h2><p>Redis的集合<code>Set</code>是String类型的无序集合，与list类似是一个列表的功能，但<code>Set</code>可以自动数据排重。底层是一个value为<code>null</code>的hash表，所以添加、删除、查找的复杂度都为<code>O(1)</code>。</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>sadd &lt;key&gt; &lt;member1&gt; &lt;member2&gt;….</td><td>将一个或多个member元素加入到集合key中，已存在的member将被忽略</td></tr><tr><td>smembers &lt;key&gt;</td><td>取出该集合的所有值</td></tr><tr><td>sismember &lt;key&gt; &lt;member&gt;</td><td>判断集合key是否含有该member值，有则1，无则0</td></tr><tr><td>scard &lt;key&gt;</td><td>返回该集合的元素个数</td></tr><tr><td>srem &lt;key&gt; &lt;member1&gt; &lt;member2&gt;….</td><td>删除集合中的某个元素</td></tr><tr><td>spop &lt;key&gt;</td><td>随机从该集合中吐出一个值</td></tr><tr><td>srandmember &lt;key&gt; &lt;n&gt;</td><td>随机从该集合中取出n个值。值不会从集合中删除</td></tr><tr><td>smove &lt;source&gt; &lt;destination&gt;  &lt;member&gt;</td><td>把集合中的一个member值从一个集合移动到另一个集合中</td></tr><tr><td>sinter/sunion &lt;key1&gt; &lt;key2&gt;</td><td>返回两个集合的交集/并集元素</td></tr><tr><td>sdiff &lt;key1&gt; &lt;key2&gt;</td><td>返回两个集合的差集元素（key1中的，不包含key2中的）</td></tr></tbody></table><h2 id="Redis哈希（Hash）"><a href="#Redis哈希（Hash）" class="headerlink" title="Redis哈希（Hash）"></a>Redis哈希（Hash）</h2><p>Redis的<code>Hash</code>是一个String类型的field和value的映射表，hash适合用于存储对象，类似Java中的<code>Map&lt;String, Object&gt;</code>。</p><p>当key存储的value过多时，往往为了提高查询效率，例如用户ID为key，field有姓名、年龄、职业等信息，这是我们可以选择通过key(用户ID)+field(属性标签)就可以操作对应属性的数据。</p><p>类似于map套娃：<code>&lt;String， &lt;Map&lt;key, value&gt;&gt;&gt;</code></p><div class="note green no-icon flat"><p>好处：既不需要重复存储数据，避免了数据冗余，也不会带来序列化和并发修改控制的问题。</p></div><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>hset &lt;key&gt; &lt;field&gt; &lt;value&gt;</td><td>给key集合中的field键赋值value，例：hset user:001 name zeker</td></tr><tr><td>hget &lt;key&gt; &lt;field&gt;</td><td>从key集合中的fild中取出value</td></tr><tr><td>hmset &lt;key&gt; &lt;field1&gt; &lt;value1&gt; &lt;field2&gt; &lt;value2&gt;….</td><td>批量设置hash的值</td></tr><tr><td>hexists &lt;key&gt; &lt;field&gt;</td><td>查看哈希表key中，给定field是否存在</td></tr><tr><td>hkeys &lt;key&gt;</td><td>列出该hash集合的所有field</td></tr><tr><td>hvals &lt;key&gt;</td><td>列出该hash集合的所有value</td></tr><tr><td>hincrby &lt;key&gt; &lt;field&gt; &lt;increment&gt;</td><td>为哈希表key中的field的值加上增量increment（例：1 -1）</td></tr><tr><td>hsetnx &lt;key&gt; &lt;field&gt; &lt;value&gt;</td><td>将哈希表key中的field的值设置为value，当且仅当field不存在</td></tr></tbody></table><h2 id="Redis有序集合（Zset）"><a href="#Redis有序集合（Zset）" class="headerlink" title="Redis有序集合（Zset）"></a>Redis有序集合（Zset）</h2><p>Redis有序集合<code>Zset</code>与普通集合Set相似，都是一个没有重复元素的字符串集合。</p><p>不同之处在于有序集合<code>Zset</code>的每个成员都关联了一个评分（score），这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。</p><p>集合中的成员是唯一的，但评分可以是重复的。这里例子可以为：排行榜</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>zadd &lt;key&gt; &lt;score1&gt; &lt;member1&gt; &lt;score2&gt; &lt;member2&gt;….</td><td>将一个或多个memeber元素及其score值加入到有序集key中</td></tr><tr><td>zrange &lt;key&gt; &lt;start&gt; &lt;stop&gt; [withscores]</td><td>返回有序集key中，下标在start与stop之间的元素(withscores可让分数与值返回到结果集</td></tr><tr><td>zrangebyscore key min max [withscoers]  [limit offset count]</td><td>返回有序集key中，所有score值介于min和max之间（包括等于min或max）的成员，有序集成员按score值递增（从小到大）次序排列</td></tr><tr><td>zrevrangebyscore key max min [withscoers]  [limit offset count]</td><td>dev：反转。意思同上，次序从大到小排列</td></tr><tr><td>zincrby &lt;key&gt; &lt;increment&gt; &lt;member&gt;</td><td>为元素member的score加上增量increment</td></tr><tr><td>zrem &lt;key&gt; &lt;member&gt;</td><td>删除该集合下指定值的元素</td></tr><tr><td>zcount &lt;key&gt; &lt;min&gt; &lt;max&gt;</td><td>统计该集合中分数区间内的元素个数</td></tr><tr><td>zrank &lt;key&gt; &lt;member&gt;</td><td>返回该元素member在集合中的排名，从0开始</td></tr></tbody></table><p>Zset底层中使用了两种数据结构：hash表与跳跃表</p><ol><li>hash表，作用就是关联元素value和权重score，保障元素value的唯一值，可以通过元素value找到相应的score值。</li><li>跳跃表，目的在于给元素value排序，根据score的范围获取元素列表，从而比普通列表查询效率更快。</li></ol><h2 id="Redis新数据类型"><a href="#Redis新数据类型" class="headerlink" title="Redis新数据类型"></a>Redis新数据类型</h2><h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><p>Redis提供<code>Bitmaps</code>这个”数据类型“可以实现对位的操作：</p><p>（1）<code>Bitmaps</code>本身不是一种数据结构，实际上就是字符串，但是它可以对字符串的位进行操作。、</p><p>（2）<code>Bitmaps</code>单独提供了一套命令，所以在Redis中使用<code>Bitmaps</code>和使用字符串的方法不太相同。可以<code>Bitmaps</code>想象成一个以位为单位数组，数组中的每个单元只能存0或者1，数组的下标在<code>Bitmaps</code>中叫做偏移量。单个<code>Bitmaps</code>的最大长度是<code>512MB</code>，即<code>2^32</code>个比特位。</p><div class="note green no-icon flat"><p>合理地使用操作位能够有效地提高内存使用率和开发效率，并且可以极大地节省内存空间。<br>例如：用户访问，统计不同电话号码的个数以及布隆过滤法（URL的排重、垃圾邮箱地址的过滤）……</p></div><table><thead><tr><th>命令</th><th>描述</th><th></th></tr></thead><tbody><tr><td>setbit &lt;key&gt; &lt;offset&gt; &lt;value&gt;</td><td>设置Bitmaps中某个偏移量offset的值value</td><td></td></tr><tr><td>getbit &lt;key&gt; &lt;offset&gt;</td><td>获取Bitmaps中某个偏移量offset的值value</td><td></td></tr><tr><td>bitcount &lt;key&gt; [start end]</td><td>统计字符串从start字节到end字节比特值为1的数量</td><td></td></tr><tr><td>bitop and(or/not/xor) &lt;destkey&gt; [key….]</td><td>多个Bitmaps的and（交集）、or（并集）、not（非）、xor（异或）操作并将结果保存在destkey中</td><td></td></tr></tbody></table><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><div class="note default no-icon flat"><p>在工作当中，经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。<br>但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？而这种求集合中不重复元素个数的问题称为基数问题。</p></div><p>解决基数问题方案：</p><p>（1）数据存储在MySQL表中，使用distinct count计算不重复个数</p><p>（2）使用Redis提供的hash、set、bitmaps等数据结构来处理</p><p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。</p><p>为了能够降低一定的精度来平衡存储空间，Redis推出了HyperLogLog，一种用来做基数统计的算法。</p><p>其优点在于：</p><p>在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p><p>每个<code>HyperLogLog</code>键只需要花费 <code>12 KB</code>内存，就可以计算接近 <code>2^64</code> 个不同元素的<code>基数</code>。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p><div class="note info flat"><p>基数 = 数据集元素个数 - 重复数字个数</p></div><p>但是，因为<code>HyperLogLog</code>只会根据输入元素来计算基数，而不会储存输入元素本身，所以 <code>HyperLogLog</code>不能像集合那样，返回输入的各个元素。</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>padd &lt;key&gt; &lt;element&gt; [element….]</td><td>添加指定元素element到HyperLogLog中</td></tr><tr><td>pfcount &lt;key&gt; [key….]</td><td>计算key中的基数</td></tr><tr><td>pfmerge &lt;destkey&gt; &lt;sourcekey&gt; [sourcekey….]</td><td>将一个或多个key合并后的结果储存在另一个destkey中</td></tr></tbody></table><h3 id="Geospatital"><a href="#Geospatital" class="headerlink" title="Geospatital"></a>Geospatital</h3><p><code>Redis GEO</code>，Geographic，地理信息的缩写。</p><p>主要用于存储地理位置信息，即经纬度（二维坐标），基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>geoadd &lt;key&gt; &lt;longitude&gt; &lt;latitude&gt; &lt;member&gt; [longitude latitude member….]</td><td>添加地理位置（经度、维度、名称）（有效经度：-180度到180度；有效纬度：-85.05112878度到85.05112878度）</td></tr><tr><td>geopos &lt;key&gt; &lt;member&gt; [member….]</td><td>获得指定地区member的坐标</td></tr><tr><td>geodist &lt;key&gt; &lt;member1&gt; &lt;member2&gt; [m|km|ft|mi]</td><td>获取两个指定地区位置之间的直线距离（单位：米|千米|英尺|英里，默认单位米）</td></tr><tr><td>georadius &lt;key&gt; &lt;longitude&gt; &lt;latitude&gt; radius    m|km|ft|mi</td><td>以给定的经纬度为中心找出某一半径radius内的元素</td></tr></tbody></table><h2 id="Redis事务命令"><a href="#Redis事务命令" class="headerlink" title="Redis事务命令"></a>Redis事务命令</h2><p>一个事务从开始到执行会经历以下三个阶段：</p><ul><li>开始事务</li><li>命令入队</li><li>执行事务</li></ul><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>multi</td><td>标记一个事务块的开始，开始对命令的组队阶段</td></tr><tr><td>exec</td><td>执行所有事务块内的命令，开始执行阶段</td></tr><tr><td>discard</td><td>取消事务，放弃执行事务块内的所有命令</td></tr><tr><td>watch &lt;key&gt; [key….]</td><td>监视一个（或多个）key，如果在事务执行之前这个（或这些）key被其他命令锁改动，那么事务将被打断</td></tr><tr><td>unwatch</td><td>取消watch命令对所有key的监视</td></tr></tbody></table><p>组队阶段中某个命令出现了命令报错，执行阶段整个的所有队列都会被取消。</p><p>而当组队阶段无报错，执行阶段某一命令出现了命令报错，则只有报错的命令不会被执行，其他命令不受影响。</p><p>当出现事务冲突时，Redis往往呈现出<code>乐观锁</code>的形式进行处理，即在使用完数据<code>修改版本号</code>等机制，提高吞吐量，而Redis就是利用这种<code>check-and-set</code>机制实现事务。</p><h3 id="事务三特性"><a href="#事务三特性" class="headerlink" title="事务三特性"></a>事务三特性</h3><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>单独的隔离操作</td><td>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断</td></tr><tr><td>没有隔离级别的概念</td><td>队列中的命令没有提交之前都不会实际地被执行，因为事务提交前任何指令都不会被实际执行</td></tr><tr><td>不保证原子性</td><td>Redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos安装Redis</title>
      <link href="/posts/9d3a5b2a/"/>
      <url>/posts/9d3a5b2a/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Centos导入Redis安装包"><a href="#Centos导入Redis安装包" class="headerlink" title="Centos导入Redis安装包"></a>Centos导入Redis安装包</h2><div class="hide-toggle" style="border: 1px solid #e8fafe"><div class="hide-button toggle-title" style="background-color: #e8fafe;color: color"><i class="fas fa-caret-right fa-fw"></i><span>第一种方案</span></div>    <div class="hide-content"><h3 id="前往Redis官网下载安装包"><a href="#前往Redis官网下载安装包" class="headerlink" title="前往Redis官网下载安装包"></a>前往<a href="http://redi.io/">Redis官网</a>下载安装包</h3><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210722/1.4b8tzfon68k0.jpg" alt="1"></p><h3 id="通过Xftp将已下载好的安装包拖拽到centos的新建目录下"><a href="#通过Xftp将已下载好的安装包拖拽到centos的新建目录下" class="headerlink" title="通过Xftp将已下载好的安装包拖拽到centos的新建目录下"></a>通过Xftp将已下载好的安装包拖拽到centos的新建目录下</h3><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210722/2.kd9zl46gwc0.jpg" alt="2"></p><h3 id="查看安装包是否在选定目录下"><a href="#查看安装包是否在选定目录下" class="headerlink" title="查看安装包是否在选定目录下"></a>查看安装包是否在选定目录下</h3><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210722/3.6app3qipdg40.jpg" alt="3"></p></div></div><div class="hide-toggle" style="border: 1px solid #fff8e9"><div class="hide-button toggle-title" style="background-color: #fff8e9;color: color"><i class="fas fa-caret-right fa-fw"></i><span>第二种方案</span></div>    <div class="hide-content"><p>在Centos直接安装，下载之前，建议新建一个文件夹来存放安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-6.2.4.tar.gz   #下载最新版即可</span><br></pre></td></tr></table></figure></div></div><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>安装C语言的编译环境gcc</li></ol><p>依次输入以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install centos-release-scl scl-utils-build</span><br><span class="line">yum install -y devtollset-8-toolchain</span><br><span class="line">scl enable devtoolset-8 bash</span><br></pre></td></tr></table></figure><ol start="2"><li> 查看gcc是否安装成功</li></ol><p>检测gcc版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc --version</span><br></pre></td></tr></table></figure><p>安装成功如下:</p><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210722/4.1zo605jol5wg.jpg" alt="4"></p><h2 id="解压并安装"><a href="#解压并安装" class="headerlink" title="解压并安装"></a>解压并安装</h2><ol><li> 解压安装包<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf redis-6.2.4.tar.gz</span><br></pre></td></tr></table></figure></li><li> 解压完成后进入目录<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd redis-6.2.4</span><br></pre></td></tr></table></figure></li><li>在目录下执行make命令，编译成C文件</li></ol><div class="note info no-icon flat"><p>注意：如果没有安装C语言编译环境，make命令会报错</p><p>报错信息：jemalloc/jemalloc.h: 没有那个文件或目录</p><p>解决方案：检测gcc是否安装成功，并运行make distclean</p></div><ol start="4"><li>在目录下进行安装<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure></li></ol><h2 id="安装目录：-user-local-bin"><a href="#安装目录：-user-local-bin" class="headerlink" title="安装目录：/user/local/bin"></a>安装目录：/user/local/bin</h2><table><thead><tr><th align="left">文件名</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">redis-benchmark</td><td align="left">性能测试工具</td></tr><tr><td align="left">redis-check-aof</td><td align="left">修复有问题的AOF文件</td></tr><tr><td align="left">redis-check-rdb</td><td align="left">修复有问题的dump.rdb文件</td></tr><tr><td align="left">redis-sentinel</td><td align="left">Redis哨兵启动，用于主从复制、集群使用</td></tr><tr><td align="left"><font color='red'>redis-server</td><td align="left">Redis服务器启动</td></tr><tr><td align="left"><font color='red'>redis-cli</td><td align="left">Redis客户端，操作入口</td></tr></tbody></table><h2 id="前台启动（不推荐）"><a href="#前台启动（不推荐）" class="headerlink" title="前台启动（不推荐）"></a>前台启动（不推荐）</h2><p>运行redis-server命令启动，但命令行窗口不能关闭，否则服务器停止</p><h2 id="后台启动（推荐）"><a href="#后台启动（推荐）" class="headerlink" title="后台启动（推荐）"></a>后台启动（推荐）</h2><ol><li><p> 修改后台启动设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/redis-6.2.4             #进入redis目录下</span><br><span class="line">ls                              #查看文件</span><br><span class="line">cp redis.conf /etc/redis.conf   #为方便操作，复制redis.conf文件到其他目录下</span><br><span class="line">vim /opt/redis.conf             #进入编辑器修改文件</span><br></pre></td></tr></table></figure><p>在编辑器中通过<font color='red'>\daemonize</font>查找，将文件内的<font color='red'>daemonize no</font>改为<font color='red'>yes</font>，保存退出，使服务器能在后台启动</p></li><li><p> 后台启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /etc/redis.conf</span><br></pre></td></tr></table></figure></li><li><p> 查看进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure></li><li><p> 客户端通过输入<font color='red'>redis-cli</font>命令进行访问 </p></li></ol><div class="note info no-icon flat"><p>多个端口号可输入redis-cli -p 端口号</p></div><ol start="5"><li> 关闭后台Redis</li></ol><p>一、单实例关闭</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli shutdown</span><br></pre></td></tr></table></figure><p>二、多实例关闭，指定端口关闭</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 端口号 shutdown</span><br></pre></td></tr></table></figure><p>三、关闭Redis进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 进程号</span><br></pre></td></tr></table></figure><p>四、在Redis终端中输入shutdown进行关闭</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis详细概述</title>
      <link href="/posts/389b592e/"/>
      <url>/posts/389b592e/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="技术分类"><a href="#技术分类" class="headerlink" title="技术分类"></a>技术分类</h2><table><thead><tr><th align="left">解决问题类型</th><th align="left">技术</th></tr></thead><tbody><tr><td align="left">功能性</td><td align="left">JAVA、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN</td></tr><tr><td align="left">扩展性</td><td align="left">Struts、Spring、SpringMVC、Hibernate、Mybatis</td></tr><tr><td align="left">性能</td><td align="left">NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch</td></tr></tbody></table><p>随着web技术的不断发展，用户访问量的大幅度提升，同时也产生了大量的用户数据，加之智能移动设备的普及，<br>所有的互联网平台都面临着巨大的性能挑战。</p><div class="note danger no-icon flat"><p>web服务器面临着CPU及内存压力，数据库服务器面临着IO压力。</p></div><h2 id="问题及主要解决方案"><a href="#问题及主要解决方案" class="headerlink" title="问题及主要解决方案"></a>问题及主要解决方案</h2><div class="hide-toggle" style="border: 1px solid #e8fafe"><div class="hide-button toggle-title" style="background-color: #e8fafe;color: color"><i class="fas fa-caret-right fa-fw"></i><span>CPU及内存压力：主要为session存储问题</span></div>    <div class="hide-content"><p>但session应该存在哪里呢？</p><ol><li><p>存储在cookie中</p><p> 优点：极高的扩展性和可用性</p><p> 缺点：不安全</p></li><li><p>存储在文件服务器或者数据库里</p><p> 优点：简单高性能，支持分布式与集群</p><p> 缺点: 数据库的大量IO效率问题</p></li><li><p>session复制</p><p> 优点： 实现简单、配置较少、当网络中有机器Down掉时不影响用户访问</p><p> 缺点： 广播式复制有一定廷时，会带来一定网络开销；session对象内容相同，空间浪费造成session数据冗余，节点（服务器）越多浪费越大</p></li><li><p>存储在缓存数据库（例NoSQL数据库）</p><p> 优点： 不经过IO，减少访问数据库的频率，完全在内存中，速度快，数据结构简单，无形中缓解了CPU及内存压力</p></li></ol></div></div><div class="hide-toggle" style="border: 1px solid #fff8e9"><div class="hide-button toggle-title" style="background-color: #fff8e9;color: color"><i class="fas fa-caret-right fa-fw"></i><span>IO压力</span></div>    <div class="hide-content"><p>随着数据量的增多，数据库操作逐渐麻烦，效率也急剧降低</p><ol><li><p>数据库表进行拆分</p><p> 水平切分、垂直切分、读写分离，通过破坏一定的业务逻辑来换取性能</p></li><li><p>缓存数据库（例NoSQL数据库）</p><p> 通过添加缓存数据库，从中查询数据，从而减少IO的读操作，极大地提高查询效率</p></li></ol></div></div><h2 id="NoSQL数据库概述"><a href="#NoSQL数据库概述" class="headerlink" title="NoSQL数据库概述"></a>NoSQL数据库概述</h2><p>NoSQL(Not Only SQL)，意思为“不仅仅是SQL”，泛指非关系型数据库。</p><p>NoSQL相较于MySQL，它不依赖业务逻辑方式存储，而以简单的key-value模式存储，因此大大的增加了数据库的扩展能力。</p><ul><li>  不遵循SQL标准</li><li>  不支持ACID（即原子性、一致性、隔离性、持久性）</li><li>  远超于SQL的性能</li></ul><div class="note success flat"><p>NoSQL数据库打破了传统关系型数据库以业务逻辑为依据的存储模式，而是针对不同数据结构类型改为以性能为最有限的存储方式。</p></div><div class="hide-toggle" style="border: 1px solid #e8fafe"><div class="hide-button toggle-title" style="background-color: #e8fafe;color: color"><i class="fas fa-caret-right fa-fw"></i><span>适用场景</span></div>    <div class="hide-content"><ul><li>  对数据高并发读写，例如“购物秒杀系统”</li><li>  海量数据读写</li><li>  对数据高可扩展性的</li></ul></div></div><div class="hide-toggle" style="border: 1px solid #fff8e9"><div class="hide-button toggle-title" style="background-color: #fff8e9;color: color"><i class="fas fa-caret-right fa-fw"></i><span>不适用场景</span></div>    <div class="hide-content"><ul><li>  取代通过键查询，而是通过值来查询。 Key-Value数据库中根本没有通过值查询的途径。</li><li>  需要储存数据之间的关系。在Key-Value数据库中不能通过两个或以上的键来关联数据。</li><li>  事务的支持。在Key-Value数据库中故障产生时不可以进行回滚。</li></ul></div></div><h3 id="常见NoSQL数据库"><a href="#常见NoSQL数据库" class="headerlink" title="常见NoSQL数据库"></a>常见NoSQL数据库</h3><table><thead><tr><th>数据库名称</th><th>特点</th></tr></thead><tbody><tr><td>Memcache</td><td>1. 很早出现的NoSQL数据库<br>2. 多线程+锁的机制，数据库都在内存中，一般不持久化<br>3. 支持简单的key-value模式，支持类型单一<br>4. 一般是作为缓存数据库辅助持久化的数据库</td></tr><tr><td>Redis</td><td>1. 几乎覆盖了Memcache的绝大部分功能<br>2. 单线程+多路IO复用的机制，数据都在内存中，支持持久化，主要用作备份恢复<br>3. 除了支持简单的key-value模式，还支持多种数据结构的存储，如list、set、hash、zset等<br>4. 一般是作为缓存数据库辅助持久化的数据库</td></tr><tr><td>MongoDB</td><td>1. 文档型数据库<br>2. 数据都在内存中，若内存不足，则把不常用的数据存到硬盘<br>3. 虽然是key-value模式，但是对value（尤其是json）提供强大的查询功能<br>4. 支持二进制数据及大型对象<br>5. 可根据数据特点替代RDBMS，成为独立数据库，亦或配合RDBMS,存储特定数据</td></tr></tbody></table><div class="note orange icon simple"><i class="note-icon fas fa-battery-half"></i><p>看完上面对NoSQL的介绍，对Redis有一个大概了解了吧</p></div><h2 id="Redis概述"><a href="#Redis概述" class="headerlink" title="Redis概述"></a>Redis概述</h2><p>Redis是当今社会最受欢迎的NoSQL数据库之一，是一个使用ANSI C编写的开源，遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，且提供多种语言的API。</p><div class="note primary no-icon flat"><p>Redis具备以下特性：</p><ul><li>  开源C语言代码，支持单线程+多路IO复用，不依赖外部库，速度极快</li><li>  数据持久化，支持多种数据结构、编程语言</li><li>  高并发读写，支持lua脚本，主从复制</li><li>  高可用，支持分布式，理论上可以无限扩展 </li></ul></div><div class="note primary no-icon flat"><p>Redis的应用场景包括：<br>    缓存系统（“热点”数据：高频读、低频写)、计数器、消息队列系统、排行榜、社交网络和实时系统。</p></div><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: far fa-hand-point-right;color:  green larger">看看哪些大厂在使用Redis？  </button><span class="hide-content">github，twitter，微博，Stack Overflow，阿里巴巴，百度，腾讯，美团，搜狐...... </span></span>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156/"/>
      <url>/posts/4a17b156/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Welcome-to-my-blog"><a href="#Welcome-to-my-blog" class="headerlink" title="Welcome to my blog!"></a>Welcome to my blog!</h2><p> by zeker</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
