<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis学习日记（1）</title>
      <link href="/2021/07/27/Redis3-1/"/>
      <url>/2021/07/27/Redis3-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Redis键（key）"><a href="#Redis键（key）" class="headerlink" title="Redis键（key）"></a>Redis键（key）</h2><table><thead><tr><th align="left">命令</th><th>描述</th></tr></thead><tbody><tr><td align="left">keys *</td><td>查看当前库所有key</td></tr><tr><td align="left">exists <key></td><td>判断某个key是否存在</td></tr><tr><td align="left">type <key></td><td>查看key是什么类型</td></tr><tr><td align="left">del <key></td><td>删除指定的key数据</td></tr><tr><td align="left">expore <key> <time></td><td>为给定的key设置过期时间（单位秒）</td></tr><tr><td align="left">ttl <key></td><td>查看还有多少秒过期，-1表示永不过期，-2表示已过期</td></tr><tr><td align="left">select <index></td><td>切换当前数据库（共16个数据库，0为默认库）</td></tr><tr><td align="left">dbsize</td><td>查看当前数据库key的数量</td></tr><tr><td align="left">flushdb/flushall</td><td>清空当前库/全部库</td></tr></tbody></table><h2 id="Redis字符串（String）"><a href="#Redis字符串（String）" class="headerlink" title="Redis字符串（String）"></a>Redis字符串（String）</h2><p>String类型是二进制安全的，意味着Redis的String可包含任何数据，比如jpg图片或者序列化的对象。</p><p>一个Redis中字符串value最多可以是512M。</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>set <key> <value></td><td>添加键值对</td></tr><tr><td>get <key></td><td>查询对应键值</td></tr><tr><td>append <key> <value></td><td>将给定的value追加到原值的末尾</td></tr><tr><td>strlen <key></td><td>获得key的长度</td></tr><tr><td>setnx <key> <value></td><td>只有在key不存在时，才能设置key的值</td></tr><tr><td>incr/decr <key></td><td>将key中储存的数字值增/减（+/-） 1</td></tr><tr><td>incrby/decrby <key> &lt;步长&gt;</td><td>将key中储存的数字值增/减，自定义步长</td></tr><tr><td>mset <key1><value1><key2><value2>….</td><td>同时设置一个或多个key-value对</td></tr><tr><td>mget <key1><key2>….</td><td>同时获取一个或多个value</td></tr><tr><td>msetnx <key1><value1><key2><value2>….</td><td>同时设置一个或多个key-value对，当且仅当所有给定key都不存在</td></tr><tr><td>getrange <key> &lt;起始位置&gt;&lt;结束位置&gt;</td><td>获得值的范围（全部：get key 0 -1）</td></tr><tr><td>setrange <key>&lt;起始位置&gt;<value></td><td>用value覆写key所储存的字符串值，从起始位置开始（索引从0开始）</td></tr><tr><td>setnx <key> &lt;过期时间&gt;<value></td><td>设置键值的同时，设置过期时间（单位秒）</td></tr><tr><td>getset<key><value></td><td>设置新值同时获得旧值</td></tr></tbody></table><h2 id="Redis列表（List）"><a href="#Redis列表（List）" class="headerlink" title="Redis列表（List）"></a>Redis列表（List）</h2><p>单键多值，双向链表</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>lpush/rpush <key> <value1> <value2>….</td><td>从左边/右边插入一个或多个值</td></tr><tr><td>lpop/rpop  <key></td><td>从左边/右边吐出一个值。</td></tr><tr><td>rpoplpush  <key1> <key2></td><td>从key1列表右边吐出一个值，查到key2列表右边</td></tr><tr><td>lrange <key> <start> <stop></td><td>按照索引下标获得元素（从左到右）<br>（全部：lrange key 0 -1）</td></tr><tr><td>lindex <key> <index></td><td>按照索引下标获得元素（从左到右）</td></tr><tr><td>llen <key></td><td>获得列表的长度</td></tr><tr><td>linsert <key> before/after <value> <newvalue></td><td>在value的前/后面插入newvalue值</td></tr><tr><td>lrem <key> <n> <value></td><td>从左边删除n个value（从左到右）</td></tr><tr><td>lset <key> <index> <value></td><td>将列表key下标为index的值替换成value</td></tr></tbody></table><h2 id="Redis集合（Set）"><a href="#Redis集合（Set）" class="headerlink" title="Redis集合（Set）"></a>Redis集合（Set）</h2><p>Redis的集合Set是String类型的无序集合，与list类似是一个列表的功能，但set可以自动数据排重。底层是一个value为null的hash表，所以添加、删除、删除、查找的复杂度都为O(1)。</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>sadd <key> <member1> <member2>….</td><td>将一个或多个member元素加入到集合key中，已存在的member将被忽略</td></tr><tr><td>smembers <key></td><td>取出该集合的所有值</td></tr><tr><td>sismember <key> <member></td><td>判断集合key是否含有该member值，有则1，无则0</td></tr><tr><td>scard <key></td><td>返回该集合的元素个数</td></tr><tr><td>srem <key> <member1> <member2>….</td><td>删除集合中的某个元素</td></tr><tr><td>spop <key></td><td>随机从该集合中吐出一个值</td></tr><tr><td>srandmember <key> <n></td><td>随机从该集合中取出n个值。值不会从集合中删除</td></tr><tr><td>smove <source> <destination>  <member></td><td>把集合中的一个member值从一个集合移动到另一个集合中</td></tr><tr><td>sinter/sunion <key1> <key2></td><td>返回两个集合的交集/并集元素</td></tr><tr><td>sdiff <key1> <key2></td><td>返回两个集合的差集元素（key1中的，不包含key2中的）</td></tr></tbody></table><h2 id="Redis哈希（Hash）"><a href="#Redis哈希（Hash）" class="headerlink" title="Redis哈希（Hash）"></a>Redis哈希（Hash）</h2><p>Redis的Hash是一个String类型的field和value的映射表，hash适合用于存储对象，类似Java中的Map&lt;String, Object&gt;。</p><p>当key存储的value过多时，往往为了提高查询效率，例如用户ID为key，field有姓名、年龄、职业等信息，这是我们可以选择通过key(用户ID)+field(属性标签)就可以操作对应属性的数据。</p><p>类似于map套娃：&lt;String， &lt;Map&lt;key, value&gt;&gt;&gt;</p><p>好处：既不需要重复存储数据，避免了数据冗余，也不会带来序列化和并发修改控制的问题。</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>hset <key> <field> <value></td><td>给key集合中的field键赋值value，例：hset user:001 name zeker</td></tr><tr><td>hget <key> <field></td><td>从key集合中的fild中取出value</td></tr><tr><td>hmset <key> <field1> <value1> <field2> <value2>….</td><td>批量设置hash的值</td></tr><tr><td>hexists <key> <field></td><td>查看哈希表key中，给定field是否存在</td></tr><tr><td>hkeys <key></td><td>列出该hash集合的所有field</td></tr><tr><td>hvals <key></td><td>列出该hash集合的所有value</td></tr><tr><td>hincrby <key> <field> <increment></td><td>为哈希表key中的field的值加上增量increment（例：1 -1）</td></tr><tr><td>hsetnx <key> <field> <value></td><td>将哈希表key中的field的值设置为value，当且仅当field不存在</td></tr></tbody></table><h2 id="Redis有序集合（Zset）"><a href="#Redis有序集合（Zset）" class="headerlink" title="Redis有序集合（Zset）"></a>Redis有序集合（Zset）</h2><p>Redis有序集合Zset与普通集合Set相似，都是一个没有重复元素的字符串集合。</p><p>不同之处在于有序集合Zset的每个成员都关联了一个评分（score），这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。</p><p>集合中的成员是唯一的，但评分可以是重复的。这里例子可以为：排行榜</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>zadd <key> <score1> <member1> <score2> <member2>….</td><td>将一个或多个memeber元素及其score值加入到有序集key中</td></tr><tr><td>zrange <key> <start> <stop> [withscores]</td><td>返回有序集key中，下标在start与stop之间的元素(withscores可让分数与值返回到结果集</td></tr><tr><td>zrangebyscore key min max [withscoers]  [limit offset count]</td><td>返回有序集key中，所有score值介于min和max之间（包括等于min或max）的成员，有序集成员按score值递增（从小到大）次序排列</td></tr><tr><td>zrevrangebyscore key max min [withscoers]  [limit offset count]</td><td>dev：反转。意思同上，次序从大到小排列</td></tr><tr><td>zincrby <key> <increment> <member></td><td>为元素member的score加上增量increment</td></tr><tr><td>zrem <key> <member></td><td>删除该集合下指定值的元素</td></tr><tr><td>zcount <key> <min> <max></td><td>统计该集合中分数区间内的元素个数</td></tr><tr><td>zrank <key> <member></td><td>返回该元素member在集合中的排名，从0开始</td></tr></tbody></table><p>Zset底层中使用了两种数据结构：hash表与跳跃表</p><ol><li>hash表，作用就是关联元素value和权重score，保障元素value的唯一值，可以通过元素value找到相应的score值。</li><li>跳跃表，目的在于给元素value排序，根据score的范围获取元素列表，从而比普通列表查询效率更快。</li></ol><h2 id="Redis新数据类型"><a href="#Redis新数据类型" class="headerlink" title="Redis新数据类型"></a>Redis新数据类型</h2><h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><p>Redis提供Bitmaps这个”数据类型“可以实现对位的操作：</p><p>（1）Bitmaps本身不是一种数据结构，实际上就是字符串，但是它可以对字符串的位进行操作。、</p><p>（2）Bitmaps单独提供了一套命令，所以在Redis中使用Bitmaps和使用字符串的方法不太相同。可以Bitmaps想象成一个以位为单位数组，数组中的每个单元只能存0或者1，数组的下标在Bitmaps中叫做偏移量。单个Bitmaps的最大长度是512MB，即2^32个比特位。</p><p>合理地使用操作位能够有效地提高内存使用率和开发效率，并且可以极大地节省内存空间，举例如：用户访问，统计不同电话号码的个数以及布隆过滤法（URL的排重、垃圾邮箱地址的过滤）……</p><table><thead><tr><th>命令</th><th>描述</th><th></th></tr></thead><tbody><tr><td>setbit <key> <offset> <value></td><td>设置Bitmaps中某个偏移量offset的值value</td><td></td></tr><tr><td>getbit <key> <offset></td><td>获取Bitmaps中某个偏移量offset的值value</td><td></td></tr><tr><td>bitcount <key> [start end]</td><td>统计字符串从start字节到end字节比特值为1的数量</td><td></td></tr><tr><td>bitop and(or/not/xor) <destkey> [key….]</td><td>多个Bitmaps的and（交集）、or（并集）、not（非）、xor（异或）操作并将结果保存在destkey中</td><td></td></tr></tbody></table><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><blockquote><p>​        在工作当中，经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。<br>         但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？而这种求集合中不重复元素个数的问题称为基数问题。</p></blockquote><p>解决基数问题方案：</p><p>（1）数据存储在MySQL表中，使用distinct count计算不重复个数</p><p>（2）使用Redis提供的hash、set、bitmaps等数据结构来处理</p><p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。</p><p>为了能够降低一定的精度来平衡存储空间，Redis推出了HyperLogLog，一种用来做基数统计的算法。</p><p>其优点在于：</p><p>在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p><p>每个<code>HyperLogLog</code>键只需要花费 <code>12 KB</code>内存，就可以计算接近 <code>2^64</code> 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p><p>基数 = 数据集元素个数 - 重复数字个数</p><p>但是，因为<code>HyperLogLog</code>只会根据输入元素来计算基数，而不会储存输入元素本身，所以 <code>HyperLogLog</code>不能像集合那样，返回输入的各个元素。</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>padd <key> <element> [element….]</td><td>添加指定元素element到HyperLogLog中</td></tr><tr><td>pfcount <key> [key….]</td><td>计算key中的基数</td></tr><tr><td>pfmerge <destkey> <sourcekey> [sourcekey….]</td><td>将一个或多个key合并后的结果储存在另一个destkey中</td></tr></tbody></table><h3 id="Geospatital"><a href="#Geospatital" class="headerlink" title="Geospatital"></a>Geospatital</h3><p>Redis GEO，Geographic，地理信息的缩写。</p><p>主要用于存储地理位置信息，即经纬度（二维坐标），基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>geoadd <key> <longitude> <latitude> <member> [longitude latitude member….]</td><td>添加地理位置（经度、维度、名称）（有效经度：-180度到180度；有效纬度：-85.05112878度到85.05112878度）</td></tr><tr><td>geopos <key> <member> [member….]</td><td>获得指定地区member的坐标</td></tr><tr><td>geodist <key> <member1> <member2> [m|km|ft|mi]</td><td>获取两个指定地区位置之间的直线距离（单位：米|千米|英尺|英里，默认单位米）</td></tr><tr><td>georadius <key> <longitude> <latitude> radius    m|km|ft|mi</td><td>以给定的经纬度为中心找出某一半径radius内的元素</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
            <tag> 学习日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos安装Redis</title>
      <link href="/2021/07/22/Redis2/"/>
      <url>/2021/07/22/Redis2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Centos导入Redis安装包"><a href="#Centos导入Redis安装包" class="headerlink" title="Centos导入Redis安装包"></a>Centos导入Redis安装包</h2><div class="hide-toggle" style="border: 1px solid #e8fafe"><div class="hide-button toggle-title" style="background-color: #e8fafe;color: color"><i class="fas fa-caret-right fa-fw"></i><span>第一种方案</span></div>    <div class="hide-content"><h3 id="前往Redis官网下载安装包"><a href="#前往Redis官网下载安装包" class="headerlink" title="前往Redis官网下载安装包"></a>前往<a href="http://redi.io/">Redis官网</a>下载安装包</h3><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210722/1.4b8tzfon68k0.jpg" alt="1"></p><h3 id="通过Xftp将已下载好的安装包拖拽到centos的新建目录下"><a href="#通过Xftp将已下载好的安装包拖拽到centos的新建目录下" class="headerlink" title="通过Xftp将已下载好的安装包拖拽到centos的新建目录下"></a>通过Xftp将已下载好的安装包拖拽到centos的新建目录下</h3><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210722/2.kd9zl46gwc0.jpg" alt="2"></p><h3 id="查看安装包是否在选定目录下"><a href="#查看安装包是否在选定目录下" class="headerlink" title="查看安装包是否在选定目录下"></a>查看安装包是否在选定目录下</h3><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210722/3.6app3qipdg40.jpg" alt="3"></p></div></div><div class="hide-toggle" style="border: 1px solid #fff8e9"><div class="hide-button toggle-title" style="background-color: #fff8e9;color: color"><i class="fas fa-caret-right fa-fw"></i><span>第二种方案</span></div>    <div class="hide-content"><p>在Centos直接安装，下载之前，建议新建一个文件夹来存放安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-6.2.4.tar.gz   #下载最新版即可</span><br></pre></td></tr></table></figure></div></div><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>安装C语言的编译环境gcc</li></ol><p>依次输入以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install centos-release-scl scl-utils-build</span><br><span class="line">yum install -y devtollset-8-toolchain</span><br><span class="line">scl enable devtoolset-8 bash</span><br></pre></td></tr></table></figure><ol start="2"><li> 查看gcc是否安装成功</li></ol><p>检测gcc版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc --version</span><br></pre></td></tr></table></figure><p>安装成功如下:</p><p><img src="https://cdn.jsdelivr.net/gh/ZekerTop/images@main/20210722/4.1zo605jol5wg.jpg" alt="4"></p><h2 id="解压并安装"><a href="#解压并安装" class="headerlink" title="解压并安装"></a>解压并安装</h2><ol><li> 解压安装包<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf redis-6.2.4.tar.gz</span><br></pre></td></tr></table></figure></li><li> 解压完成后进入目录<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd redis-6.2.4</span><br></pre></td></tr></table></figure></li><li>在目录下执行make命令，编译成C文件</li></ol><div class="note info no-icon flat"><p>注意：如果没有安装C语言编译环境，make命令会报错</p><p>报错信息：jemalloc/jemalloc.h: 没有那个文件或目录</p><p>解决方案：检测gcc是否安装成功，并运行make distclean</p></div><ol start="4"><li>在目录下进行安装<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure></li></ol><h2 id="安装目录：-user-local-bin"><a href="#安装目录：-user-local-bin" class="headerlink" title="安装目录：/user/local/bin"></a>安装目录：/user/local/bin</h2><table><thead><tr><th align="left">文件名</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">redis-benchmark</td><td align="left">性能测试工具</td></tr><tr><td align="left">redis-check-aof</td><td align="left">修复有问题的AOF文件</td></tr><tr><td align="left">redis-check-rdb</td><td align="left">修复有问题的dump.rdb文件</td></tr><tr><td align="left">redis-sentinel</td><td align="left">Redis集群使用</td></tr><tr><td align="left"><font color='red'>redis-server</td><td align="left">Redis服务器启动</td></tr><tr><td align="left"><font color='red'>redis-cli</td><td align="left">客户端，操作入口</td></tr></tbody></table><h2 id="前台启动（不推荐）"><a href="#前台启动（不推荐）" class="headerlink" title="前台启动（不推荐）"></a>前台启动（不推荐）</h2><p>运行redis-server命令启动，但命令行窗口不能关闭，否则服务器停止</p><h2 id="后台启动（推荐）"><a href="#后台启动（推荐）" class="headerlink" title="后台启动（推荐）"></a>后台启动（推荐）</h2><ol><li><p> 修改后台启动设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/redis-6.2.4             #进入redis目录下</span><br><span class="line">ls                              #查看文件</span><br><span class="line">cp redis.conf /etc/redis.conf   #为方便操作，复制redis.conf文件到其他目录下</span><br><span class="line">vim /opt/redis.conf             #进入编辑器修改文件</span><br></pre></td></tr></table></figure><p>在编辑器中通过<font color='red'>\daemonize</font>查找，将文件内的<font color='red'>daemonize no</font>改为<font color='red'>yes</font>，保存退出，使服务器能在后台启动</p></li><li><p> 后台启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /etc/redis.conf</span><br></pre></td></tr></table></figure></li><li><p> 查看进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure></li><li><p> 客户端通过输入<font color='red'>redis-cli</font>命令进行访问 </p></li></ol><div class="note info no-icon flat"><p>多个端口号可输入redis-cli -p 端口号</p></div><ol start="5"><li> 关闭后台Redis</li></ol><p>一、单实例关闭</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli shutdown</span><br></pre></td></tr></table></figure><p>二、多实例关闭，指定端口关闭</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 端口号 shutdown</span><br></pre></td></tr></table></figure><p>三、关闭Redis进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 进程号</span><br></pre></td></tr></table></figure><p>四、在Redis终端中输入shutdown进行关闭</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis详细概述</title>
      <link href="/2021/07/22/Redis1/"/>
      <url>/2021/07/22/Redis1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="技术分类"><a href="#技术分类" class="headerlink" title="技术分类"></a>技术分类</h2><table><thead><tr><th align="left">解决问题类型</th><th align="left">技术</th></tr></thead><tbody><tr><td align="left">功能性</td><td align="left">JAVA、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN</td></tr><tr><td align="left">扩展性</td><td align="left">Struts、Spring、SpringMVC、Hibernate、Mybatis</td></tr><tr><td align="left">性能</td><td align="left">NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch</td></tr></tbody></table><p>随着web技术的不断发展，用户访问量的大幅度提升，同时也产生了大量的用户数据，加之智能移动设备的普及，<br>所有的互联网平台都面临着巨大的性能挑战。</p><div class="note danger no-icon flat"><p>web服务器面临着CPU及内存压力，数据库服务器面临着IO压力。</p></div><h2 id="问题及主要解决方案"><a href="#问题及主要解决方案" class="headerlink" title="问题及主要解决方案"></a>问题及主要解决方案</h2><div class="hide-toggle" style="border: 1px solid #e8fafe"><div class="hide-button toggle-title" style="background-color: #e8fafe;color: color"><i class="fas fa-caret-right fa-fw"></i><span>CPU及内存压力：主要为session存储问题</span></div>    <div class="hide-content"><p>但session应该存在哪里呢？</p><ol><li><p>存储在cookie中</p><p> 优点：极高的扩展性和可用性</p><p> 缺点：不安全</p></li><li><p>存储在文件服务器或者数据库里</p><p> 优点：简单高性能，支持分布式与集群</p><p> 缺点: 数据库的大量IO效率问题</p></li><li><p>session复制</p><p> 优点： 实现简单、配置较少、当网络中有机器Down掉时不影响用户访问</p><p> 缺点： 广播式复制有一定廷时，会带来一定网络开销；session对象内容相同，空间浪费造成session数据冗余，节点（服务器）越多浪费越大</p></li><li><p>存储在缓存数据库（例NoSQL数据库）</p><p> 优点： 不经过IO，减少访问数据库的频率，完全在内存中，速度快，数据结构简单，无形中缓解了CPU及内存压力</p></li></ol></div></div><div class="hide-toggle" style="border: 1px solid #fff8e9"><div class="hide-button toggle-title" style="background-color: #fff8e9;color: color"><i class="fas fa-caret-right fa-fw"></i><span>IO压力</span></div>    <div class="hide-content"><p>随着数据量的增多，数据库操作逐渐麻烦，效率也急剧降低</p><ol><li><p>数据库表进行拆分</p><p> 水平切分、垂直切分、读写分离，通过破坏一定的业务逻辑来换取性能</p></li><li><p>缓存数据库（例NoSQL数据库）</p><p> 通过添加缓存数据库，从中查询数据，从而减少IO的读操作，极大地提高查询效率</p></li></ol></div></div><h2 id="NoSQL数据库概述"><a href="#NoSQL数据库概述" class="headerlink" title="NoSQL数据库概述"></a>NoSQL数据库概述</h2><p>NoSQL(Not Only SQL)，意思为“不仅仅是SQL”，泛指非关系型数据库。</p><p>NoSQL相较于MySQL，它不依赖业务逻辑方式存储，而以简单的key-value模式存储，因此大大的增加了数据库的扩展能力。</p><ul><li>  不遵循SQL标准</li><li>  不支持ACID（即原子性、一致性、隔离性、持久性）</li><li>  远超于SQL的性能</li></ul><div class="note success flat"><p>NoSQL数据库打破了传统关系型数据库以业务逻辑为依据的存储模式，而是针对不同数据结构类型改为以性能为最有限的存储方式。</p></div><div class="hide-toggle" style="border: 1px solid #e8fafe"><div class="hide-button toggle-title" style="background-color: #e8fafe;color: color"><i class="fas fa-caret-right fa-fw"></i><span>适用场景</span></div>    <div class="hide-content"><ul><li>  对数据高并发读写，例如“购物秒杀系统”</li><li>  海量数据读写</li><li>  对数据高可扩展性的</li></ul></div></div><div class="hide-toggle" style="border: 1px solid #fff8e9"><div class="hide-button toggle-title" style="background-color: #fff8e9;color: color"><i class="fas fa-caret-right fa-fw"></i><span>不适用场景</span></div>    <div class="hide-content"><ul><li>  取代通过键查询，而是通过值来查询。 Key-Value数据库中根本没有通过值查询的途径。</li><li>  需要储存数据之间的关系。在Key-Value数据库中不能通过两个或以上的键来关联数据。</li><li>  事务的支持。在Key-Value数据库中故障产生时不可以进行回滚。</li></ul></div></div><h3 id="常见NoSQL数据库"><a href="#常见NoSQL数据库" class="headerlink" title="常见NoSQL数据库"></a>常见NoSQL数据库</h3><table><thead><tr><th>数据库名称</th><th>特点</th></tr></thead><tbody><tr><td>Memcache</td><td>1. 很早出现的NoSQL数据库<br>2. 多线程+锁的机制，数据库都在内存中，一般不持久化<br>3. 支持简单的key-value模式，支持类型单一<br>4. 一般是作为缓存数据库辅助持久化的数据库</td></tr><tr><td>Redis</td><td>1. 几乎覆盖了Memcache的绝大部分功能<br>2. 单线程+多路IO复用的机制，数据都在内存中，支持持久化，主要用作备份恢复<br>3. 除了支持简单的key-value模式，还支持多种数据结构的存储，如list、set、hash、zset等<br>4. 一般是作为缓存数据库辅助持久化的数据库</td></tr><tr><td>MongoDB</td><td>1. 文档型数据库<br>2. 数据都在内存中，若内存不足，则把不常用的数据存到硬盘<br>3. 虽然是key-value模式，但是对value（尤其是json）提供强大的查询功能<br>4. 支持二进制数据及大型对象<br>5. 可根据数据特点替代RDBMS，成为独立数据库，亦或配合RDBMS,存储特定数据</td></tr></tbody></table><div class="note orange icon simple"><i class="note-icon fas fa-battery-half"></i><p>看完上面对NoSQL的介绍，对Redis有一个大概了解了吧</p></div><h2 id="Redis概述"><a href="#Redis概述" class="headerlink" title="Redis概述"></a>Redis概述</h2><p>Redis是当今社会最受欢迎的NoSQL数据库之一，是一个使用ANSI C编写的开源，遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，且提供多种语言的API。</p><div class="note primary no-icon flat"><p>Redis具备以下特性：</p><ul><li>  开源C语言代码，支持单线程+多路IO复用，不依赖外部库，速度极快</li><li>  数据持久化，支持多种数据结构、编程语言</li><li>  高并发读写，支持lua脚本，主从复制</li><li>  高可用，支持分布式，理论上可以无限扩展 </li></ul></div><div class="note primary no-icon flat"><p>Redis的应用场景包括：<br>    缓存系统（“热点”数据：高频读、低频写)、计数器、消息队列系统、排行榜、社交网络和实时系统。</p></div><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: far fa-hand-point-right;color:  green larger">看看哪些大厂在使用Redis？  </button><span class="hide-content">github，twitter，微博，Stack Overflow，阿里巴巴，百度，腾讯，美团，搜狐...... </span></span>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/07/16/hello-world/"/>
      <url>/2021/07/16/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Welcome-to-my-blog"><a href="#Welcome-to-my-blog" class="headerlink" title="Welcome to my blog!"></a>Welcome to my blog!</h2><p> by zeker</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
